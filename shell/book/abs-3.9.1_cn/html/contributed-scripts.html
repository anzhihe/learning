<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>捐献的脚本</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="高级Bash脚本编程指南"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="参考文献"
HREF="biblio.html"><LINK
REL="NEXT"
TITLE="参考卡片"
HREF="refcards.html"></HEAD
><BODY
CLASS="APPENDIX"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>高级Bash脚本编程指南: 一本深入学习shell脚本艺术的书籍</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="biblio.html"
ACCESSKEY="P"
>前一页</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="refcards.html"
ACCESSKEY="N"
>下一页</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="APPENDIX"
><H1
><A
NAME="CONTRIBUTED-SCRIPTS"
></A
>Appendix A. 捐献的脚本</H1
><P
>这些脚本展示了一些有趣的shell编程技术, 但是它们并不适合放入本文档的文本讲解中. 
    不过它们还是非常有用, 运行和分析它们都是很有意思的事. </P
><P
>译者: 这里留给那些有能力而且有多余时间的读者来详读, 个人认为翻译这些注释有点画蛇添足. </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="MAILFORMAT"
></A
><P
><B
>例子 A-1. <B
CLASS="COMMAND"
>mailformat</B
>: 格式化一个e-mail消息</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# mail-format.sh (ver. 1.1): Format e-mail messages.
  3&nbsp;
  4&nbsp;# Gets rid of carets, tabs, and also folds excessively long lines.
  5&nbsp;
  6&nbsp;# =================================================================
  7&nbsp;#                 Standard Check for Script Argument(s)
  8&nbsp;ARGS=1
  9&nbsp;E_BADARGS=65
 10&nbsp;E_NOFILE=66
 11&nbsp;
 12&nbsp;if [ $# -ne $ARGS ]  # Correct number of arguments passed to script?
 13&nbsp;then
 14&nbsp;  echo "Usage: `basename $0` filename"
 15&nbsp;  exit $E_BADARGS
 16&nbsp;fi
 17&nbsp;
 18&nbsp;if [ -f "$1" ]       # Check if file exists.
 19&nbsp;then
 20&nbsp;    file_name=$1
 21&nbsp;else
 22&nbsp;    echo "File \"$1\" does not exist."
 23&nbsp;    exit $E_NOFILE
 24&nbsp;fi
 25&nbsp;# =================================================================
 26&nbsp;
 27&nbsp;MAXWIDTH=70          # Width to fold excessively long lines to.
 28&nbsp;
 29&nbsp;# ---------------------------------
 30&nbsp;# A variable can hold a sed script.
 31&nbsp;sedscript='s/^&#62;//
 32&nbsp;s/^  *&#62;//
 33&nbsp;s/^  *//
 34&nbsp;s/		*//'
 35&nbsp;# ---------------------------------
 36&nbsp;
 37&nbsp;#  Delete carets and tabs at beginning of lines,
 38&nbsp;#+ then fold lines to $MAXWIDTH characters.
 39&nbsp;sed "$sedscript" $1 | fold -s --width=$MAXWIDTH
 40&nbsp;                        #  -s option to "fold"
 41&nbsp;                        #+ breaks lines at whitespace, if possible.
 42&nbsp;
 43&nbsp;
 44&nbsp;#  This script was inspired by an article in a well-known trade journal
 45&nbsp;#+ extolling a 164K MS Windows utility with similar functionality.
 46&nbsp;#
 47&nbsp;#  An nice set of text processing utilities and an efficient
 48&nbsp;#+ scripting language provide an alternative to bloated executables.
 49&nbsp;
 50&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="RN"
></A
><P
><B
>例子 A-2. <B
CLASS="COMMAND"
>rn</B
>: 一个非常简单的文件重命名工具</B
></P
><P
>这个脚本是<A
HREF="textproc.html#LOWERCASE"
>例子 12-19</A
>的一个修改版. </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#! /bin/bash
  2&nbsp;#
  3&nbsp;# Very simpleminded filename "rename" utility (based on "lowercase.sh").
  4&nbsp;#
  5&nbsp;#  The "ren" utility, by Vladimir Lanin (lanin@csd2.nyu.edu),
  6&nbsp;#+ does a much better job of this.
  7&nbsp;
  8&nbsp;
  9&nbsp;ARGS=2
 10&nbsp;E_BADARGS=65
 11&nbsp;ONE=1                     # For getting singular/plural right (see below).
 12&nbsp;
 13&nbsp;if [ $# -ne "$ARGS" ]
 14&nbsp;then
 15&nbsp;  echo "Usage: `basename $0` old-pattern new-pattern"
 16&nbsp;  # As in "rn gif jpg", which renames all gif files in working directory to jpg.
 17&nbsp;  exit $E_BADARGS
 18&nbsp;fi
 19&nbsp;
 20&nbsp;number=0                  # Keeps track of how many files actually renamed.
 21&nbsp;
 22&nbsp;
 23&nbsp;for filename in *$1*      #Traverse all matching files in directory.
 24&nbsp;do
 25&nbsp;   if [ -f "$filename" ]  # If finds match...
 26&nbsp;   then
 27&nbsp;     fname=`basename $filename`            # Strip off path.
 28&nbsp;     n=`echo $fname | sed -e "s/$1/$2/"`   # Substitute new for old in filename.
 29&nbsp;     mv $fname $n                          # Rename.
 30&nbsp;     let "number += 1"
 31&nbsp;   fi
 32&nbsp;done   
 33&nbsp;
 34&nbsp;if [ "$number" -eq "$ONE" ]                # For correct grammar.
 35&nbsp;then
 36&nbsp; echo "$number file renamed."
 37&nbsp;else 
 38&nbsp; echo "$number files renamed."
 39&nbsp;fi 
 40&nbsp;
 41&nbsp;exit 0
 42&nbsp;
 43&nbsp;
 44&nbsp;# Exercises:
 45&nbsp;# ---------
 46&nbsp;# What type of files will this not work on?
 47&nbsp;# How can this be fixed?
 48&nbsp;#
 49&nbsp;#  Rewrite this script to process all the files in a directory
 50&nbsp;#+ containing spaces in their names, and to rename them,
 51&nbsp;#+ substituting an underscore for each space.</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="BLANKRENAME"
></A
><P
><B
>例子 A-3. <B
CLASS="COMMAND"
>blank-rename</B
>: 重命名包含空白的文件名</B
></P
><P
>这是上一个脚本的简化版. </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#! /bin/bash
  2&nbsp;# blank-rename.sh
  3&nbsp;#
  4&nbsp;# Substitutes underscores for blanks in all the filenames in a directory.
  5&nbsp;
  6&nbsp;ONE=1                     # For getting singular/plural right (see below).
  7&nbsp;number=0                  # Keeps track of how many files actually renamed.
  8&nbsp;FOUND=0                   # Successful return value.
  9&nbsp;
 10&nbsp;for filename in *         #Traverse all files in directory.
 11&nbsp;do
 12&nbsp;     echo "$filename" | grep -q " "         #  Check whether filename
 13&nbsp;     if [ $? -eq $FOUND ]                   #+ contains space(s).
 14&nbsp;     then
 15&nbsp;       fname=$filename                      # Strip off path.
 16&nbsp;       n=`echo $fname | sed -e "s/ /_/g"`   # Substitute underscore for blank.
 17&nbsp;       mv "$fname" "$n"                     # Do the actual renaming.
 18&nbsp;       let "number += 1"
 19&nbsp;     fi
 20&nbsp;done   
 21&nbsp;
 22&nbsp;if [ "$number" -eq "$ONE" ]                 # For correct grammar.
 23&nbsp;then
 24&nbsp; echo "$number file renamed."
 25&nbsp;else 
 26&nbsp; echo "$number files renamed."
 27&nbsp;fi 
 28&nbsp;
 29&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ENCRYPTEDPW"
></A
><P
><B
>例子 A-4. <B
CLASS="COMMAND"
>encryptedpw</B
>: 使用一个本地加密口令, 上传到一个ftp服务器. </B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;
  3&nbsp;# Example "ex72.sh" modified to use encrypted password.
  4&nbsp;
  5&nbsp;#  Note that this is still rather insecure,
  6&nbsp;#+ since the decrypted password is sent in the clear.
  7&nbsp;#  Use something like "ssh" if this is a concern.
  8&nbsp;
  9&nbsp;E_BADARGS=65
 10&nbsp;
 11&nbsp;if [ -z "$1" ]
 12&nbsp;then
 13&nbsp;  echo "Usage: `basename $0` filename"
 14&nbsp;  exit $E_BADARGS
 15&nbsp;fi  
 16&nbsp;
 17&nbsp;Username=bozo           # Change to suit.
 18&nbsp;pword=/home/bozo/secret/password_encrypted.file
 19&nbsp;# File containing encrypted password.
 20&nbsp;
 21&nbsp;Filename=`basename $1`  # Strips pathname out of file name.
 22&nbsp;
 23&nbsp;Server="XXX"
 24&nbsp;Directory="YYY"         # Change above to actual server name &#38; directory.
 25&nbsp;
 26&nbsp;
 27&nbsp;Password=`cruft &#60;$pword`          # Decrypt password.
 28&nbsp;#  Uses the author's own "cruft" file encryption package,
 29&nbsp;#+ based on the classic "onetime pad" algorithm,
 30&nbsp;#+ and obtainable from:
 31&nbsp;#+ Primary-site:   ftp://ibiblio.org/pub/Linux/utils/file
 32&nbsp;#+                 cruft-0.2.tar.gz [16k]
 33&nbsp;
 34&nbsp;
 35&nbsp;ftp -n $Server &#60;&#60;End-Of-Session
 36&nbsp;user $Username $Password
 37&nbsp;binary
 38&nbsp;bell
 39&nbsp;cd $Directory
 40&nbsp;put $Filename
 41&nbsp;bye
 42&nbsp;End-Of-Session
 43&nbsp;# -n option to "ftp" disables auto-logon.
 44&nbsp;# Note that "bell" rings 'bell' after each file transfer.
 45&nbsp;
 46&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="COPYCD"
></A
><P
><B
>例子 A-5. <B
CLASS="COMMAND"
>copy-cd</B
>: 拷贝一个数据CD</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# copy-cd.sh: copying a data CD
  3&nbsp;
  4&nbsp;CDROM=/dev/cdrom                           # CD ROM device
  5&nbsp;OF=/home/bozo/projects/cdimage.iso         # output file
  6&nbsp;#       /xxxx/xxxxxxx/                     Change to suit your system.
  7&nbsp;BLOCKSIZE=2048
  8&nbsp;SPEED=2                                    # May use higher speed if supported.
  9&nbsp;DEVICE=cdrom
 10&nbsp;# DEVICE="0,0"    on older versions of cdrecord.
 11&nbsp;
 12&nbsp;echo; echo "Insert source CD, but do *not* mount it."
 13&nbsp;echo "Press ENTER when ready. "
 14&nbsp;read ready                                 # Wait for input, $ready not used.
 15&nbsp;
 16&nbsp;echo; echo "Copying the source CD to $OF."
 17&nbsp;echo "This may take a while. Please be patient."
 18&nbsp;
 19&nbsp;dd if=$CDROM of=$OF bs=$BLOCKSIZE          # Raw device copy.
 20&nbsp;
 21&nbsp;
 22&nbsp;echo; echo "Remove data CD."
 23&nbsp;echo "Insert blank CDR."
 24&nbsp;echo "Press ENTER when ready. "
 25&nbsp;read ready                                 # Wait for input, $ready not used.
 26&nbsp;
 27&nbsp;echo "Copying $OF to CDR."
 28&nbsp;
 29&nbsp;cdrecord -v -isosize speed=$SPEED dev=$DEVICE $OF
 30&nbsp;# Uses Joerg Schilling's "cdrecord" package (see its docs).
 31&nbsp;# http://www.fokus.gmd.de/nthp/employees/schilling/cdrecord.html
 32&nbsp;
 33&nbsp;
 34&nbsp;echo; echo "Done copying $OF to CDR on device $CDROM."
 35&nbsp;
 36&nbsp;echo "Do you want to erase the image file (y/n)? "  # Probably a huge file.
 37&nbsp;read answer
 38&nbsp;
 39&nbsp;case "$answer" in
 40&nbsp;[yY]) rm -f $OF
 41&nbsp;      echo "$OF erased."
 42&nbsp;      ;;
 43&nbsp;*)    echo "$OF not erased.";;
 44&nbsp;esac
 45&nbsp;
 46&nbsp;echo
 47&nbsp;
 48&nbsp;# Exercise:
 49&nbsp;# Change the above "case" statement to also accept "yes" and "Yes" as input.
 50&nbsp;
 51&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="COLLATZ"
></A
><P
><B
>例子 A-6. Collatz序列</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# collatz.sh
  3&nbsp;
  4&nbsp;#  The notorious "hailstone" or Collatz series.
  5&nbsp;#  -------------------------------------------
  6&nbsp;#  1) Get the integer "seed" from the command line.
  7&nbsp;#  2) NUMBER &#60;--- seed
  8&nbsp;#  3) Print NUMBER.
  9&nbsp;#  4)  If NUMBER is even, divide by 2, or
 10&nbsp;#  5)+ if odd, multiply by 3 and add 1.
 11&nbsp;#  6) NUMBER &#60;--- result 
 12&nbsp;#  7) Loop back to step 3 (for specified number of iterations).
 13&nbsp;#
 14&nbsp;#  The theory is that every sequence,
 15&nbsp;#+ no matter how large the initial value,
 16&nbsp;#+ eventually settles down to repeating "4,2,1..." cycles,
 17&nbsp;#+ even after fluctuating through a wide range of values.
 18&nbsp;#
 19&nbsp;#  This is an instance of an "iterate",
 20&nbsp;#+ an operation that feeds its output back into the input.
 21&nbsp;#  Sometimes the result is a "chaotic" series.
 22&nbsp;
 23&nbsp;
 24&nbsp;MAX_ITERATIONS=200
 25&nbsp;# For large seed numbers (&#62;32000), increase MAX_ITERATIONS.
 26&nbsp;
 27&nbsp;h=${1:-$$}                      #  Seed
 28&nbsp;                                #  Use $PID as seed,
 29&nbsp;                                #+ if not specified as command-line arg.
 30&nbsp;
 31&nbsp;echo
 32&nbsp;echo "C($h) --- $MAX_ITERATIONS Iterations"
 33&nbsp;echo
 34&nbsp;
 35&nbsp;for ((i=1; i&#60;=MAX_ITERATIONS; i++))
 36&nbsp;do
 37&nbsp;
 38&nbsp;echo -n "$h	"
 39&nbsp;#          ^^^^^
 40&nbsp;#           tab
 41&nbsp;
 42&nbsp;  let "remainder = h % 2"
 43&nbsp;  if [ "$remainder" -eq 0 ]   # Even?
 44&nbsp;  then
 45&nbsp;    let "h /= 2"              # Divide by 2.
 46&nbsp;  else
 47&nbsp;    let "h = h*3 + 1"         # Multiply by 3 and add 1.
 48&nbsp;  fi
 49&nbsp;
 50&nbsp;
 51&nbsp;COLUMNS=10                    # Output 10 values per line.
 52&nbsp;let "line_break = i % $COLUMNS"
 53&nbsp;if [ "$line_break" -eq 0 ]
 54&nbsp;then
 55&nbsp;  echo
 56&nbsp;fi  
 57&nbsp;
 58&nbsp;done
 59&nbsp;
 60&nbsp;echo
 61&nbsp;
 62&nbsp;#  For more information on this mathematical function,
 63&nbsp;#+ see "Computers, Pattern, Chaos, and Beauty", by Pickover, p. 185 ff.,
 64&nbsp;#+ as listed in the bibliography.
 65&nbsp;
 66&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="DAYSBETWEEN"
></A
><P
><B
>例子 A-7. <B
CLASS="COMMAND"
>days-between</B
>: 计算两个日期之间天数差</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# days-between.sh:    Number of days between two dates.
  3&nbsp;# Usage: ./days-between.sh [M]M/[D]D/YYYY [M]M/[D]D/YYYY
  4&nbsp;#
  5&nbsp;# Note: Script modified to account for changes in Bash 2.05b
  6&nbsp;#+      that closed the loophole permitting large negative
  7&nbsp;#+      integer return values.
  8&nbsp;
  9&nbsp;ARGS=2                # Two command line parameters expected.
 10&nbsp;E_PARAM_ERR=65        # Param error.
 11&nbsp;
 12&nbsp;REFYR=1600            # Reference year.
 13&nbsp;CENTURY=100
 14&nbsp;DIY=365
 15&nbsp;ADJ_DIY=367           # Adjusted for leap year + fraction.
 16&nbsp;MIY=12
 17&nbsp;DIM=31
 18&nbsp;LEAPCYCLE=4
 19&nbsp;
 20&nbsp;MAXRETVAL=255         #  Largest permissable
 21&nbsp;                      #+ positive return value from a function.
 22&nbsp;
 23&nbsp;diff=                 # Declare global variable for date difference.
 24&nbsp;value=                # Declare global variable for absolute value.
 25&nbsp;day=                  # Declare globals for day, month, year.
 26&nbsp;month=
 27&nbsp;year=
 28&nbsp;
 29&nbsp;
 30&nbsp;Param_Error ()        # Command line parameters wrong.
 31&nbsp;{
 32&nbsp;  echo "Usage: `basename $0` [M]M/[D]D/YYYY [M]M/[D]D/YYYY"
 33&nbsp;  echo "       (date must be after 1/3/1600)"
 34&nbsp;  exit $E_PARAM_ERR
 35&nbsp;}  
 36&nbsp;
 37&nbsp;
 38&nbsp;Parse_Date ()                 # Parse date from command line params.
 39&nbsp;{
 40&nbsp;  month=${1%%/**}
 41&nbsp;  dm=${1%/**}                 # Day and month.
 42&nbsp;  day=${dm#*/}
 43&nbsp;  let "year = `basename $1`"  # Not a filename, but works just the same.
 44&nbsp;}  
 45&nbsp;
 46&nbsp;
 47&nbsp;check_date ()                 # Checks for invalid date(s) passed.
 48&nbsp;{
 49&nbsp;  [ "$day" -gt "$DIM" ] || [ "$month" -gt "$MIY" ] || [ "$year" -lt "$REFYR" ] &#38;&#38; Param_Error
 50&nbsp;  # Exit script on bad value(s).
 51&nbsp;  # Uses "or-list / and-list".
 52&nbsp;  #
 53&nbsp;  # Exercise: Implement more rigorous date checking.
 54&nbsp;}
 55&nbsp;
 56&nbsp;
 57&nbsp;strip_leading_zero () #  Better to strip possible leading zero(s)
 58&nbsp;{                     #+ from day and/or month
 59&nbsp;  return ${1#0}       #+ since otherwise Bash will interpret them
 60&nbsp;}                     #+ as octal values (POSIX.2, sect 2.9.2.1).
 61&nbsp;
 62&nbsp;
 63&nbsp;day_index ()          # Gauss' Formula:
 64&nbsp;{                     # Days from Jan. 3, 1600 to date passed as param.
 65&nbsp;
 66&nbsp;  day=$1
 67&nbsp;  month=$2
 68&nbsp;  year=$3
 69&nbsp;
 70&nbsp;  let "month = $month - 2"
 71&nbsp;  if [ "$month" -le 0 ]
 72&nbsp;  then
 73&nbsp;    let "month += 12"
 74&nbsp;    let "year -= 1"
 75&nbsp;  fi  
 76&nbsp;
 77&nbsp;  let "year -= $REFYR"
 78&nbsp;  let "indexyr = $year / $CENTURY"
 79&nbsp;
 80&nbsp;
 81&nbsp;  let "Days = $DIY*$year + $year/$LEAPCYCLE - $indexyr + $indexyr/$LEAPCYCLE + $ADJ_DIY*$month/$MIY + $day - $DIM"
 82&nbsp;  #  For an in-depth explanation of this algorithm, see
 83&nbsp;  #+ http://home.t-online.de/home/berndt.schwerdtfeger/cal.htm
 84&nbsp;
 85&nbsp;
 86&nbsp;  echo $Days
 87&nbsp;
 88&nbsp;}  
 89&nbsp;
 90&nbsp;
 91&nbsp;calculate_difference ()            # Difference between to day indices.
 92&nbsp;{
 93&nbsp;  let "diff = $1 - $2"             # Global variable.
 94&nbsp;}  
 95&nbsp;
 96&nbsp;
 97&nbsp;abs ()                             #  Absolute value
 98&nbsp;{                                  #  Uses global "value" variable.
 99&nbsp;  if [ "$1" -lt 0 ]                #  If negative
100&nbsp;  then                             #+ then
101&nbsp;    let "value = 0 - $1"           #+ change sign,
102&nbsp;  else                             #+ else
103&nbsp;    let "value = $1"               #+ leave it alone.
104&nbsp;  fi
105&nbsp;}
106&nbsp;
107&nbsp;
108&nbsp;
109&nbsp;if [ $# -ne "$ARGS" ]              # Require two command line params.
110&nbsp;then
111&nbsp;  Param_Error
112&nbsp;fi  
113&nbsp;
114&nbsp;Parse_Date $1
115&nbsp;check_date $day $month $year       #  See if valid date.
116&nbsp;
117&nbsp;strip_leading_zero $day            #  Remove any leading zeroes
118&nbsp;day=$?                             #+ on day and/or month.
119&nbsp;strip_leading_zero $month
120&nbsp;month=$?
121&nbsp;
122&nbsp;let "date1 = `day_index $day $month $year`"
123&nbsp;
124&nbsp;
125&nbsp;Parse_Date $2
126&nbsp;check_date $day $month $year
127&nbsp;
128&nbsp;strip_leading_zero $day
129&nbsp;day=$?
130&nbsp;strip_leading_zero $month
131&nbsp;month=$?
132&nbsp;
133&nbsp;date2=$(day_index $day $month $year) # Command substitution.
134&nbsp;
135&nbsp;
136&nbsp;calculate_difference $date1 $date2
137&nbsp;
138&nbsp;abs $diff                            # Make sure it's positive.
139&nbsp;diff=$value
140&nbsp;
141&nbsp;echo $diff
142&nbsp;
143&nbsp;exit 0
144&nbsp;#  Compare this script with
145&nbsp;#+ the implementation of Gauss' Formula in a C program at:
146&nbsp;#+    http://buschencrew.hypermart.net/software/datedif</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="MAKEDICT"
></A
><P
><B
>例子 A-8. 构造一个<SPAN
CLASS="QUOTE"
>"字典"</SPAN
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# makedict.sh  [make dictionary]
  3&nbsp;
  4&nbsp;# Modification of /usr/sbin/mkdict script.
  5&nbsp;# Original script copyright 1993, by Alec Muffett.
  6&nbsp;#
  7&nbsp;#  This modified script included in this document in a manner
  8&nbsp;#+ consistent with the "LICENSE" document of the "Crack" package
  9&nbsp;#+ that the original script is a part of.
 10&nbsp;
 11&nbsp;#  This script processes text files to produce a sorted list
 12&nbsp;#+ of words found in the files.
 13&nbsp;#  This may be useful for compiling dictionaries
 14&nbsp;#+ and for lexicographic research.
 15&nbsp;
 16&nbsp;
 17&nbsp;E_BADARGS=65
 18&nbsp;
 19&nbsp;if [ ! -r "$1" ]                     #  Need at least one
 20&nbsp;then                                 #+ valid file argument.
 21&nbsp;  echo "Usage: $0 files-to-process"
 22&nbsp;  exit $E_BADARGS
 23&nbsp;fi  
 24&nbsp;
 25&nbsp;
 26&nbsp;# SORT="sort"                        #  No longer necessary to define options
 27&nbsp;                                     #+ to sort. Changed from original script.
 28&nbsp;
 29&nbsp;cat $* |                             # Contents of specified files to stdout.
 30&nbsp;        tr A-Z a-z |                 # Convert to lowercase.
 31&nbsp;        tr ' ' '\012' |              # New: change spaces to newlines.
 32&nbsp;#       tr -cd '\012[a-z][0-9]' |    #  Get rid of everything non-alphanumeric
 33&nbsp;                                     #+ (original script).
 34&nbsp;        tr -c '\012a-z'  '\012' |    #  Rather than deleting
 35&nbsp;                                     #+ now change non-alpha to newlines.
 36&nbsp;        sort |                       # $SORT options unnecessary now.
 37&nbsp;        uniq |                       # Remove duplicates.
 38&nbsp;        grep -v '^#' |               # Delete lines beginning with a hashmark.
 39&nbsp;        grep -v '^$'                 # Delete blank lines.
 40&nbsp;
 41&nbsp;exit 0	</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="SOUNDEX"
></A
><P
><B
>例子 A-9. Soundex转换</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# soundex.sh: Calculate "soundex" code for names
  3&nbsp;
  4&nbsp;# =======================================================
  5&nbsp;#        Soundex script
  6&nbsp;#              by
  7&nbsp;#         Mendel Cooper
  8&nbsp;#     thegrendel@theriver.com
  9&nbsp;#       23 January, 2002
 10&nbsp;#
 11&nbsp;#   Placed in the Public Domain.
 12&nbsp;#
 13&nbsp;# A slightly different version of this script appeared in
 14&nbsp;#+ Ed Schaefer's July, 2002 "Shell Corner" column
 15&nbsp;#+ in "Unix Review" on-line,
 16&nbsp;#+ http://www.unixreview.com/documents/uni1026336632258/
 17&nbsp;# =======================================================
 18&nbsp;
 19&nbsp;
 20&nbsp;ARGCOUNT=1                     # Need name as argument.
 21&nbsp;E_WRONGARGS=70
 22&nbsp;
 23&nbsp;if [ $# -ne "$ARGCOUNT" ]
 24&nbsp;then
 25&nbsp;  echo "Usage: `basename $0` name"
 26&nbsp;  exit $E_WRONGARGS
 27&nbsp;fi  
 28&nbsp;
 29&nbsp;
 30&nbsp;assign_value ()                #  Assigns numerical value
 31&nbsp;{                              #+ to letters of name.
 32&nbsp;
 33&nbsp;  val1=bfpv                    # 'b,f,p,v' = 1
 34&nbsp;  val2=cgjkqsxz                # 'c,g,j,k,q,s,x,z' = 2
 35&nbsp;  val3=dt                      #  etc.
 36&nbsp;  val4=l
 37&nbsp;  val5=mn
 38&nbsp;  val6=r
 39&nbsp;
 40&nbsp;# Exceptionally clever use of 'tr' follows.
 41&nbsp;# Try to figure out what is going on here.
 42&nbsp;
 43&nbsp;value=$( echo "$1" \
 44&nbsp;| tr -d wh \
 45&nbsp;| tr $val1 1 | tr $val2 2 | tr $val3 3 \
 46&nbsp;| tr $val4 4 | tr $val5 5 | tr $val6 6 \
 47&nbsp;| tr -s 123456 \
 48&nbsp;| tr -d aeiouy )
 49&nbsp;
 50&nbsp;# Assign letter values.
 51&nbsp;# Remove duplicate numbers, except when separated by vowels.
 52&nbsp;# Ignore vowels, except as separators, so delete them last.
 53&nbsp;# Ignore 'w' and 'h', even as separators, so delete them first.
 54&nbsp;#
 55&nbsp;# The above command substitution lays more pipe than a plumber &#60;g&#62;.
 56&nbsp;
 57&nbsp;}  
 58&nbsp;
 59&nbsp;
 60&nbsp;input_name="$1"
 61&nbsp;echo
 62&nbsp;echo "Name = $input_name"
 63&nbsp;
 64&nbsp;
 65&nbsp;# Change all characters of name input to lowercase.
 66&nbsp;# ------------------------------------------------
 67&nbsp;name=$( echo $input_name | tr A-Z a-z )
 68&nbsp;# ------------------------------------------------
 69&nbsp;# Just in case argument to script is mixed case.
 70&nbsp;
 71&nbsp;
 72&nbsp;# Prefix of soundex code: first letter of name.
 73&nbsp;# --------------------------------------------
 74&nbsp;
 75&nbsp;
 76&nbsp;char_pos=0                     # Initialize character position. 
 77&nbsp;prefix0=${name:$char_pos:1}
 78&nbsp;prefix=`echo $prefix0 | tr a-z A-Z`
 79&nbsp;                               # Uppercase 1st letter of soundex.
 80&nbsp;
 81&nbsp;let "char_pos += 1"            # Bump character position to 2nd letter of name.
 82&nbsp;name1=${name:$char_pos}
 83&nbsp;
 84&nbsp;
 85&nbsp;# ++++++++++++++++++++++++++ Exception Patch +++++++++++++++++++++++++++++++++
 86&nbsp;#  Now, we run both the input name and the name shifted one char to the right
 87&nbsp;#+ through the value-assigning function.
 88&nbsp;#  If we get the same value out, that means that the first two characters
 89&nbsp;#+ of the name have the same value assigned, and that one should cancel.
 90&nbsp;#  However, we also need to test whether the first letter of the name
 91&nbsp;#+ is a vowel or 'w' or 'h', because otherwise this would bollix things up.
 92&nbsp;
 93&nbsp;char1=`echo $prefix | tr A-Z a-z`    # First letter of name, lowercased.
 94&nbsp;
 95&nbsp;assign_value $name
 96&nbsp;s1=$value
 97&nbsp;assign_value $name1
 98&nbsp;s2=$value
 99&nbsp;assign_value $char1
100&nbsp;s3=$value
101&nbsp;s3=9$s3                              #  If first letter of name is a vowel
102&nbsp;                                     #+ or 'w' or 'h',
103&nbsp;                                     #+ then its "value" will be null (unset).
104&nbsp;				     #+ Therefore, set it to 9, an otherwise
105&nbsp;				     #+ unused value, which can be tested for.
106&nbsp;
107&nbsp;
108&nbsp;if [[ "$s1" -ne "$s2" || "$s3" -eq 9 ]]
109&nbsp;then
110&nbsp;  suffix=$s2
111&nbsp;else  
112&nbsp;  suffix=${s2:$char_pos}
113&nbsp;fi  
114&nbsp;# ++++++++++++++++++++++ end Exception Patch +++++++++++++++++++++++++++++++++
115&nbsp;
116&nbsp;
117&nbsp;padding=000                    # Use at most 3 zeroes to pad.
118&nbsp;
119&nbsp;
120&nbsp;soun=$prefix$suffix$padding    # Pad with zeroes.
121&nbsp;
122&nbsp;MAXLEN=4                       # Truncate to maximum of 4 chars.
123&nbsp;soundex=${soun:0:$MAXLEN}
124&nbsp;
125&nbsp;echo "Soundex = $soundex"
126&nbsp;
127&nbsp;echo
128&nbsp;
129&nbsp;#  The soundex code is a method of indexing and classifying names
130&nbsp;#+ by grouping together the ones that sound alike.
131&nbsp;#  The soundex code for a given name is the first letter of the name,
132&nbsp;#+ followed by a calculated three-number code.
133&nbsp;#  Similar sounding names should have almost the same soundex codes.
134&nbsp;
135&nbsp;#   Examples:
136&nbsp;#   Smith and Smythe both have a "S-530" soundex.
137&nbsp;#   Harrison = H-625
138&nbsp;#   Hargison = H-622
139&nbsp;#   Harriman = H-655
140&nbsp;
141&nbsp;#  This works out fairly well in practice, but there are numerous anomalies.
142&nbsp;#
143&nbsp;#
144&nbsp;#  The U.S. Census and certain other governmental agencies use soundex,
145&nbsp;#  as do genealogical researchers.
146&nbsp;#
147&nbsp;#  For more information,
148&nbsp;#+ see the "National Archives and Records Administration home page",
149&nbsp;#+ http://www.nara.gov/genealogy/soundex/soundex.html
150&nbsp;
151&nbsp;
152&nbsp;
153&nbsp;# Exercise:
154&nbsp;# --------
155&nbsp;# Simplify the "Exception Patch" section of this script.
156&nbsp;
157&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="LIFESLOW"
></A
><P
><B
>例子 A-10. <SPAN
CLASS="QUOTE"
>"Game of Life"</SPAN
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# life.sh: "Life in the Slow Lane"
  3&nbsp;# Version 2: Patched by Daniel Albers
  4&nbsp;#+           to allow non-square grids as input.
  5&nbsp;
  6&nbsp;# ##################################################################### #
  7&nbsp;# This is the Bash script version of John Conway's "Game of Life".      #
  8&nbsp;# "Life" is a simple implementation of cellular automata.               #
  9&nbsp;# --------------------------------------------------------------------- #
 10&nbsp;# On a rectangular grid, let each "cell" be either "living" or "dead".  #
 11&nbsp;# Designate a living cell with a dot, and a dead one with a blank space.#
 12&nbsp;#  Begin with an arbitrarily drawn dot-and-blank grid,                  #
 13&nbsp;#+ and let this be the starting generation, "generation 0".             #
 14&nbsp;# Determine each successive generation by the following rules:          #
 15&nbsp;# 1) Each cell has 8 neighbors, the adjoining cells                     #
 16&nbsp;#+   left, right, top, bottom, and the 4 diagonals.                     #
 17&nbsp;#                       123                                             #
 18&nbsp;#                       4*5                                             #
 19&nbsp;#                       678                                             #
 20&nbsp;#                                                                       #
 21&nbsp;# 2) A living cell with either 2 or 3 living neighbors remains alive.   #
 22&nbsp;# 3) A dead cell with 3 living neighbors becomes alive (a "birth").     #
 23&nbsp;SURVIVE=2                                                               #
 24&nbsp;BIRTH=3                                                                 #
 25&nbsp;# 4) All other cases result in a dead cell for the next generation.     #
 26&nbsp;# ##################################################################### #
 27&nbsp;
 28&nbsp;
 29&nbsp;startfile=gen0   # Read the starting generation from the file "gen0".
 30&nbsp;                 # Default, if no other file specified when invoking script.
 31&nbsp;                 #
 32&nbsp;if [ -n "$1" ]   # Specify another "generation 0" file.
 33&nbsp;then
 34&nbsp;    startfile="$1"
 35&nbsp;fi  
 36&nbsp;
 37&nbsp;############################################
 38&nbsp;#  Abort script if "startfile" not specified
 39&nbsp;#+ AND
 40&nbsp;#+ "gen0" not present.
 41&nbsp;
 42&nbsp;E_NOSTARTFILE=68
 43&nbsp;
 44&nbsp;if [ ! -e "$startfile" ]
 45&nbsp;then
 46&nbsp;  echo "Startfile \""$startfile"\" missing!"
 47&nbsp;  exit $E_NOSTARTFILE
 48&nbsp;fi
 49&nbsp;############################################
 50&nbsp;
 51&nbsp;
 52&nbsp;ALIVE1=.
 53&nbsp;DEAD1=_
 54&nbsp;                 # Represent living and "dead" cells in the start-up file.
 55&nbsp;
 56&nbsp;#  ---------------------------------------------------------- #
 57&nbsp;#  This script uses a 10 x 10 grid (may be increased,
 58&nbsp;#+ but a large grid will will cause very slow execution).
 59&nbsp;ROWS=10
 60&nbsp;COLS=10
 61&nbsp;#  Change above two variables to match grid size, if necessary.
 62&nbsp;#  ---------------------------------------------------------- #
 63&nbsp;
 64&nbsp;GENERATIONS=10          #  How many generations to cycle through.
 65&nbsp;                        #  Adjust this upwards,
 66&nbsp;                        #+ if you have time on your hands.
 67&nbsp;
 68&nbsp;NONE_ALIVE=80           #  Exit status on premature bailout,
 69&nbsp;                        #+ if no cells left alive.
 70&nbsp;TRUE=0
 71&nbsp;FALSE=1
 72&nbsp;ALIVE=0
 73&nbsp;DEAD=1
 74&nbsp;
 75&nbsp;avar=                   # Global; holds current generation.
 76&nbsp;generation=0            # Initialize generation count.
 77&nbsp;
 78&nbsp;# =================================================================
 79&nbsp;
 80&nbsp;
 81&nbsp;let "cells = $ROWS * $COLS"
 82&nbsp;                        # How many cells.
 83&nbsp;
 84&nbsp;declare -a initial      # Arrays containing "cells".
 85&nbsp;declare -a current
 86&nbsp;
 87&nbsp;display ()
 88&nbsp;{
 89&nbsp;
 90&nbsp;alive=0                 # How many cells "alive" at any given time.
 91&nbsp;                        # Initially zero.
 92&nbsp;
 93&nbsp;declare -a arr
 94&nbsp;arr=( `echo "$1"` )     # Convert passed arg to array.
 95&nbsp;
 96&nbsp;element_count=${#arr[*]}
 97&nbsp;
 98&nbsp;local i
 99&nbsp;local rowcheck
100&nbsp;
101&nbsp;for ((i=0; i&#60;$element_count; i++))
102&nbsp;do
103&nbsp;
104&nbsp;  # Insert newline at end of each row.
105&nbsp;  let "rowcheck = $i % COLS"
106&nbsp;  if [ "$rowcheck" -eq 0 ]
107&nbsp;  then
108&nbsp;    echo                # Newline.
109&nbsp;    echo -n "      "    # Indent.
110&nbsp;  fi  
111&nbsp;
112&nbsp;  cell=${arr[i]}
113&nbsp;
114&nbsp;  if [ "$cell" = . ]
115&nbsp;  then
116&nbsp;    let "alive += 1"
117&nbsp;  fi  
118&nbsp;
119&nbsp;  echo -n "$cell" | sed -e 's/_/ /g'
120&nbsp;  # Print out array and change underscores to spaces.
121&nbsp;done  
122&nbsp;
123&nbsp;return
124&nbsp;
125&nbsp;}
126&nbsp;
127&nbsp;IsValid ()                            # Test whether cell coordinate valid.
128&nbsp;{
129&nbsp;
130&nbsp;  if [ -z "$1"  -o -z "$2" ]          # Mandatory arguments missing?
131&nbsp;  then
132&nbsp;    return $FALSE
133&nbsp;  fi
134&nbsp;
135&nbsp;local row
136&nbsp;local lower_limit=0                   # Disallow negative coordinate.
137&nbsp;local upper_limit
138&nbsp;local left
139&nbsp;local right
140&nbsp;
141&nbsp;let "upper_limit = $ROWS * $COLS - 1" # Total number of cells.
142&nbsp;
143&nbsp;
144&nbsp;if [ "$1" -lt "$lower_limit" -o "$1" -gt "$upper_limit" ]
145&nbsp;then
146&nbsp;  return $FALSE                       # Out of array bounds.
147&nbsp;fi  
148&nbsp;
149&nbsp;row=$2
150&nbsp;let "left = $row * $COLS"             # Left limit.
151&nbsp;let "right = $left + $COLS - 1"       # Right limit.
152&nbsp;
153&nbsp;if [ "$1" -lt "$left" -o "$1" -gt "$right" ]
154&nbsp;then
155&nbsp;  return $FALSE                       # Beyond row boundary.
156&nbsp;fi  
157&nbsp;
158&nbsp;return $TRUE                          # Valid coordinate.
159&nbsp;
160&nbsp;}  
161&nbsp;
162&nbsp;
163&nbsp;IsAlive ()              # Test whether cell is alive.
164&nbsp;                        # Takes array, cell number, state of cell as arguments.
165&nbsp;{
166&nbsp;  GetCount "$1" $2      # Get alive cell count in neighborhood.
167&nbsp;  local nhbd=$?
168&nbsp;
169&nbsp;
170&nbsp;  if [ "$nhbd" -eq "$BIRTH" ]  # Alive in any case.
171&nbsp;  then
172&nbsp;    return $ALIVE
173&nbsp;  fi
174&nbsp;
175&nbsp;  if [ "$3" = "." -a "$nhbd" -eq "$SURVIVE" ]
176&nbsp;  then                  # Alive only if previously alive.
177&nbsp;    return $ALIVE
178&nbsp;  fi  
179&nbsp;
180&nbsp;  return $DEAD          # Default.
181&nbsp;
182&nbsp;}  
183&nbsp;
184&nbsp;
185&nbsp;GetCount ()             # Count live cells in passed cell's neighborhood.
186&nbsp;                        # Two arguments needed:
187&nbsp;			# $1) variable holding array
188&nbsp;			# $2) cell number
189&nbsp;{
190&nbsp;  local cell_number=$2
191&nbsp;  local array
192&nbsp;  local top
193&nbsp;  local center
194&nbsp;  local bottom
195&nbsp;  local r
196&nbsp;  local row
197&nbsp;  local i
198&nbsp;  local t_top
199&nbsp;  local t_cen
200&nbsp;  local t_bot
201&nbsp;  local count=0
202&nbsp;  local ROW_NHBD=3
203&nbsp;
204&nbsp;  array=( `echo "$1"` )
205&nbsp;
206&nbsp;  let "top = $cell_number - $COLS - 1"    # Set up cell neighborhood.
207&nbsp;  let "center = $cell_number - 1"
208&nbsp;  let "bottom = $cell_number + $COLS - 1"
209&nbsp;  let "r = $cell_number / $COLS"
210&nbsp;
211&nbsp;  for ((i=0; i&#60;$ROW_NHBD; i++))           # Traverse from left to right. 
212&nbsp;  do
213&nbsp;    let "t_top = $top + $i"
214&nbsp;    let "t_cen = $center + $i"
215&nbsp;    let "t_bot = $bottom + $i"
216&nbsp;
217&nbsp;
218&nbsp;    let "row = $r"                        # Count center row of neighborhood.
219&nbsp;    IsValid $t_cen $row                   # Valid cell position?
220&nbsp;    if [ $? -eq "$TRUE" ]
221&nbsp;    then
222&nbsp;      if [ ${array[$t_cen]} = "$ALIVE1" ] # Is it alive?
223&nbsp;      then                                # Yes?
224&nbsp;        let "count += 1"                  # Increment count.
225&nbsp;      fi	
226&nbsp;    fi  
227&nbsp;
228&nbsp;    let "row = $r - 1"                    # Count top row.          
229&nbsp;    IsValid $t_top $row
230&nbsp;    if [ $? -eq "$TRUE" ]
231&nbsp;    then
232&nbsp;      if [ ${array[$t_top]} = "$ALIVE1" ] 
233&nbsp;      then
234&nbsp;        let "count += 1"
235&nbsp;      fi	
236&nbsp;    fi  
237&nbsp;
238&nbsp;    let "row = $r + 1"                    # Count bottom row.
239&nbsp;    IsValid $t_bot $row
240&nbsp;    if [ $? -eq "$TRUE" ]
241&nbsp;    then
242&nbsp;      if [ ${array[$t_bot]} = "$ALIVE1" ] 
243&nbsp;      then
244&nbsp;        let "count += 1"
245&nbsp;      fi	
246&nbsp;    fi  
247&nbsp;
248&nbsp;  done  
249&nbsp;
250&nbsp;
251&nbsp;  if [ ${array[$cell_number]} = "$ALIVE1" ]
252&nbsp;  then
253&nbsp;    let "count -= 1"        #  Make sure value of tested cell itself
254&nbsp;  fi                        #+ is not counted.
255&nbsp;
256&nbsp;
257&nbsp;  return $count
258&nbsp;  
259&nbsp;}
260&nbsp;
261&nbsp;next_gen ()               # Update generation array.
262&nbsp;{
263&nbsp;
264&nbsp;local array
265&nbsp;local i=0
266&nbsp;
267&nbsp;array=( `echo "$1"` )     # Convert passed arg to array.
268&nbsp;
269&nbsp;while [ "$i" -lt "$cells" ]
270&nbsp;do
271&nbsp;  IsAlive "$1" $i ${array[$i]}   # Is cell alive?
272&nbsp;  if [ $? -eq "$ALIVE" ]
273&nbsp;  then                           #  If alive, then
274&nbsp;    array[$i]=.                  #+ represent the cell as a period.
275&nbsp;  else  
276&nbsp;    array[$i]="_"                #  Otherwise underscore
277&nbsp;   fi                            #+ (which will later be converted to space).  
278&nbsp;  let "i += 1" 
279&nbsp;done   
280&nbsp;
281&nbsp;
282&nbsp;# let "generation += 1"   # Increment generation count.
283&nbsp;# Why was the above line commented out?
284&nbsp;
285&nbsp;
286&nbsp;# Set variable to pass as parameter to "display" function.
287&nbsp;avar=`echo ${array[@]}`   # Convert array back to string variable.
288&nbsp;display "$avar"           # Display it.
289&nbsp;echo; echo
290&nbsp;echo "Generation $generation  -  $alive alive"
291&nbsp;
292&nbsp;if [ "$alive" -eq 0 ]
293&nbsp;then
294&nbsp;  echo
295&nbsp;  echo "Premature exit: no more cells alive!"
296&nbsp;  exit $NONE_ALIVE        #  No point in continuing
297&nbsp;fi                        #+ if no live cells.
298&nbsp;
299&nbsp;}
300&nbsp;
301&nbsp;
302&nbsp;# =========================================================
303&nbsp;
304&nbsp;# main ()
305&nbsp;
306&nbsp;# Load initial array with contents of startup file.
307&nbsp;initial=( `cat "$startfile" | sed -e '/#/d' | tr -d '\n' |\
308&nbsp;sed -e 's/\./\. /g' -e 's/_/_ /g'` )
309&nbsp;# Delete lines containing '#' comment character.
310&nbsp;# Remove linefeeds and insert space between elements.
311&nbsp;
312&nbsp;clear          # Clear screen.
313&nbsp;
314&nbsp;echo #         Title
315&nbsp;echo "======================="
316&nbsp;echo "    $GENERATIONS generations"
317&nbsp;echo "           of"
318&nbsp;echo "\"Life in the Slow Lane\""
319&nbsp;echo "======================="
320&nbsp;
321&nbsp;
322&nbsp;# -------- Display first generation. --------
323&nbsp;Gen0=`echo ${initial[@]}`
324&nbsp;display "$Gen0"           # Display only.
325&nbsp;echo; echo
326&nbsp;echo "Generation $generation  -  $alive alive"
327&nbsp;# -------------------------------------------
328&nbsp;
329&nbsp;
330&nbsp;let "generation += 1"     # Increment generation count.
331&nbsp;echo
332&nbsp;
333&nbsp;# ------- Display second generation. -------
334&nbsp;Cur=`echo ${initial[@]}`
335&nbsp;next_gen "$Cur"          # Update &#38; display.
336&nbsp;# ------------------------------------------
337&nbsp;
338&nbsp;let "generation += 1"     # Increment generation count.
339&nbsp;
340&nbsp;# ------ Main loop for displaying subsequent generations ------
341&nbsp;while [ "$generation" -le "$GENERATIONS" ]
342&nbsp;do
343&nbsp;  Cur="$avar"
344&nbsp;  next_gen "$Cur"
345&nbsp;  let "generation += 1"
346&nbsp;done
347&nbsp;# ==============================================================
348&nbsp;
349&nbsp;echo
350&nbsp;
351&nbsp;exit 0   # END
352&nbsp;
353&nbsp;
354&nbsp;
355&nbsp;# The grid in this script has a "boundary problem."
356&nbsp;# The the top, bottom, and sides border on a void of dead cells.
357&nbsp;# Exercise: Change the script to have the grid wrap around,
358&nbsp;# +         so that the left and right sides will "touch,"      
359&nbsp;# +         as will the top and bottom.
360&nbsp;#
361&nbsp;# Exercise: Create a new "gen0" file to seed this script.
362&nbsp;#           Use a 12 x 16 grid, instead of the original 10 x 10 one.
363&nbsp;#           Make the necessary changes to the script,
364&nbsp;#+          so it will run with the altered file.
365&nbsp;#
366&nbsp;# Exercise: Modify this script so that it can determine the grid size
367&nbsp;#+          from the "gen0" file, and set any variables necessary
368&nbsp;#+          for the script to run.
369&nbsp;#           This would make unnecessary any changes to variables
370&nbsp;#+          in the script for an altered grid size.</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="GEN0DATA"
></A
><P
><B
>例子 A-11. <SPAN
CLASS="QUOTE"
>"Game of Life"</SPAN
>的数据文件</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;# This is an example "generation 0" start-up file for "life.sh".
  2&nbsp;# --------------------------------------------------------------
  3&nbsp;#  The "gen0" file is a 10 x 10 grid using a period (.) for live cells,
  4&nbsp;#+ and an underscore (_) for dead ones. We cannot simply use spaces
  5&nbsp;#+ for dead cells in this file because of a peculiarity in Bash arrays.
  6&nbsp;#  [Exercise for the reader: explain this.]
  7&nbsp;#
  8&nbsp;# Lines beginning with a '#' are comments, and the script ignores them.
  9&nbsp;__.__..___
 10&nbsp;___._.____
 11&nbsp;____.___..
 12&nbsp;_._______.
 13&nbsp;____._____
 14&nbsp;..__...___
 15&nbsp;____._____
 16&nbsp;___...____
 17&nbsp;__.._..___
 18&nbsp;_..___..__</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>+++</P
><P
>下面的两个脚本是由多伦多大学的Mark Moraes编写的. 
    请参考附件文件<SPAN
CLASS="QUOTE"
>"Moraes-COPYRIGHT"</SPAN
>, 
    详细的指明了授权与约定. </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="BEHEAD"
></A
><P
><B
>例子 A-12. <B
CLASS="COMMAND"
>behead</B
>: 去掉信件与新消息的头</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#! /bin/sh
  2&nbsp;# Strips off the header from a mail/News message i.e. till the first
  3&nbsp;# empty line
  4&nbsp;# Mark Moraes, University of Toronto
  5&nbsp;
  6&nbsp;# ==&#62; These comments added by author of this document.
  7&nbsp;
  8&nbsp;if [ $# -eq 0 ]; then
  9&nbsp;# ==&#62; If no command line args present, then works on file redirected to stdin.
 10&nbsp;	sed -e '1,/^$/d' -e '/^[ 	]*$/d'
 11&nbsp;	# --&#62; Delete empty lines and all lines until 
 12&nbsp;	# --&#62; first one beginning with white space.
 13&nbsp;else
 14&nbsp;# ==&#62; If command line args present, then work on files named.
 15&nbsp;	for i do
 16&nbsp;		sed -e '1,/^$/d' -e '/^[ 	]*$/d' $i
 17&nbsp;		# --&#62; Ditto, as above.
 18&nbsp;	done
 19&nbsp;fi
 20&nbsp;
 21&nbsp;# ==&#62; Exercise: Add error checking and other options.
 22&nbsp;# ==&#62;
 23&nbsp;# ==&#62; Note that the small sed script repeats, except for the arg passed.
 24&nbsp;# ==&#62; Does it make sense to embed it in a function? Why or why not?</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="FTPGET"
></A
><P
><B
>例子 A-13. <B
CLASS="COMMAND"
>ftpget</B
>: 通过ftp下载文件</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#! /bin/sh 
  2&nbsp;# $Id: ftpget,v 1.2 91/05/07 21:15:43 moraes Exp $ 
  3&nbsp;# Script to perform batch anonymous ftp. Essentially converts a list of
  4&nbsp;# of command line arguments into input to ftp.
  5&nbsp;# ==&#62; This script is nothing but a shell wrapper around "ftp" . . .
  6&nbsp;# Simple, and quick - written as a companion to ftplist 
  7&nbsp;# -h specifies the remote host (default prep.ai.mit.edu) 
  8&nbsp;# -d specifies the remote directory to cd to - you can provide a sequence 
  9&nbsp;# of -d options - they will be cd'ed to in turn. If the paths are relative, 
 10&nbsp;# make sure you get the sequence right. Be careful with relative paths - 
 11&nbsp;# there are far too many symlinks nowadays.  
 12&nbsp;# (default is the ftp login directory)
 13&nbsp;# -v turns on the verbose option of ftp, and shows all responses from the 
 14&nbsp;# ftp server.  
 15&nbsp;# -f remotefile[:localfile] gets the remote file into localfile 
 16&nbsp;# -m pattern does an mget with the specified pattern. Remember to quote 
 17&nbsp;# shell characters.  
 18&nbsp;# -c does a local cd to the specified directory
 19&nbsp;# For example, 
 20&nbsp;# 	ftpget -h expo.lcs.mit.edu -d contrib -f xplaces.shar:xplaces.sh \
 21&nbsp;#		-d ../pub/R3/fixes -c ~/fixes -m 'fix*' 
 22&nbsp;# will get xplaces.shar from ~ftp/contrib on expo.lcs.mit.edu, and put it in
 23&nbsp;# xplaces.sh in the current working directory, and get all fixes from
 24&nbsp;# ~ftp/pub/R3/fixes and put them in the ~/fixes directory. 
 25&nbsp;# Obviously, the sequence of the options is important, since the equivalent
 26&nbsp;# commands are executed by ftp in corresponding order
 27&nbsp;#
 28&nbsp;# Mark Moraes &#60;moraes@csri.toronto.edu&#62;, Feb 1, 1989 
 29&nbsp;#
 30&nbsp;
 31&nbsp;
 32&nbsp;# ==&#62; These comments added by author of this document.
 33&nbsp;
 34&nbsp;# PATH=/local/bin:/usr/ucb:/usr/bin:/bin
 35&nbsp;# export PATH
 36&nbsp;# ==&#62; Above 2 lines from original script probably superfluous.
 37&nbsp;
 38&nbsp;E_BADARGS=65
 39&nbsp;
 40&nbsp;TMPFILE=/tmp/ftp.$$
 41&nbsp;# ==&#62; Creates temp file, using process id of script ($$)
 42&nbsp;# ==&#62; to construct filename.
 43&nbsp;
 44&nbsp;SITE=`domainname`.toronto.edu
 45&nbsp;# ==&#62; 'domainname' similar to 'hostname'
 46&nbsp;# ==&#62; May rewrite this to parameterize this for general use.
 47&nbsp;
 48&nbsp;usage="Usage: $0 [-h remotehost] [-d remotedirectory]... [-f remfile:localfile]... \
 49&nbsp;		[-c localdirectory] [-m filepattern] [-v]"
 50&nbsp;ftpflags="-i -n"
 51&nbsp;verbflag=
 52&nbsp;set -f 		# So we can use globbing in -m
 53&nbsp;set x `getopt vh:d:c:m:f: $*`
 54&nbsp;if [ $? != 0 ]; then
 55&nbsp;	echo $usage
 56&nbsp;	exit $E_BADARGS
 57&nbsp;fi
 58&nbsp;shift
 59&nbsp;trap 'rm -f ${TMPFILE} ; exit' 0 1 2 3 15
 60&nbsp;# ==&#62; Delete tempfile in case of abnormal exit from script.
 61&nbsp;echo "user anonymous ${USER-gnu}@${SITE} &#62; ${TMPFILE}"
 62&nbsp;# ==&#62; Added quotes (recommended in complex echoes).
 63&nbsp;echo binary &#62;&#62; ${TMPFILE}
 64&nbsp;for i in $*   # ==&#62; Parse command line args.
 65&nbsp;do
 66&nbsp;	case $i in
 67&nbsp;	-v) verbflag=-v; echo hash &#62;&#62; ${TMPFILE}; shift;;
 68&nbsp;	-h) remhost=$2; shift 2;;
 69&nbsp;	-d) echo cd $2 &#62;&#62; ${TMPFILE}; 
 70&nbsp;	    if [ x${verbflag} != x ]; then
 71&nbsp;	        echo pwd &#62;&#62; ${TMPFILE};
 72&nbsp;	    fi;
 73&nbsp;	    shift 2;;
 74&nbsp;	-c) echo lcd $2 &#62;&#62; ${TMPFILE}; shift 2;;
 75&nbsp;	-m) echo mget "$2" &#62;&#62; ${TMPFILE}; shift 2;;
 76&nbsp;	-f) f1=`expr "$2" : "\([^:]*\).*"`; f2=`expr "$2" : "[^:]*:\(.*\)"`;
 77&nbsp;	    echo get ${f1} ${f2} &#62;&#62; ${TMPFILE}; shift 2;;
 78&nbsp;	--) shift; break;;
 79&nbsp;	esac
 80&nbsp;        # ==&#62; 'lcd' and 'mget' are ftp commands. See "man ftp" . . .
 81&nbsp;done
 82&nbsp;if [ $# -ne 0 ]; then
 83&nbsp;	echo $usage
 84&nbsp;	exit $E_BADARGS
 85&nbsp;        # ==&#62; Changed from "exit 2" to conform with style standard.
 86&nbsp;fi
 87&nbsp;if [ x${verbflag} != x ]; then
 88&nbsp;	ftpflags="${ftpflags} -v"
 89&nbsp;fi
 90&nbsp;if [ x${remhost} = x ]; then
 91&nbsp;	remhost=prep.ai.mit.edu
 92&nbsp;	# ==&#62; Change to match appropriate ftp site.
 93&nbsp;fi
 94&nbsp;echo quit &#62;&#62; ${TMPFILE}
 95&nbsp;# ==&#62; All commands saved in tempfile.
 96&nbsp;
 97&nbsp;ftp ${ftpflags} ${remhost} &#60; ${TMPFILE}
 98&nbsp;# ==&#62; Now, tempfile batch processed by ftp.
 99&nbsp;
100&nbsp;rm -f ${TMPFILE}
101&nbsp;# ==&#62; Finally, tempfile deleted (you may wish to copy it to a logfile).
102&nbsp;
103&nbsp;
104&nbsp;# ==&#62; Exercises:
105&nbsp;# ==&#62; ---------
106&nbsp;# ==&#62; 1) Add error checking.
107&nbsp;# ==&#62; 2) Add bells &#38; whistles.</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>+</P
><P
>Antek Sawicki捐献了下面的脚本, 这个脚本非常聪明的使用了参数替换操作符, 
		我们在<A
HREF="parameter-substitution.html"
>Section 9.3</A
>中讨论了参数替换操作符. </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="PW"
></A
><P
><B
>例子 A-14. <B
CLASS="COMMAND"
>password</B
>: 产生随机的8个字符的密码</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# May need to be invoked with  #!/bin/bash2  on older machines.
  3&nbsp;#
  4&nbsp;# Random password generator for Bash 2.x by Antek Sawicki &#60;tenox@tenox.tc&#62;,
  5&nbsp;# who generously gave permission to the document author to use it here.
  6&nbsp;#
  7&nbsp;# ==&#62; Comments added by document author ==&#62;
  8&nbsp;
  9&nbsp;
 10&nbsp;MATRIX="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
 11&nbsp;# ==&#62; Password will consist of alphanumeric characters.
 12&nbsp;LENGTH="8"
 13&nbsp;# ==&#62; May change 'LENGTH' for longer password.
 14&nbsp;
 15&nbsp;
 16&nbsp;while [ "${n:=1}" -le "$LENGTH" ]
 17&nbsp;# ==&#62; Recall that := is "default substitution" operator.
 18&nbsp;# ==&#62; So, if 'n' has not been initialized, set it to 1.
 19&nbsp;do
 20&nbsp;	PASS="$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}"
 21&nbsp;	# ==&#62; Very clever, but tricky.
 22&nbsp;
 23&nbsp;	# ==&#62; Starting from the innermost nesting...
 24&nbsp;	# ==&#62; ${#MATRIX} returns length of array MATRIX.
 25&nbsp;
 26&nbsp;	# ==&#62; $RANDOM%${#MATRIX} returns random number between 1
 27&nbsp;	# ==&#62; and [length of MATRIX] - 1.
 28&nbsp;
 29&nbsp;	# ==&#62; ${MATRIX:$(($RANDOM%${#MATRIX})):1}
 30&nbsp;	# ==&#62; returns expansion of MATRIX at random position, by length 1. 
 31&nbsp;	# ==&#62; See {var:pos:len} parameter substitution in Chapter 9.
 32&nbsp;	# ==&#62; and the associated examples.
 33&nbsp;
 34&nbsp;	# ==&#62; PASS=... simply pastes this result onto previous PASS (concatenation).
 35&nbsp;
 36&nbsp;	# ==&#62; To visualize this more clearly, uncomment the following line
 37&nbsp;	#                 echo "$PASS"
 38&nbsp;	# ==&#62; to see PASS being built up,
 39&nbsp;	# ==&#62; one character at a time, each iteration of the loop.
 40&nbsp;
 41&nbsp;	let n+=1
 42&nbsp;	# ==&#62; Increment 'n' for next pass.
 43&nbsp;done
 44&nbsp;
 45&nbsp;echo "$PASS"      # ==&#62; Or, redirect to a file, as desired.
 46&nbsp;
 47&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>+</P
><P
><A
NAME="ZFIFO"
></A
>James R. Van Zandt捐献了这个脚本, 
      使用命名管道, 用他的话来说, <SPAN
CLASS="QUOTE"
>"引用与转义的真正练习"</SPAN
>. </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="FIFO"
></A
><P
><B
>例子 A-15. <B
CLASS="COMMAND"
>fifo</B
>: 使用命名管道来做每日的备份</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# ==&#62; Script by James R. Van Zandt, and used here with his permission.
  3&nbsp;
  4&nbsp;# ==&#62; Comments added by author of this document.
  5&nbsp;
  6&nbsp;  
  7&nbsp;  HERE=`uname -n`    # ==&#62; hostname
  8&nbsp;  THERE=bilbo
  9&nbsp;  echo "starting remote backup to $THERE at `date +%r`"
 10&nbsp;  # ==&#62; `date +%r` returns time in 12-hour format, i.e. "08:08:34 PM".
 11&nbsp;  
 12&nbsp;  # make sure /pipe really is a pipe and not a plain file
 13&nbsp;  rm -rf /pipe
 14&nbsp;  mkfifo /pipe       # ==&#62; Create a "named pipe", named "/pipe".
 15&nbsp;  
 16&nbsp;  # ==&#62; 'su xyz' runs commands as user "xyz".
 17&nbsp;  # ==&#62; 'ssh' invokes secure shell (remote login client).
 18&nbsp;  su xyz -c "ssh $THERE \"cat &#62;/home/xyz/backup/${HERE}-daily.tar.gz\" &#60; /pipe"&#38;
 19&nbsp;  cd /
 20&nbsp;  tar -czf - bin boot dev etc home info lib man root sbin share usr var &#62;/pipe
 21&nbsp;  # ==&#62; Uses named pipe, /pipe, to communicate between processes:
 22&nbsp;  # ==&#62; 'tar/gzip' writes to /pipe and 'ssh' reads from /pipe.
 23&nbsp;
 24&nbsp;  # ==&#62; The end result is this backs up the main directories, from / on down.
 25&nbsp;
 26&nbsp;  # ==&#62;  What are the advantages of a "named pipe" in this situation,
 27&nbsp;  # ==&#62;+ as opposed to an "anonymous pipe", with |?
 28&nbsp;  # ==&#62;  Will an anonymous pipe even work here?
 29&nbsp;
 30&nbsp;
 31&nbsp;  exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>+</P
><P
>Stephane Chazelas捐献了这个脚本, 用来展示如何不使用数组来产生素数</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="PRIMES"
></A
><P
><B
>例子 A-16. 使用模操作符来产生素数</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# primes.sh: Generate prime numbers, without using arrays.
  3&nbsp;# Script contributed by Stephane Chazelas.
  4&nbsp;
  5&nbsp;#  This does *not* use the classic "Sieve of Eratosthenes" algorithm,
  6&nbsp;#+ but instead uses the more intuitive method of testing each candidate number
  7&nbsp;#+ for factors (divisors), using the "%" modulo operator.
  8&nbsp;
  9&nbsp;
 10&nbsp;LIMIT=1000                    # Primes 2 - 1000
 11&nbsp;
 12&nbsp;Primes()
 13&nbsp;{
 14&nbsp; (( n = $1 + 1 ))             # Bump to next integer.
 15&nbsp; shift                        # Next parameter in list.
 16&nbsp;#  echo "_n=$n i=$i_"
 17&nbsp; 
 18&nbsp; if (( n == LIMIT ))
 19&nbsp; then echo $*
 20&nbsp; return
 21&nbsp; fi
 22&nbsp;
 23&nbsp; for i; do                    # "i" gets set to "@", previous values of $n.
 24&nbsp;#   echo "-n=$n i=$i-"
 25&nbsp;   (( i * i &#62; n )) &#38;&#38; break   # Optimization.
 26&nbsp;   (( n % i )) &#38;&#38; continue    # Sift out non-primes using modulo operator.
 27&nbsp;   Primes $n $@               # Recursion inside loop.
 28&nbsp;   return
 29&nbsp;   done
 30&nbsp;
 31&nbsp;   Primes $n $@ $n            # Recursion outside loop.
 32&nbsp;                              # Successively accumulate positional parameters.
 33&nbsp;                              # "$@" is the accumulating list of primes.
 34&nbsp;}
 35&nbsp;
 36&nbsp;Primes 1
 37&nbsp;
 38&nbsp;exit 0
 39&nbsp;
 40&nbsp;#  Uncomment lines 16 and 24 to help figure out what is going on.
 41&nbsp;
 42&nbsp;#  Compare the speed of this algorithm for generating primes
 43&nbsp;#+ with the Sieve of Eratosthenes (ex68.sh).
 44&nbsp;
 45&nbsp;#  Exercise: Rewrite this script without recursion, for faster execution.</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>+</P
><P
>这是Jordi Sanfeliu的<EM
>tree</EM
>脚本的升级版, 由Rick Boivie编写. </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="TREE"
></A
><P
><B
>例子 A-17. <B
CLASS="COMMAND"
>tree</B
>: 显示目录树</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# tree.sh
  3&nbsp;
  4&nbsp;#  Written by Rick Boivie.
  5&nbsp;#  Used with permission.
  6&nbsp;#  This is a revised and simplified version of a script
  7&nbsp;#+ by Jordi Sanfeliu (and patched by Ian Kjos).
  8&nbsp;#  This script replaces the earlier version used in
  9&nbsp;#+ previous releases of the Advanced Bash Scripting Guide.
 10&nbsp;
 11&nbsp;# ==&#62; Comments added by the author of this document.
 12&nbsp;
 13&nbsp;
 14&nbsp;search () {
 15&nbsp;for dir in `echo *`
 16&nbsp;#  ==&#62; `echo *` lists all the files in current working directory,
 17&nbsp;#+ ==&#62; without line breaks.
 18&nbsp;#  ==&#62; Similar effect to for dir in *
 19&nbsp;#  ==&#62; but "dir in `echo *`" will not handle filenames with blanks.
 20&nbsp;do
 21&nbsp;  if [ -d "$dir" ] ; then # ==&#62; If it is a directory (-d)...
 22&nbsp;  zz=0                    # ==&#62; Temp variable, keeping track of directory level.
 23&nbsp;  while [ $zz != $1 ]     # Keep track of inner nested loop.
 24&nbsp;    do
 25&nbsp;      echo -n "| "        # ==&#62; Display vertical connector symbol,
 26&nbsp;                          # ==&#62; with 2 spaces &#38; no line feed in order to indent.
 27&nbsp;      zz=`expr $zz + 1`   # ==&#62; Increment zz.
 28&nbsp;    done
 29&nbsp;
 30&nbsp;    if [ -L "$dir" ] ; then # ==&#62; If directory is a symbolic link...
 31&nbsp;      echo "+---$dir" `ls -l $dir | sed 's/^.*'$dir' //'`
 32&nbsp;      # ==&#62; Display horiz. connector and list directory name, but...
 33&nbsp;      # ==&#62; delete date/time part of long listing.
 34&nbsp;    else
 35&nbsp;      echo "+---$dir"       # ==&#62; Display horizontal connector symbol...
 36&nbsp;      # ==&#62; and print directory name.
 37&nbsp;      numdirs=`expr $numdirs + 1` # ==&#62; Increment directory count.
 38&nbsp;      if cd "$dir" ; then         # ==&#62; If can move to subdirectory...
 39&nbsp;        search `expr $1 + 1`      # with recursion ;-)
 40&nbsp;        # ==&#62; Function calls itself.
 41&nbsp;        cd ..
 42&nbsp;      fi
 43&nbsp;    fi
 44&nbsp;  fi
 45&nbsp;done
 46&nbsp;}
 47&nbsp;
 48&nbsp;if [ $# != 0 ] ; then
 49&nbsp;  cd $1 # move to indicated directory.
 50&nbsp;  #else # stay in current directory
 51&nbsp;fi
 52&nbsp;
 53&nbsp;echo "Initial directory = `pwd`"
 54&nbsp;numdirs=0
 55&nbsp;
 56&nbsp;search 0
 57&nbsp;echo "Total directories = $numdirs"
 58&nbsp;
 59&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>经过Noah Friedman的授权, 他的<EM
>string
			function</EM
>脚本可以在本书中使用, 
		这个脚本本质上就是复制了一些C库的字符串操作函数. 
      </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="STRING"
></A
><P
><B
>例子 A-18. <B
CLASS="COMMAND"
>string functions</B
>: C风格的字符串函数</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;
  3&nbsp;# string.bash --- bash emulation of string(3) library routines
  4&nbsp;# Author: Noah Friedman &#60;friedman@prep.ai.mit.edu&#62;
  5&nbsp;# ==&#62;     Used with his kind permission in this document.
  6&nbsp;# Created: 1992-07-01
  7&nbsp;# Last modified: 1993-09-29
  8&nbsp;# Public domain
  9&nbsp;
 10&nbsp;# Conversion to bash v2 syntax done by Chet Ramey
 11&nbsp;
 12&nbsp;# Commentary:
 13&nbsp;# Code:
 14&nbsp;
 15&nbsp;#:docstring strcat:
 16&nbsp;# Usage: strcat s1 s2
 17&nbsp;#
 18&nbsp;# Strcat appends the value of variable s2 to variable s1. 
 19&nbsp;#
 20&nbsp;# Example:
 21&nbsp;#    a="foo"
 22&nbsp;#    b="bar"
 23&nbsp;#    strcat a b
 24&nbsp;#    echo $a
 25&nbsp;#    =&#62; foobar
 26&nbsp;#
 27&nbsp;#:end docstring:
 28&nbsp;
 29&nbsp;###;;;autoload   ==&#62; Autoloading of function commented out.
 30&nbsp;function strcat ()
 31&nbsp;{
 32&nbsp;    local s1_val s2_val
 33&nbsp;
 34&nbsp;    s1_val=${!1}                        # indirect variable expansion
 35&nbsp;    s2_val=${!2}
 36&nbsp;    eval "$1"=\'"${s1_val}${s2_val}"\'
 37&nbsp;    # ==&#62; eval $1='${s1_val}${s2_val}' avoids problems,
 38&nbsp;    # ==&#62; if one of the variables contains a single quote.
 39&nbsp;}
 40&nbsp;
 41&nbsp;#:docstring strncat:
 42&nbsp;# Usage: strncat s1 s2 $n
 43&nbsp;# 
 44&nbsp;# Line strcat, but strncat appends a maximum of n characters from the value
 45&nbsp;# of variable s2.  It copies fewer if the value of variabl s2 is shorter
 46&nbsp;# than n characters.  Echoes result on stdout.
 47&nbsp;#
 48&nbsp;# Example:
 49&nbsp;#    a=foo
 50&nbsp;#    b=barbaz
 51&nbsp;#    strncat a b 3
 52&nbsp;#    echo $a
 53&nbsp;#    =&#62; foobar
 54&nbsp;#
 55&nbsp;#:end docstring:
 56&nbsp;
 57&nbsp;###;;;autoload
 58&nbsp;function strncat ()
 59&nbsp;{
 60&nbsp;    local s1="$1"
 61&nbsp;    local s2="$2"
 62&nbsp;    local -i n="$3"
 63&nbsp;    local s1_val s2_val
 64&nbsp;
 65&nbsp;    s1_val=${!s1}                       # ==&#62; indirect variable expansion
 66&nbsp;    s2_val=${!s2}
 67&nbsp;
 68&nbsp;    if [ ${#s2_val} -gt ${n} ]; then
 69&nbsp;       s2_val=${s2_val:0:$n}            # ==&#62; substring extraction
 70&nbsp;    fi
 71&nbsp;
 72&nbsp;    eval "$s1"=\'"${s1_val}${s2_val}"\'
 73&nbsp;    # ==&#62; eval $1='${s1_val}${s2_val}' avoids problems,
 74&nbsp;    # ==&#62; if one of the variables contains a single quote.
 75&nbsp;}
 76&nbsp;
 77&nbsp;#:docstring strcmp:
 78&nbsp;# Usage: strcmp $s1 $s2
 79&nbsp;#
 80&nbsp;# Strcmp compares its arguments and returns an integer less than, equal to,
 81&nbsp;# or greater than zero, depending on whether string s1 is lexicographically
 82&nbsp;# less than, equal to, or greater than string s2.
 83&nbsp;#:end docstring:
 84&nbsp;
 85&nbsp;###;;;autoload
 86&nbsp;function strcmp ()
 87&nbsp;{
 88&nbsp;    [ "$1" = "$2" ] &#38;&#38; return 0
 89&nbsp;
 90&nbsp;    [ "${1}" '&#60;' "${2}" ] &#62; /dev/null &#38;&#38; return -1
 91&nbsp;
 92&nbsp;    return 1
 93&nbsp;}
 94&nbsp;
 95&nbsp;#:docstring strncmp:
 96&nbsp;# Usage: strncmp $s1 $s2 $n
 97&nbsp;# 
 98&nbsp;# Like strcmp, but makes the comparison by examining a maximum of n
 99&nbsp;# characters (n less than or equal to zero yields equality).
100&nbsp;#:end docstring:
101&nbsp;
102&nbsp;###;;;autoload
103&nbsp;function strncmp ()
104&nbsp;{
105&nbsp;    if [ -z "${3}" -o "${3}" -le "0" ]; then
106&nbsp;       return 0
107&nbsp;    fi
108&nbsp;   
109&nbsp;    if [ ${3} -ge ${#1} -a ${3} -ge ${#2} ]; then
110&nbsp;       strcmp "$1" "$2"
111&nbsp;       return $?
112&nbsp;    else
113&nbsp;       s1=${1:0:$3}
114&nbsp;       s2=${2:0:$3}
115&nbsp;       strcmp $s1 $s2
116&nbsp;       return $?
117&nbsp;    fi
118&nbsp;}
119&nbsp;
120&nbsp;#:docstring strlen:
121&nbsp;# Usage: strlen s
122&nbsp;#
123&nbsp;# Strlen returns the number of characters in string literal s.
124&nbsp;#:end docstring:
125&nbsp;
126&nbsp;###;;;autoload
127&nbsp;function strlen ()
128&nbsp;{
129&nbsp;    eval echo "\${#${1}}"
130&nbsp;    # ==&#62; Returns the length of the value of the variable
131&nbsp;    # ==&#62; whose name is passed as an argument.
132&nbsp;}
133&nbsp;
134&nbsp;#:docstring strspn:
135&nbsp;# Usage: strspn $s1 $s2
136&nbsp;# 
137&nbsp;# Strspn returns the length of the maximum initial segment of string s1,
138&nbsp;# which consists entirely of characters from string s2.
139&nbsp;#:end docstring:
140&nbsp;
141&nbsp;###;;;autoload
142&nbsp;function strspn ()
143&nbsp;{
144&nbsp;    # Unsetting IFS allows whitespace to be handled as normal chars. 
145&nbsp;    local IFS=
146&nbsp;    local result="${1%%[!${2}]*}"
147&nbsp; 
148&nbsp;    echo ${#result}
149&nbsp;}
150&nbsp;
151&nbsp;#:docstring strcspn:
152&nbsp;# Usage: strcspn $s1 $s2
153&nbsp;#
154&nbsp;# Strcspn returns the length of the maximum initial segment of string s1,
155&nbsp;# which consists entirely of characters not from string s2.
156&nbsp;#:end docstring:
157&nbsp;
158&nbsp;###;;;autoload
159&nbsp;function strcspn ()
160&nbsp;{
161&nbsp;    # Unsetting IFS allows whitspace to be handled as normal chars. 
162&nbsp;    local IFS=
163&nbsp;    local result="${1%%[${2}]*}"
164&nbsp; 
165&nbsp;    echo ${#result}
166&nbsp;}
167&nbsp;
168&nbsp;#:docstring strstr:
169&nbsp;# Usage: strstr s1 s2
170&nbsp;# 
171&nbsp;# Strstr echoes a substring starting at the first occurrence of string s2 in
172&nbsp;# string s1, or nothing if s2 does not occur in the string.  If s2 points to
173&nbsp;# a string of zero length, strstr echoes s1.
174&nbsp;#:end docstring:
175&nbsp;
176&nbsp;###;;;autoload
177&nbsp;function strstr ()
178&nbsp;{
179&nbsp;    # if s2 points to a string of zero length, strstr echoes s1
180&nbsp;    [ ${#2} -eq 0 ] &#38;&#38; { echo "$1" ; return 0; }
181&nbsp;
182&nbsp;    # strstr echoes nothing if s2 does not occur in s1
183&nbsp;    case "$1" in
184&nbsp;    *$2*) ;;
185&nbsp;    *) return 1;;
186&nbsp;    esac
187&nbsp;
188&nbsp;    # use the pattern matching code to strip off the match and everything
189&nbsp;    # following it
190&nbsp;    first=${1/$2*/}
191&nbsp;
192&nbsp;    # then strip off the first unmatched portion of the string
193&nbsp;    echo "${1##$first}"
194&nbsp;}
195&nbsp;
196&nbsp;#:docstring strtok:
197&nbsp;# Usage: strtok s1 s2
198&nbsp;#
199&nbsp;# Strtok considers the string s1 to consist of a sequence of zero or more
200&nbsp;# text tokens separated by spans of one or more characters from the
201&nbsp;# separator string s2.  The first call (with a non-empty string s1
202&nbsp;# specified) echoes a string consisting of the first token on stdout. The
203&nbsp;# function keeps track of its position in the string s1 between separate
204&nbsp;# calls, so that subsequent calls made with the first argument an empty
205&nbsp;# string will work through the string immediately following that token.  In
206&nbsp;# this way subsequent calls will work through the string s1 until no tokens
207&nbsp;# remain.  The separator string s2 may be different from call to call.
208&nbsp;# When no token remains in s1, an empty value is echoed on stdout.
209&nbsp;#:end docstring:
210&nbsp;
211&nbsp;###;;;autoload
212&nbsp;function strtok ()
213&nbsp;{
214&nbsp; :
215&nbsp;}
216&nbsp;
217&nbsp;#:docstring strtrunc:
218&nbsp;# Usage: strtrunc $n $s1 {$s2} {$...}
219&nbsp;#
220&nbsp;# Used by many functions like strncmp to truncate arguments for comparison.
221&nbsp;# Echoes the first n characters of each string s1 s2 ... on stdout. 
222&nbsp;#:end docstring:
223&nbsp;
224&nbsp;###;;;autoload
225&nbsp;function strtrunc ()
226&nbsp;{
227&nbsp;    n=$1 ; shift
228&nbsp;    for z; do
229&nbsp;        echo "${z:0:$n}"
230&nbsp;    done
231&nbsp;}
232&nbsp;
233&nbsp;# provide string
234&nbsp;
235&nbsp;# string.bash ends here
236&nbsp;
237&nbsp;
238&nbsp;# ========================================================================== #
239&nbsp;# ==&#62; Everything below here added by the document author.
240&nbsp;
241&nbsp;# ==&#62; Suggested use of this script is to delete everything below here,
242&nbsp;# ==&#62; and "source" this file into your own scripts.
243&nbsp;
244&nbsp;# strcat
245&nbsp;string0=one
246&nbsp;string1=two
247&nbsp;echo
248&nbsp;echo "Testing \"strcat\" function:"
249&nbsp;echo "Original \"string0\" = $string0"
250&nbsp;echo "\"string1\" = $string1"
251&nbsp;strcat string0 string1
252&nbsp;echo "New \"string0\" = $string0"
253&nbsp;echo
254&nbsp;
255&nbsp;# strlen
256&nbsp;echo
257&nbsp;echo "Testing \"strlen\" function:"
258&nbsp;str=123456789
259&nbsp;echo "\"str\" = $str"
260&nbsp;echo -n "Length of \"str\" = "
261&nbsp;strlen str
262&nbsp;echo
263&nbsp;
264&nbsp;
265&nbsp;
266&nbsp;# Exercise:
267&nbsp;# --------
268&nbsp;# Add code to test all the other string functions above.
269&nbsp;
270&nbsp;
271&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>这个复杂的数组用例使用了<A
HREF="filearchiv.html#MD5SUMREF"
>md5sum</A
>检查和命令来编码目录信息, 
		此脚本由Michael Zick编写. </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="DIRECTORYINFO"
></A
><P
><B
>例子 A-19. 目录信息</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#! /bin/bash
  2&nbsp;# directory-info.sh
  3&nbsp;# Parses and lists directory information.
  4&nbsp;
  5&nbsp;# NOTE: Change lines 273 and 353 per "README" file.
  6&nbsp;
  7&nbsp;# Michael Zick is the author of this script.
  8&nbsp;# Used here with his permission.
  9&nbsp;
 10&nbsp;# Controls
 11&nbsp;# If overridden by command arguments, they must be in the order:
 12&nbsp;#   Arg1: "Descriptor Directory"
 13&nbsp;#   Arg2: "Exclude Paths"
 14&nbsp;#   Arg3: "Exclude Directories"
 15&nbsp;#
 16&nbsp;# Environment Settings override Defaults.
 17&nbsp;# Command arguments override Environment Settings.
 18&nbsp;
 19&nbsp;# Default location for content addressed file descriptors.
 20&nbsp;MD5UCFS=${1:-${MD5UCFS:-'/tmpfs/ucfs'}}
 21&nbsp;
 22&nbsp;# Directory paths never to list or enter
 23&nbsp;declare -a \
 24&nbsp;  EXCLUDE_PATHS=${2:-${EXCLUDE_PATHS:-'(/proc /dev /devfs /tmpfs)'}}
 25&nbsp;
 26&nbsp;# Directories never to list or enter
 27&nbsp;declare -a \
 28&nbsp;  EXCLUDE_DIRS=${3:-${EXCLUDE_DIRS:-'(ucfs lost+found tmp wtmp)'}}
 29&nbsp;
 30&nbsp;# Files never to list or enter
 31&nbsp;declare -a \
 32&nbsp;  EXCLUDE_FILES=${3:-${EXCLUDE_FILES:-'(core "Name with Spaces")'}}
 33&nbsp;
 34&nbsp;
 35&nbsp;# Here document used as a comment block.
 36&nbsp;: &#60;&#60;LSfieldsDoc
 37&nbsp;# # # # # List Filesystem Directory Information # # # # #
 38&nbsp;#
 39&nbsp;#	ListDirectory "FileGlob" "Field-Array-Name"
 40&nbsp;# or
 41&nbsp;#	ListDirectory -of "FileGlob" "Field-Array-Filename"
 42&nbsp;#	'-of' meaning 'output to filename'
 43&nbsp;# # # # #
 44&nbsp;
 45&nbsp;String format description based on: ls (GNU fileutils) version 4.0.36
 46&nbsp;
 47&nbsp;Produces a line (or more) formatted:
 48&nbsp;inode permissions hard-links owner group ...
 49&nbsp;32736 -rw-------    1 mszick   mszick
 50&nbsp;
 51&nbsp;size    day month date hh:mm:ss year path
 52&nbsp;2756608 Sun Apr 20 08:53:06 2003 /home/mszick/core
 53&nbsp;
 54&nbsp;Unless it is formatted:
 55&nbsp;inode permissions hard-links owner group ...
 56&nbsp;266705 crw-rw----    1    root  uucp
 57&nbsp;
 58&nbsp;major minor day month date hh:mm:ss year path
 59&nbsp;4,  68 Sun Apr 20 09:27:33 2003 /dev/ttyS4
 60&nbsp;NOTE: that pesky comma after the major number
 61&nbsp;
 62&nbsp;NOTE: the 'path' may be multiple fields:
 63&nbsp;/home/mszick/core
 64&nbsp;/proc/982/fd/0 -&#62; /dev/null
 65&nbsp;/proc/982/fd/1 -&#62; /home/mszick/.xsession-errors
 66&nbsp;/proc/982/fd/13 -&#62; /tmp/tmpfZVVOCs (deleted)
 67&nbsp;/proc/982/fd/7 -&#62; /tmp/kde-mszick/ksycoca
 68&nbsp;/proc/982/fd/8 -&#62; socket:[11586]
 69&nbsp;/proc/982/fd/9 -&#62; pipe:[11588]
 70&nbsp;
 71&nbsp;If that isn't enough to keep your parser guessing,
 72&nbsp;either or both of the path components may be relative:
 73&nbsp;../Built-Shared -&#62; Built-Static
 74&nbsp;../linux-2.4.20.tar.bz2 -&#62; ../../../SRCS/linux-2.4.20.tar.bz2
 75&nbsp;
 76&nbsp;The first character of the 11 (10?) character permissions field:
 77&nbsp;'s' Socket
 78&nbsp;'d' Directory
 79&nbsp;'b' Block device
 80&nbsp;'c' Character device
 81&nbsp;'l' Symbolic link
 82&nbsp;NOTE: Hard links not marked - test for identical inode numbers
 83&nbsp;on identical filesystems.
 84&nbsp;All information about hard linked files are shared, except
 85&nbsp;for the names and the name's location in the directory system.
 86&nbsp;NOTE: A "Hard link" is known as a "File Alias" on some systems.
 87&nbsp;'-' An undistingushed file
 88&nbsp;
 89&nbsp;Followed by three groups of letters for: User, Group, Others
 90&nbsp;Character 1: '-' Not readable; 'r' Readable
 91&nbsp;Character 2: '-' Not writable; 'w' Writable
 92&nbsp;Character 3, User and Group: Combined execute and special
 93&nbsp;'-' Not Executable, Not Special
 94&nbsp;'x' Executable, Not Special
 95&nbsp;'s' Executable, Special
 96&nbsp;'S' Not Executable, Special
 97&nbsp;Character 3, Others: Combined execute and sticky (tacky?)
 98&nbsp;'-' Not Executable, Not Tacky
 99&nbsp;'x' Executable, Not Tacky
100&nbsp;'t' Executable, Tacky
101&nbsp;'T' Not Executable, Tacky
102&nbsp;
103&nbsp;Followed by an access indicator
104&nbsp;Haven't tested this one, it may be the eleventh character
105&nbsp;or it may generate another field
106&nbsp;' ' No alternate access
107&nbsp;'+' Alternate access
108&nbsp;LSfieldsDoc
109&nbsp;
110&nbsp;
111&nbsp;ListDirectory()
112&nbsp;{
113&nbsp;	local -a T
114&nbsp;	local -i of=0		# Default return in variable
115&nbsp;#	OLD_IFS=$IFS		# Using BASH default ' \t\n'
116&nbsp;
117&nbsp;	case "$#" in
118&nbsp;	3)	case "$1" in
119&nbsp;		-of)	of=1 ; shift ;;
120&nbsp;		 * )	return 1 ;;
121&nbsp;		esac ;;
122&nbsp;	2)	: ;;		# Poor man's "continue"
123&nbsp;	*)	return 1 ;;
124&nbsp;	esac
125&nbsp;
126&nbsp;	# NOTE: the (ls) command is NOT quoted (")
127&nbsp;	T=( $(ls --inode --ignore-backups --almost-all --directory \
128&nbsp;	--full-time --color=none --time=status --sort=none \
129&nbsp;	--format=long $1) )
130&nbsp;
131&nbsp;	case $of in
132&nbsp;	# Assign T back to the array whose name was passed as $2
133&nbsp;		0) eval $2=\( \"\$\{T\[@\]\}\" \) ;;
134&nbsp;	# Write T into filename passed as $2
135&nbsp;		1) echo "${T[@]}" &#62; "$2" ;;
136&nbsp;	esac
137&nbsp;	return 0
138&nbsp;   }
139&nbsp;
140&nbsp;# # # # # Is that string a legal number? # # # # #
141&nbsp;#
142&nbsp;#	IsNumber "Var"
143&nbsp;# # # # # There has to be a better way, sigh...
144&nbsp;
145&nbsp;IsNumber()
146&nbsp;{
147&nbsp;	local -i int
148&nbsp;	if [ $# -eq 0 ]
149&nbsp;	then
150&nbsp;		return 1
151&nbsp;	else
152&nbsp;		(let int=$1)  2&#62;/dev/null
153&nbsp;		return $?	# Exit status of the let thread
154&nbsp;	fi
155&nbsp;}
156&nbsp;
157&nbsp;# # # # # Index Filesystem Directory Information # # # # #
158&nbsp;#
159&nbsp;#	IndexList "Field-Array-Name" "Index-Array-Name"
160&nbsp;# or
161&nbsp;#	IndexList -if Field-Array-Filename Index-Array-Name
162&nbsp;#	IndexList -of Field-Array-Name Index-Array-Filename
163&nbsp;#	IndexList -if -of Field-Array-Filename Index-Array-Filename
164&nbsp;# # # # #
165&nbsp;
166&nbsp;: &#60;&#60;IndexListDoc
167&nbsp;Walk an array of directory fields produced by ListDirectory
168&nbsp;
169&nbsp;Having suppressed the line breaks in an otherwise line oriented
170&nbsp;report, build an index to the array element which starts each line.
171&nbsp;
172&nbsp;Each line gets two index entries, the first element of each line
173&nbsp;(inode) and the element that holds the pathname of the file.
174&nbsp;
175&nbsp;The first index entry pair (Line-Number==0) are informational:
176&nbsp;Index-Array-Name[0] : Number of "Lines" indexed
177&nbsp;Index-Array-Name[1] : "Current Line" pointer into Index-Array-Name
178&nbsp;
179&nbsp;The following index pairs (if any) hold element indexes into
180&nbsp;the Field-Array-Name per:
181&nbsp;Index-Array-Name[Line-Number * 2] : The "inode" field element.
182&nbsp;NOTE: This distance may be either +11 or +12 elements.
183&nbsp;Index-Array-Name[(Line-Number * 2) + 1] : The "pathname" element.
184&nbsp;NOTE: This distance may be a variable number of elements.
185&nbsp;Next line index pair for Line-Number+1.
186&nbsp;IndexListDoc
187&nbsp;
188&nbsp;
189&nbsp;
190&nbsp;IndexList()
191&nbsp;{
192&nbsp;	local -a LIST			# Local of listname passed
193&nbsp;	local -a -i INDEX=( 0 0 )	# Local of index to return
194&nbsp;	local -i Lidx Lcnt
195&nbsp;	local -i if=0 of=0		# Default to variable names
196&nbsp;
197&nbsp;	case "$#" in			# Simplistic option testing
198&nbsp;		0) return 1 ;;
199&nbsp;		1) return 1 ;;
200&nbsp;		2) : ;;			# Poor man's continue
201&nbsp;		3) case "$1" in
202&nbsp;			-if) if=1 ;;
203&nbsp;			-of) of=1 ;;
204&nbsp;			 * ) return 1 ;;
205&nbsp;		   esac ; shift ;;
206&nbsp;		4) if=1 ; of=1 ; shift ; shift ;;
207&nbsp;		*) return 1
208&nbsp;	esac
209&nbsp;
210&nbsp;	# Make local copy of list
211&nbsp;	case "$if" in
212&nbsp;		0) eval LIST=\( \"\$\{$1\[@\]\}\" \) ;;
213&nbsp;		1) LIST=( $(cat $1) ) ;;
214&nbsp;	esac
215&nbsp;
216&nbsp;	# Grok (grope?) the array
217&nbsp;	Lcnt=${#LIST[@]}
218&nbsp;	Lidx=0
219&nbsp;	until (( Lidx &#62;= Lcnt ))
220&nbsp;	do
221&nbsp;	if IsNumber ${LIST[$Lidx]}
222&nbsp;	then
223&nbsp;		local -i inode name
224&nbsp;		local ft
225&nbsp;		inode=Lidx
226&nbsp;		local m=${LIST[$Lidx+2]}	# Hard Links field
227&nbsp;		ft=${LIST[$Lidx+1]:0:1} 	# Fast-Stat
228&nbsp;		case $ft in
229&nbsp;		b)	((Lidx+=12)) ;;		# Block device
230&nbsp;		c)	((Lidx+=12)) ;;		# Character device
231&nbsp;		*)	((Lidx+=11)) ;;		# Anything else
232&nbsp;		esac
233&nbsp;		name=Lidx
234&nbsp;		case $ft in
235&nbsp;		-)	((Lidx+=1)) ;;		# The easy one
236&nbsp;		b)	((Lidx+=1)) ;;		# Block device
237&nbsp;		c)	((Lidx+=1)) ;;		# Character device
238&nbsp;		d)	((Lidx+=1)) ;;		# The other easy one
239&nbsp;		l)	((Lidx+=3)) ;;		# At LEAST two more fields
240&nbsp;#  A little more elegance here would handle pipes,
241&nbsp;#+ sockets, deleted files - later.
242&nbsp;		*)	until IsNumber ${LIST[$Lidx]} || ((Lidx &#62;= Lcnt))
243&nbsp;			do
244&nbsp;				((Lidx+=1))
245&nbsp;			done
246&nbsp;			;;			# Not required
247&nbsp;		esac
248&nbsp;		INDEX[${#INDEX[*]}]=$inode
249&nbsp;		INDEX[${#INDEX[*]}]=$name
250&nbsp;		INDEX[0]=${INDEX[0]}+1		# One more "line" found
251&nbsp;# echo "Line: ${INDEX[0]} Type: $ft Links: $m Inode: \
252&nbsp;# ${LIST[$inode]} Name: ${LIST[$name]}"
253&nbsp;
254&nbsp;	else
255&nbsp;		((Lidx+=1))
256&nbsp;	fi
257&nbsp;	done
258&nbsp;	case "$of" in
259&nbsp;		0) eval $2=\( \"\$\{INDEX\[@\]\}\" \) ;;
260&nbsp;		1) echo "${INDEX[@]}" &#62; "$2" ;;
261&nbsp;	esac
262&nbsp;	return 0				# What could go wrong?
263&nbsp;}
264&nbsp;
265&nbsp;# # # # # Content Identify File # # # # #
266&nbsp;#
267&nbsp;#	DigestFile Input-Array-Name Digest-Array-Name
268&nbsp;# or
269&nbsp;#	DigestFile -if Input-FileName Digest-Array-Name
270&nbsp;# # # # #
271&nbsp;
272&nbsp;# Here document used as a comment block.
273&nbsp;: &#60;&#60;DigestFilesDoc
274&nbsp;
275&nbsp;The key (no pun intended) to a Unified Content File System (UCFS)
276&nbsp;is to distinguish the files in the system based on their content.
277&nbsp;Distinguishing files by their name is just, so, 20th Century.
278&nbsp;
279&nbsp;The content is distinguished by computing a checksum of that content.
280&nbsp;This version uses the md5sum program to generate a 128 bit checksum
281&nbsp;representative of the file's contents.
282&nbsp;There is a chance that two files having different content might
283&nbsp;generate the same checksum using md5sum (or any checksum).  Should
284&nbsp;that become a problem, then the use of md5sum can be replace by a
285&nbsp;cyrptographic signature.  But until then...
286&nbsp;
287&nbsp;The md5sum program is documented as outputting three fields (and it
288&nbsp;does), but when read it appears as two fields (array elements).  This
289&nbsp;is caused by the lack of whitespace between the second and third field.
290&nbsp;So this function gropes the md5sum output and returns:
291&nbsp;	[0]	32 character checksum in hexidecimal (UCFS filename)
292&nbsp;	[1]	Single character: ' ' text file, '*' binary file
293&nbsp;	[2]	Filesystem (20th Century Style) name
294&nbsp;	Note: That name may be the character '-' indicating STDIN read.
295&nbsp;
296&nbsp;DigestFilesDoc
297&nbsp;
298&nbsp;
299&nbsp;
300&nbsp;DigestFile()
301&nbsp;{
302&nbsp;	local if=0		# Default, variable name
303&nbsp;	local -a T1 T2
304&nbsp;
305&nbsp;	case "$#" in
306&nbsp;	3)	case "$1" in
307&nbsp;		-if)	if=1 ; shift ;;
308&nbsp;		 * )	return 1 ;;
309&nbsp;		esac ;;
310&nbsp;	2)	: ;;		# Poor man's "continue"
311&nbsp;	*)	return 1 ;;
312&nbsp;	esac
313&nbsp;
314&nbsp;	case $if in
315&nbsp;	0) eval T1=\( \"\$\{$1\[@\]\}\" \)
316&nbsp;	   T2=( $(echo ${T1[@]} | md5sum -) )
317&nbsp;	   ;;
318&nbsp;	1) T2=( $(md5sum $1) )
319&nbsp;	   ;;
320&nbsp;	esac
321&nbsp;
322&nbsp;	case ${#T2[@]} in
323&nbsp;	0) return 1 ;;
324&nbsp;	1) return 1 ;;
325&nbsp;	2) case ${T2[1]:0:1} in		# SanScrit-2.0.5
326&nbsp;	   \*) T2[${#T2[@]}]=${T2[1]:1}
327&nbsp;	       T2[1]=\*
328&nbsp;	       ;;
329&nbsp;	    *) T2[${#T2[@]}]=${T2[1]}
330&nbsp;	       T2[1]=" "
331&nbsp;	       ;;
332&nbsp;	   esac
333&nbsp;	   ;;
334&nbsp;	3) : ;; # Assume it worked
335&nbsp;	*) return 1 ;;
336&nbsp;	esac
337&nbsp;
338&nbsp;	local -i len=${#T2[0]}
339&nbsp;	if [ $len -ne 32 ] ; then return 1 ; fi
340&nbsp;	eval $2=\( \"\$\{T2\[@\]\}\" \)
341&nbsp;}
342&nbsp;
343&nbsp;# # # # # Locate File # # # # #
344&nbsp;#
345&nbsp;#	LocateFile [-l] FileName Location-Array-Name
346&nbsp;# or
347&nbsp;#	LocateFile [-l] -of FileName Location-Array-FileName
348&nbsp;# # # # #
349&nbsp;
350&nbsp;# A file location is Filesystem-id and inode-number
351&nbsp;
352&nbsp;# Here document used as a comment block.
353&nbsp;: &#60;&#60;StatFieldsDoc
354&nbsp;	Based on stat, version 2.2
355&nbsp;	stat -t and stat -lt fields
356&nbsp;	[0]	name
357&nbsp;	[1]	Total size
358&nbsp;		File - number of bytes
359&nbsp;		Symbolic link - string length of pathname
360&nbsp;	[2]	Number of (512 byte) blocks allocated
361&nbsp;	[3]	File type and Access rights (hex)
362&nbsp;	[4]	User ID of owner
363&nbsp;	[5]	Group ID of owner
364&nbsp;	[6]	Device number
365&nbsp;	[7]	Inode number
366&nbsp;	[8]	Number of hard links
367&nbsp;	[9]	Device type (if inode device) Major
368&nbsp;	[10]	Device type (if inode device) Minor
369&nbsp;	[11]	Time of last access
370&nbsp;		May be disabled in 'mount' with noatime
371&nbsp;		atime of files changed by exec, read, pipe, utime, mknod (mmap?)
372&nbsp;		atime of directories changed by addition/deletion of files
373&nbsp;	[12]	Time of last modification
374&nbsp;		mtime of files changed by write, truncate, utime, mknod
375&nbsp;		mtime of directories changed by addtition/deletion of files
376&nbsp;	[13]	Time of last change
377&nbsp;		ctime reflects time of changed inode information (owner, group
378&nbsp;		permissions, link count
379&nbsp;-*-*- Per:
380&nbsp;	Return code: 0
381&nbsp;	Size of array: 14
382&nbsp;	Contents of array
383&nbsp;	Element 0: /home/mszick
384&nbsp;	Element 1: 4096
385&nbsp;	Element 2: 8
386&nbsp;	Element 3: 41e8
387&nbsp;	Element 4: 500
388&nbsp;	Element 5: 500
389&nbsp;	Element 6: 303
390&nbsp;	Element 7: 32385
391&nbsp;	Element 8: 22
392&nbsp;	Element 9: 0
393&nbsp;	Element 10: 0
394&nbsp;	Element 11: 1051221030
395&nbsp;	Element 12: 1051214068
396&nbsp;	Element 13: 1051214068
397&nbsp;
398&nbsp;	For a link in the form of linkname -&#62; realname
399&nbsp;	stat -t  linkname returns the linkname (link) information
400&nbsp;	stat -lt linkname returns the realname information
401&nbsp;
402&nbsp;	stat -tf and stat -ltf fields
403&nbsp;	[0]	name
404&nbsp;	[1]	ID-0?		# Maybe someday, but Linux stat structure
405&nbsp;	[2]	ID-0?		# does not have either LABEL nor UUID
406&nbsp;				# fields, currently information must come
407&nbsp;				# from file-system specific utilities
408&nbsp;	These will be munged into:
409&nbsp;	[1]	UUID if possible
410&nbsp;	[2]	Volume Label if possible
411&nbsp;	Note: 'mount -l' does return the label and could return the UUID
412&nbsp;
413&nbsp;	[3]	Maximum length of filenames
414&nbsp;	[4]	Filesystem type
415&nbsp;	[5]	Total blocks in the filesystem
416&nbsp;	[6]	Free blocks
417&nbsp;	[7]	Free blocks for non-root user(s)
418&nbsp;	[8]	Block size of the filesystem
419&nbsp;	[9]	Total inodes
420&nbsp;	[10]	Free inodes
421&nbsp;
422&nbsp;-*-*- Per:
423&nbsp;	Return code: 0
424&nbsp;	Size of array: 11
425&nbsp;	Contents of array
426&nbsp;	Element 0: /home/mszick
427&nbsp;	Element 1: 0
428&nbsp;	Element 2: 0
429&nbsp;	Element 3: 255
430&nbsp;	Element 4: ef53
431&nbsp;	Element 5: 2581445
432&nbsp;	Element 6: 2277180
433&nbsp;	Element 7: 2146050
434&nbsp;	Element 8: 4096
435&nbsp;	Element 9: 1311552
436&nbsp;	Element 10: 1276425
437&nbsp;
438&nbsp;StatFieldsDoc
439&nbsp;
440&nbsp;
441&nbsp;#	LocateFile [-l] FileName Location-Array-Name
442&nbsp;#	LocateFile [-l] -of FileName Location-Array-FileName
443&nbsp;
444&nbsp;LocateFile()
445&nbsp;{
446&nbsp;	local -a LOC LOC1 LOC2
447&nbsp;	local lk="" of=0
448&nbsp;
449&nbsp;	case "$#" in
450&nbsp;	0) return 1 ;;
451&nbsp;	1) return 1 ;;
452&nbsp;	2) : ;;
453&nbsp;	*) while (( "$#" &#62; 2 ))
454&nbsp;	   do
455&nbsp;	      case "$1" in
456&nbsp;	       -l) lk=-1 ;;
457&nbsp;	      -of) of=1 ;;
458&nbsp;	        *) return 1 ;;
459&nbsp;	      esac
460&nbsp;	   shift
461&nbsp;           done ;;
462&nbsp;	esac
463&nbsp;
464&nbsp;# More Sanscrit-2.0.5
465&nbsp;      # LOC1=( $(stat -t $lk $1) )
466&nbsp;      # LOC2=( $(stat -tf $lk $1) )
467&nbsp;      # Uncomment above two lines if system has "stat" command installed.
468&nbsp;	LOC=( ${LOC1[@]:0:1} ${LOC1[@]:3:11}
469&nbsp;	      ${LOC2[@]:1:2} ${LOC2[@]:4:1} )
470&nbsp;
471&nbsp;	case "$of" in
472&nbsp;		0) eval $2=\( \"\$\{LOC\[@\]\}\" \) ;;
473&nbsp;		1) echo "${LOC[@]}" &#62; "$2" ;;
474&nbsp;	esac
475&nbsp;	return 0
476&nbsp;# Which yields (if you are lucky, and have "stat" installed)
477&nbsp;# -*-*- Location Discriptor -*-*-
478&nbsp;#	Return code: 0
479&nbsp;#	Size of array: 15
480&nbsp;#	Contents of array
481&nbsp;#	Element 0: /home/mszick		20th Century name
482&nbsp;#	Element 1: 41e8			Type and Permissions
483&nbsp;#	Element 2: 500			User
484&nbsp;#	Element 3: 500			Group
485&nbsp;#	Element 4: 303			Device
486&nbsp;#	Element 5: 32385		inode
487&nbsp;#	Element 6: 22			Link count
488&nbsp;#	Element 7: 0			Device Major
489&nbsp;#	Element 8: 0			Device Minor
490&nbsp;#	Element 9: 1051224608		Last Access
491&nbsp;#	Element 10: 1051214068		Last Modify
492&nbsp;#	Element 11: 1051214068		Last Status
493&nbsp;#	Element 12: 0			UUID (to be)
494&nbsp;#	Element 13: 0			Volume Label (to be)
495&nbsp;#	Element 14: ef53		Filesystem type
496&nbsp;}
497&nbsp;
498&nbsp;
499&nbsp;
500&nbsp;# And then there was some test code
501&nbsp;
502&nbsp;ListArray() # ListArray Name
503&nbsp;{
504&nbsp;	local -a Ta
505&nbsp;
506&nbsp;	eval Ta=\( \"\$\{$1\[@\]\}\" \)
507&nbsp;	echo
508&nbsp;	echo "-*-*- List of Array -*-*-"
509&nbsp;	echo "Size of array $1: ${#Ta[*]}"
510&nbsp;	echo "Contents of array $1:"
511&nbsp;	for (( i=0 ; i&#60;${#Ta[*]} ; i++ ))
512&nbsp;	do
513&nbsp;	    echo -e "\tElement $i: ${Ta[$i]}"
514&nbsp;	done
515&nbsp;	return 0
516&nbsp;}
517&nbsp;
518&nbsp;declare -a CUR_DIR
519&nbsp;# For small arrays
520&nbsp;ListDirectory "${PWD}" CUR_DIR
521&nbsp;ListArray CUR_DIR
522&nbsp;
523&nbsp;declare -a DIR_DIG
524&nbsp;DigestFile CUR_DIR DIR_DIG
525&nbsp;echo "The new \"name\" (checksum) for ${CUR_DIR[9]} is ${DIR_DIG[0]}"
526&nbsp;
527&nbsp;declare -a DIR_ENT
528&nbsp;# BIG_DIR # For really big arrays - use a temporary file in ramdisk
529&nbsp;# BIG-DIR # ListDirectory -of "${CUR_DIR[11]}/*" "/tmpfs/junk2"
530&nbsp;ListDirectory "${CUR_DIR[11]}/*" DIR_ENT
531&nbsp;
532&nbsp;declare -a DIR_IDX
533&nbsp;# BIG-DIR # IndexList -if "/tmpfs/junk2" DIR_IDX
534&nbsp;IndexList DIR_ENT DIR_IDX
535&nbsp;
536&nbsp;declare -a IDX_DIG
537&nbsp;# BIG-DIR # DIR_ENT=( $(cat /tmpfs/junk2) )
538&nbsp;# BIG-DIR # DigestFile -if /tmpfs/junk2 IDX_DIG
539&nbsp;DigestFile DIR_ENT IDX_DIG
540&nbsp;# Small (should) be able to parallize IndexList &#38; DigestFile
541&nbsp;# Large (should) be able to parallize IndexList &#38; DigestFile &#38; the assignment
542&nbsp;echo "The \"name\" (checksum) for the contents of ${PWD} is ${IDX_DIG[0]}"
543&nbsp;
544&nbsp;declare -a FILE_LOC
545&nbsp;LocateFile ${PWD} FILE_LOC
546&nbsp;ListArray FILE_LOC
547&nbsp;
548&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>Stephane Chazelas向我们展示了如何在Bash脚本中使用面向对象的编程方法. </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="OBJORIENTED"
></A
><P
><B
>例子 A-20. 面向对象数据库</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# obj-oriented.sh: Object-oriented programming in a shell script.
  3&nbsp;# Script by Stephane Chazelas.
  4&nbsp;
  5&nbsp;#  Important Note:
  6&nbsp;#  --------- ----
  7&nbsp;#  If running this script under version 3 or later of Bash,
  8&nbsp;#+ replace all periods in function names with a "legal" character,
  9&nbsp;#+ for example, an underscore.
 10&nbsp;
 11&nbsp;
 12&nbsp;person.new()        # Looks almost like a class declaration in C++.
 13&nbsp;{
 14&nbsp;  local obj_name=$1 name=$2 firstname=$3 birthdate=$4
 15&nbsp;
 16&nbsp;  eval "$obj_name.set_name() {
 17&nbsp;          eval \"$obj_name.get_name() {
 18&nbsp;                   echo \$1
 19&nbsp;                 }\"
 20&nbsp;        }"
 21&nbsp;
 22&nbsp;  eval "$obj_name.set_firstname() {
 23&nbsp;          eval \"$obj_name.get_firstname() {
 24&nbsp;                   echo \$1
 25&nbsp;                 }\"
 26&nbsp;        }"
 27&nbsp;
 28&nbsp;  eval "$obj_name.set_birthdate() {
 29&nbsp;          eval \"$obj_name.get_birthdate() {
 30&nbsp;            echo \$1
 31&nbsp;          }\"
 32&nbsp;          eval \"$obj_name.show_birthdate() {
 33&nbsp;            echo \$(date -d \"1/1/1970 0:0:\$1 GMT\")
 34&nbsp;          }\"
 35&nbsp;          eval \"$obj_name.get_age() {
 36&nbsp;            echo \$(( (\$(date +%s) - \$1) / 3600 / 24 / 365 ))
 37&nbsp;          }\"
 38&nbsp;        }"
 39&nbsp;
 40&nbsp;  $obj_name.set_name $name
 41&nbsp;  $obj_name.set_firstname $firstname
 42&nbsp;  $obj_name.set_birthdate $birthdate
 43&nbsp;}
 44&nbsp;
 45&nbsp;echo
 46&nbsp;
 47&nbsp;person.new self Bozeman Bozo 101272413
 48&nbsp;# Create an instance of "person.new" (actually passing args to the function).
 49&nbsp;
 50&nbsp;self.get_firstname       #   Bozo
 51&nbsp;self.get_name            #   Bozeman
 52&nbsp;self.get_age             #   28
 53&nbsp;self.get_birthdate       #   101272413
 54&nbsp;self.show_birthdate      #   Sat Mar 17 20:13:33 MST 1973
 55&nbsp;
 56&nbsp;echo
 57&nbsp;
 58&nbsp;#  typeset -f
 59&nbsp;#+ to see the created functions (careful, it scrolls off the page).
 60&nbsp;
 61&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>Mariusz Gniazdowski发布了一个可以在脚本中使用的<A
HREF="internal.html#HASHREF"
>hash</A
>库. </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="HASHLIB"
></A
><P
><B
>例子 A-21. hash函数库</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;# Hash:
  2&nbsp;# Hash function library
  3&nbsp;# Author: Mariusz Gniazdowski &#60;mgniazd-at-gmail.com&#62;
  4&nbsp;# Date: 2005-04-07
  5&nbsp;
  6&nbsp;# Functions making emulating hashes in Bash a little less painful.
  7&nbsp;
  8&nbsp;
  9&nbsp;#    Limitations:
 10&nbsp;#  * Only global variables are supported.
 11&nbsp;#  * Each hash instance generates one global variable per value.
 12&nbsp;#  * Variable names collisions are possible
 13&nbsp;#+   if you define variable like __hash__hashname_key
 14&nbsp;#  * Keys must use chars that can be part of a Bash variable name
 15&nbsp;#+   (no dashes, periods, etc.).
 16&nbsp;#  * The hash is created as a variable:
 17&nbsp;#    ... hashname_keyname
 18&nbsp;#    So if somone will create hashes like:
 19&nbsp;#      myhash_ + mykey = myhash__mykey
 20&nbsp;#      myhash + _mykey = myhash__mykey
 21&nbsp;#    Then there will be a collision.
 22&nbsp;#    (This should not pose a major problem.)
 23&nbsp;
 24&nbsp;
 25&nbsp;Hash_config_varname_prefix=__hash__
 26&nbsp;
 27&nbsp;
 28&nbsp;# Emulates:  hash[key]=value
 29&nbsp;#
 30&nbsp;# Params:
 31&nbsp;# 1 - hash
 32&nbsp;# 2 - key
 33&nbsp;# 3 - value
 34&nbsp;function hash_set {
 35&nbsp;	eval "${Hash_config_varname_prefix}${1}_${2}=\"${3}\""
 36&nbsp;}
 37&nbsp;
 38&nbsp;
 39&nbsp;# Emulates:  value=hash[key]
 40&nbsp;#
 41&nbsp;# Params:
 42&nbsp;# 1 - hash
 43&nbsp;# 2 - key
 44&nbsp;# 3 - value (name of global variable to set)
 45&nbsp;function hash_get_into {
 46&nbsp;	eval "$3=\"\$${Hash_config_varname_prefix}${1}_${2}\""
 47&nbsp;}
 48&nbsp;
 49&nbsp;
 50&nbsp;# Emulates:  echo hash[key]
 51&nbsp;#
 52&nbsp;# Params:
 53&nbsp;# 1 - hash
 54&nbsp;# 2 - key
 55&nbsp;# 3 - echo params (like -n, for example)
 56&nbsp;function hash_echo {
 57&nbsp;	eval "echo $3 \"\$${Hash_config_varname_prefix}${1}_${2}\""
 58&nbsp;}
 59&nbsp;
 60&nbsp;
 61&nbsp;# Emulates:  hash1[key1]=hash2[key2]
 62&nbsp;#
 63&nbsp;# Params:
 64&nbsp;# 1 - hash1
 65&nbsp;# 2 - key1
 66&nbsp;# 3 - hash2
 67&nbsp;# 4 - key2
 68&nbsp;function hash_copy {
 69&nbsp;	eval "${Hash_config_varname_prefix}${1}_${2}=\"\$${Hash_config_varname_prefix}${3}_${4}\""
 70&nbsp;}
 71&nbsp;
 72&nbsp;
 73&nbsp;# Emulates:  hash[keyN-1]=hash[key2]=...hash[key1]
 74&nbsp;#
 75&nbsp;# Copies first key to rest of keys.
 76&nbsp;#
 77&nbsp;# Params:
 78&nbsp;# 1 - hash1
 79&nbsp;# 2 - key1
 80&nbsp;# 3 - key2
 81&nbsp;# . . .
 82&nbsp;# N - keyN
 83&nbsp;function hash_dup {
 84&nbsp;	local hashName="$1" keyName="$2"
 85&nbsp;	shift 2
 86&nbsp;	until [ ${#} -le 0 ]; do
 87&nbsp;		eval "${Hash_config_varname_prefix}${hashName}_${1}=\"\$${Hash_config_varname_prefix}${hashName}_${keyName}\""
 88&nbsp;		shift;
 89&nbsp;	done;
 90&nbsp;}
 91&nbsp;
 92&nbsp;
 93&nbsp;# Emulates:  unset hash[key]
 94&nbsp;#
 95&nbsp;# Params:
 96&nbsp;# 1 - hash
 97&nbsp;# 2 - key
 98&nbsp;function hash_unset {
 99&nbsp;	eval "unset ${Hash_config_varname_prefix}${1}_${2}"
100&nbsp;}
101&nbsp;
102&nbsp;
103&nbsp;# Emulates something similar to:  ref=&#38;hash[key]
104&nbsp;#
105&nbsp;# The reference is name of the variable in which value is held.
106&nbsp;#
107&nbsp;# Params:
108&nbsp;# 1 - hash
109&nbsp;# 2 - key
110&nbsp;# 3 - ref - Name of global variable to set.
111&nbsp;function hash_get_ref_into {
112&nbsp;	eval "$3=\"${Hash_config_varname_prefix}${1}_${2}\""
113&nbsp;}
114&nbsp;
115&nbsp;
116&nbsp;# Emulates something similar to:  echo &#38;hash[key]
117&nbsp;#
118&nbsp;# That reference is name of variable in which value is held.
119&nbsp;#
120&nbsp;# Params:
121&nbsp;# 1 - hash
122&nbsp;# 2 - key
123&nbsp;# 3 - echo params (like -n for example)
124&nbsp;function hash_echo_ref {
125&nbsp;	eval "echo $3 \"${Hash_config_varname_prefix}${1}_${2}\""
126&nbsp;}
127&nbsp;
128&nbsp;
129&nbsp;
130&nbsp;# Emulates something similar to:  $$hash[key](param1, param2, ...)
131&nbsp;#
132&nbsp;# Params:
133&nbsp;# 1 - hash
134&nbsp;# 2 - key
135&nbsp;# 3,4, ... - Function parameters
136&nbsp;function hash_call {
137&nbsp;	local hash key
138&nbsp;	hash=$1
139&nbsp;	key=$2
140&nbsp;	shift 2
141&nbsp;	eval "eval \"\$${Hash_config_varname_prefix}${hash}_${key} \\\"\\\$@\\\"\""
142&nbsp;}
143&nbsp;
144&nbsp;
145&nbsp;# Emulates something similar to:  isset(hash[key]) or hash[key]==NULL
146&nbsp;#
147&nbsp;# Params:
148&nbsp;# 1 - hash
149&nbsp;# 2 - key
150&nbsp;# Returns:
151&nbsp;# 0 - there is such key
152&nbsp;# 1 - there is no such key
153&nbsp;function hash_is_set {
154&nbsp;	eval "if [[ \"\${${Hash_config_varname_prefix}${1}_${2}-a}\" = \"a\" &#38;&#38; 
155&nbsp;			\"\${${Hash_config_varname_prefix}${1}_${2}-b}\" = \"b\" ]]; then return 1; else return 0; fi"
156&nbsp;}
157&nbsp;
158&nbsp;
159&nbsp;# Emulates something similar to:
160&nbsp;#   foreach($hash as $key =&#62; $value) { fun($key,$value); }
161&nbsp;#
162&nbsp;# It is possible to write different variations of this function.
163&nbsp;# Here we use a function call to make it as "generic" as possible.
164&nbsp;#
165&nbsp;# Params:
166&nbsp;# 1 - hash
167&nbsp;# 2 - function name
168&nbsp;function hash_foreach {
169&nbsp;	local keyname oldIFS="$IFS"
170&nbsp;	IFS=' '
171&nbsp;	for i in $(eval "echo \${!${Hash_config_varname_prefix}${1}_*}"); do
172&nbsp;		keyname=$(eval "echo \${i##${Hash_config_varname_prefix}${1}_}")
173&nbsp;		eval "$2 $keyname \"\$$i\""
174&nbsp;	done
175&nbsp;	IFS="$oldIFS"
176&nbsp;}
177&nbsp;
178&nbsp;# NOTE: In lines 103 and 116, ampersand changed.
179&nbsp;#       But, it doesn't matter, because these are comment lines anyhow.</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>这是个例子脚本, 这个脚本使用了前面的hash库. </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="HASHEXAMPLE"
></A
><P
><B
>例子 A-22. 使用hash函数来给文本上色</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# hash-example.sh: Colorizing text.
  3&nbsp;# Author: Mariusz Gniazdowski &#60;mgniazd-at-gmail.com&#62;
  4&nbsp;
  5&nbsp;. Hash.lib      # Load the library of functions.
  6&nbsp;
  7&nbsp;hash_set colors red          "\033[0;31m"
  8&nbsp;hash_set colors blue         "\033[0;34m"
  9&nbsp;hash_set colors light_blue   "\033[1;34m"
 10&nbsp;hash_set colors light_red    "\033[1;31m"
 11&nbsp;hash_set colors cyan         "\033[0;36m"
 12&nbsp;hash_set colors light_green  "\033[1;32m"
 13&nbsp;hash_set colors light_gray   "\033[0;37m"
 14&nbsp;hash_set colors green        "\033[0;32m"
 15&nbsp;hash_set colors yellow       "\033[1;33m"
 16&nbsp;hash_set colors light_purple "\033[1;35m"
 17&nbsp;hash_set colors purple       "\033[0;35m"
 18&nbsp;hash_set colors reset_color  "\033[0;00m"
 19&nbsp;
 20&nbsp;
 21&nbsp;# $1 - keyname
 22&nbsp;# $2 - value
 23&nbsp;try_colors() {
 24&nbsp;	echo -en "$2"
 25&nbsp;	echo "This line is $1."
 26&nbsp;}
 27&nbsp;hash_foreach colors try_colors
 28&nbsp;hash_echo colors reset_color -en
 29&nbsp;
 30&nbsp;echo -e '\nLet us overwrite some colors with yellow.\n'
 31&nbsp;# It's hard to read yellow text on some terminals.
 32&nbsp;hash_dup colors yellow   red light_green blue green light_gray cyan
 33&nbsp;hash_foreach colors try_colors
 34&nbsp;hash_echo colors reset_color -en
 35&nbsp;
 36&nbsp;echo -e '\nLet us delete them and try colors once more . . .\n'
 37&nbsp;
 38&nbsp;for i in red light_green blue green light_gray cyan; do
 39&nbsp;	hash_unset colors $i
 40&nbsp;done
 41&nbsp;hash_foreach colors try_colors
 42&nbsp;hash_echo colors reset_color -en
 43&nbsp;
 44&nbsp;hash_set other txt "Other examples . . ."
 45&nbsp;hash_echo other txt
 46&nbsp;hash_get_into other txt text
 47&nbsp;echo $text
 48&nbsp;
 49&nbsp;hash_set other my_fun try_colors
 50&nbsp;hash_call other my_fun   purple "`hash_echo colors purple`"
 51&nbsp;hash_echo colors reset_color -en
 52&nbsp;
 53&nbsp;echo; echo "Back to normal?"; echo
 54&nbsp;
 55&nbsp;exit $?
 56&nbsp;
 57&nbsp;#  On some terminals, the "light" colors print in bold,
 58&nbsp;#  and end up looking darker than the normal ones.
 59&nbsp;#  Why is this?&#13;</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>站在一个比较难的观点来阐明hash的结构. </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="HASHEX2"
></A
><P
><B
>例子 A-23. 深入hash函数</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# $Id: ha.sh,v 1.2 2005/04/21 23:24:26 oliver Exp $
  3&nbsp;# Copyright 2005 Oliver Beckstein
  4&nbsp;# Released under the GNU Public License
  5&nbsp;# Author of script granted permission for inclusion in ABS Guide.
  6&nbsp;# (Thank you!)
  7&nbsp;
  8&nbsp;#----------------------------------------------------------------
  9&nbsp;# pseudo hash based on indirect parameter expansion
 10&nbsp;# API: access through functions:
 11&nbsp;# 
 12&nbsp;# create the hash:
 13&nbsp;#  
 14&nbsp;#      newhash Lovers
 15&nbsp;#
 16&nbsp;# add entries (note single quotes for spaces)
 17&nbsp;#    
 18&nbsp;#      addhash Lovers Tristan Isolde
 19&nbsp;#      addhash Lovers 'Romeo Montague' 'Juliet Capulet'
 20&nbsp;#
 21&nbsp;# access value by key
 22&nbsp;#
 23&nbsp;#      gethash Lovers Tristan   ----&#62;  Isolde
 24&nbsp;#
 25&nbsp;# show all keys
 26&nbsp;#
 27&nbsp;#      keyshash Lovers         ----&#62; 'Tristan'  'Romeo Montague'
 28&nbsp;#
 29&nbsp;#
 30&nbsp;# convention: instead of perls' foo{bar} = boing' syntax,
 31&nbsp;# use
 32&nbsp;#       '_foo_bar=boing' (two underscores, no spaces)
 33&nbsp;#
 34&nbsp;# 1) store key   in _NAME_keys[]
 35&nbsp;# 2) store value in _NAME_values[] using the same integer index
 36&nbsp;# The integer index for the last entry is _NAME_ptr
 37&nbsp;#
 38&nbsp;# NOTE: No error or sanity checks, just bare bones.
 39&nbsp;
 40&nbsp;
 41&nbsp;function _inihash () {
 42&nbsp;    # private function
 43&nbsp;    # call at the beginning of each procedure
 44&nbsp;    # defines: _keys _values _ptr
 45&nbsp;    #
 46&nbsp;    # usage: _inihash NAME
 47&nbsp;    local name=$1
 48&nbsp;    _keys=_${name}_keys
 49&nbsp;    _values=_${name}_values
 50&nbsp;    _ptr=_${name}_ptr
 51&nbsp;}
 52&nbsp;
 53&nbsp;function newhash () {
 54&nbsp;    # usage: newhash NAME
 55&nbsp;    #        NAME should not contain spaces or '.';
 56&nbsp;    #        actually: it must be a legal name for a bash variable
 57&nbsp;    # We rely on bash automatically recognising arrays.
 58&nbsp;    local name=$1 
 59&nbsp;    local _keys _values _ptr
 60&nbsp;    _inihash ${name}
 61&nbsp;    eval ${_ptr}=0
 62&nbsp;}
 63&nbsp;
 64&nbsp;
 65&nbsp;function addhash () {
 66&nbsp;    # usage: addhash NAME KEY 'VALUE with spaces'
 67&nbsp;    #        arguments with spaces need to be quoted with single quotes ''
 68&nbsp;    local name=$1 k="$2" v="$3" 
 69&nbsp;    local _keys _values _ptr
 70&nbsp;    _inihash ${name}
 71&nbsp;
 72&nbsp;    #echo "DEBUG(addhash): ${_ptr}=${!_ptr}"
 73&nbsp;
 74&nbsp;    eval let ${_ptr}=${_ptr}+1
 75&nbsp;    eval "$_keys[${!_ptr}]=\"${k}\""
 76&nbsp;    eval "$_values[${!_ptr}]=\"${v}\""
 77&nbsp;}
 78&nbsp;
 79&nbsp;function gethash () {
 80&nbsp;    # usage: gethash NAME KEY
 81&nbsp;    #        returns boing
 82&nbsp;    #        ERR=0 if entry found, 1 otherwise
 83&nbsp;    # Thats not a proper hash---we simply linearly search through the keys
 84&nbsp;    local name=$1 key="$2" 
 85&nbsp;    local _keys _values _ptr 
 86&nbsp;    local k v i found h
 87&nbsp;    _inihash ${name}
 88&nbsp;    
 89&nbsp;    # _ptr holds the highest index in the hash
 90&nbsp;    found=0
 91&nbsp;
 92&nbsp;    for i in $(seq 1 ${!_ptr}); do
 93&nbsp;	h="\${${_keys}[${i}]}"  # safer to do it in two steps
 94&nbsp;	eval k=${h}             # (especially when quoting for spaces)
 95&nbsp;	if [ "${k}" = "${key}" ]; then found=1; break; fi
 96&nbsp;    done;
 97&nbsp;
 98&nbsp;    [ ${found} = 0 ] &#38;&#38; return 1;
 99&nbsp;    # else: i is the index that matches the key
100&nbsp;    h="\${${_values}[${i}]}"
101&nbsp;    eval echo "${h}"
102&nbsp;    return 0;	
103&nbsp;}
104&nbsp;
105&nbsp;function keyshash () {
106&nbsp;    # usage: keyshash NAME
107&nbsp;    # returns list of all keys defined for hash name
108&nbsp;    local name=$1 key="$2" 
109&nbsp;    local _keys _values _ptr 
110&nbsp;    local k i h
111&nbsp;    _inihash ${name}
112&nbsp;    
113&nbsp;    # _ptr holds the highest index in the hash
114&nbsp;    for i in $(seq 1 ${!_ptr}); do
115&nbsp;	h="\${${_keys}[${i}]}"   # Safer to do it in two steps
116&nbsp;	eval k=${h}              # (especially when quoting for spaces)
117&nbsp;	echo -n "'${k}' "
118&nbsp;    done;
119&nbsp;}
120&nbsp;
121&nbsp;
122&nbsp;# --------------------------------------------------------------------
123&nbsp;
124&nbsp;# Now, let's test it.
125&nbsp;# (Per comments at the beginning of the script.)
126&nbsp;newhash Lovers
127&nbsp;addhash Lovers Tristan Isolde
128&nbsp;addhash Lovers 'Romeo Montague' 'Juliet Capulet'
129&nbsp;
130&nbsp;# Output results.
131&nbsp;echo
132&nbsp;gethash Lovers Tristan      # Isolde
133&nbsp;echo
134&nbsp;keyshash Lovers             # 'Tristan' 'Romeo Montague'
135&nbsp;echo; echo
136&nbsp;
137&nbsp;
138&nbsp;exit 0
139&nbsp;
140&nbsp;# Exercise: Add error checks to the functions.</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>下面这个脚本可以用来安装和挂载那些小的USB keychain<SPAN
CLASS="QUOTE"
>"硬件设备"</SPAN
>(译者: 就是U盘一类的东西). </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="USBINST"
></A
><P
><B
>例子 A-24. 挂载USB keychain型的存储设备</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# ==&#62; usb.sh
  3&nbsp;# ==&#62; Script for mounting and installing pen/keychain USB storage devices.
  4&nbsp;# ==&#62; Runs as root at system startup (see below).
  5&nbsp;# ==&#62;
  6&nbsp;# ==&#62; Newer Linux distros (2004 or later) autodetect
  7&nbsp;# ==&#62; and install USB pen drives, and therefore don't need this script.
  8&nbsp;# ==&#62; But, it's still instructive.
  9&nbsp; 
 10&nbsp;#  This code is free software covered by GNU GPL license version 2 or above.
 11&nbsp;#  Please refer to http://www.gnu.org/ for the full license text.
 12&nbsp;#
 13&nbsp;#  Some code lifted from usb-mount by Michael Hamilton's usb-mount (LGPL)
 14&nbsp;#+ see http://users.actrix.co.nz/michael/usbmount.html
 15&nbsp;#
 16&nbsp;#  INSTALL
 17&nbsp;#  -------
 18&nbsp;#  Put this in /etc/hotplug/usb/diskonkey.
 19&nbsp;#  Then look in /etc/hotplug/usb.distmap, and copy all usb-storage entries
 20&nbsp;#+ into /etc/hotplug/usb.usermap, substituting "usb-storage" for "diskonkey".
 21&nbsp;#  Otherwise this code is only run during the kernel module invocation/removal
 22&nbsp;#+ (at least in my tests), which defeats the purpose.
 23&nbsp;#
 24&nbsp;#  TODO
 25&nbsp;#  ----
 26&nbsp;#  Handle more than one diskonkey device at one time (e.g. /dev/diskonkey1
 27&nbsp;#+ and /mnt/diskonkey1), etc. The biggest problem here is the handling in
 28&nbsp;#+ devlabel, which I haven't yet tried.
 29&nbsp;#
 30&nbsp;#  AUTHOR and SUPPORT
 31&nbsp;#  ------------------
 32&nbsp;#  Konstantin Riabitsev, &#60;icon linux duke edu&#62;.
 33&nbsp;#  Send any problem reports to my email address at the moment.
 34&nbsp;#
 35&nbsp;# ==&#62; Comments added by ABS Guide author.
 36&nbsp;
 37&nbsp;
 38&nbsp;
 39&nbsp;SYMLINKDEV=/dev/diskonkey
 40&nbsp;MOUNTPOINT=/mnt/diskonkey
 41&nbsp;DEVLABEL=/sbin/devlabel
 42&nbsp;DEVLABELCONFIG=/etc/sysconfig/devlabel
 43&nbsp;IAM=$0
 44&nbsp;
 45&nbsp;##
 46&nbsp;# Functions lifted near-verbatim from usb-mount code.
 47&nbsp;#
 48&nbsp;function allAttachedScsiUsb {
 49&nbsp;    find /proc/scsi/ -path '/proc/scsi/usb-storage*' -type f | xargs grep -l 'Attached: Yes'
 50&nbsp;}
 51&nbsp;function scsiDevFromScsiUsb {
 52&nbsp;    echo $1 | awk -F"[-/]" '{ n=$(NF-1);  print "/dev/sd" substr("abcdefghijklmnopqrstuvwxyz", n+1,
 53&nbsp; 1) }'
 54&nbsp;}
 55&nbsp;
 56&nbsp;if [ "${ACTION}" = "add" ] &#38;&#38; [ -f "${DEVICE}" ]; then
 57&nbsp;    ##
 58&nbsp;    # lifted from usbcam code.
 59&nbsp;    #
 60&nbsp;    if [ -f /var/run/console.lock ]; then
 61&nbsp;        CONSOLEOWNER=`cat /var/run/console.lock`
 62&nbsp;    elif [ -f /var/lock/console.lock ]; then
 63&nbsp;        CONSOLEOWNER=`cat /var/lock/console.lock`
 64&nbsp;    else
 65&nbsp;        CONSOLEOWNER=
 66&nbsp;    fi
 67&nbsp;    for procEntry in $(allAttachedScsiUsb); do
 68&nbsp;        scsiDev=$(scsiDevFromScsiUsb $procEntry)
 69&nbsp;        #  Some bug with usb-storage?
 70&nbsp;        #  Partitions are not in /proc/partitions until they are accessed
 71&nbsp;        #+ somehow.
 72&nbsp;        /sbin/fdisk -l $scsiDev &#62;/dev/null
 73&nbsp;        ##
 74&nbsp;        #  Most devices have partitioning info, so the data would be on
 75&nbsp;        #+ /dev/sd?1. However, some stupider ones don't have any partitioning
 76&nbsp;        #+ and use the entire device for data storage. This tries to
 77&nbsp;        #+ guess semi-intelligently if we have a /dev/sd?1 and if not, then
 78&nbsp;        #+ it uses the entire device and hopes for the better.
 79&nbsp;        #
 80&nbsp;        if grep -q `basename $scsiDev`1 /proc/partitions; then
 81&nbsp;            part="$scsiDev""1"
 82&nbsp;        else
 83&nbsp;            part=$scsiDev
 84&nbsp;        fi
 85&nbsp;        ##
 86&nbsp;        #  Change ownership of the partition to the console user so they can
 87&nbsp;        #+ mount it.
 88&nbsp;        #
 89&nbsp;        if [ ! -z "$CONSOLEOWNER" ]; then
 90&nbsp;            chown $CONSOLEOWNER:disk $part
 91&nbsp;        fi
 92&nbsp;        ##
 93&nbsp;        # This checks if we already have this UUID defined with devlabel.
 94&nbsp;        # If not, it then adds the device to the list.
 95&nbsp;        #
 96&nbsp;        prodid=`$DEVLABEL printid -d $part`
 97&nbsp;        if ! grep -q $prodid $DEVLABELCONFIG; then
 98&nbsp;            # cross our fingers and hope it works
 99&nbsp;            $DEVLABEL add -d $part -s $SYMLINKDEV 2&#62;/dev/null
100&nbsp;        fi
101&nbsp;        ##
102&nbsp;        # Check if the mount point exists and create if it doesn't.
103&nbsp;        #
104&nbsp;        if [ ! -e $MOUNTPOINT ]; then
105&nbsp;            mkdir -p $MOUNTPOINT
106&nbsp;        fi
107&nbsp;        ##
108&nbsp;        # Take care of /etc/fstab so mounting is easy.
109&nbsp;        #
110&nbsp;        if ! grep -q "^$SYMLINKDEV" /etc/fstab; then
111&nbsp;            # Add an fstab entry
112&nbsp;            echo -e \
113&nbsp;                "$SYMLINKDEV\t\t$MOUNTPOINT\t\tauto\tnoauto,owner,kudzu 0 0" \
114&nbsp;                &#62;&#62; /etc/fstab
115&nbsp;        fi
116&nbsp;    done
117&nbsp;    if [ ! -z "$REMOVER" ]; then
118&nbsp;        ##
119&nbsp;        # Make sure this script is triggered on device removal.
120&nbsp;        #
121&nbsp;        mkdir -p `dirname $REMOVER`
122&nbsp;        ln -s $IAM $REMOVER
123&nbsp;    fi
124&nbsp;elif [ "${ACTION}" = "remove" ]; then
125&nbsp;    ##
126&nbsp;    # If the device is mounted, unmount it cleanly.
127&nbsp;    #
128&nbsp;    if grep -q "$MOUNTPOINT" /etc/mtab; then
129&nbsp;        # unmount cleanly
130&nbsp;        umount -l $MOUNTPOINT
131&nbsp;    fi
132&nbsp;    ##
133&nbsp;    # Remove it from /etc/fstab if it's there.
134&nbsp;    #
135&nbsp;    if grep -q "^$SYMLINKDEV" /etc/fstab; then
136&nbsp;        grep -v "^$SYMLINKDEV" /etc/fstab &#62; /etc/.fstab.new
137&nbsp;        mv -f /etc/.fstab.new /etc/fstab
138&nbsp;    fi
139&nbsp;fi
140&nbsp;
141&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>这个脚本对于站点管理员来说很有用: 这是一个可以保存weblog的脚本. </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ARCHIVWEBLOGS"
></A
><P
><B
>例子 A-25. 保存weblog</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# archiveweblogs.sh v1.0
  3&nbsp;
  4&nbsp;# Troy Engel &#60;tengel@fluid.com&#62;
  5&nbsp;# Slightly modified by document author.
  6&nbsp;# Used with permission.
  7&nbsp;#
  8&nbsp;#  This script will preserve the normally rotated and
  9&nbsp;#+ thrown away weblogs from a default RedHat/Apache installation.
 10&nbsp;#  It will save the files with a date/time stamp in the filename,
 11&nbsp;#+ bzipped, to a given directory.
 12&nbsp;#
 13&nbsp;#  Run this from crontab nightly at an off hour,
 14&nbsp;#+ as bzip2 can suck up some serious CPU on huge logs:
 15&nbsp;#  0 2 * * * /opt/sbin/archiveweblogs.sh
 16&nbsp;
 17&nbsp;
 18&nbsp;PROBLEM=66
 19&nbsp;
 20&nbsp;# Set this to your backup dir.
 21&nbsp;BKP_DIR=/opt/backups/weblogs
 22&nbsp;
 23&nbsp;# Default Apache/RedHat stuff
 24&nbsp;LOG_DAYS="4 3 2 1"
 25&nbsp;LOG_DIR=/var/log/httpd
 26&nbsp;LOG_FILES="access_log error_log"
 27&nbsp;
 28&nbsp;# Default RedHat program locations
 29&nbsp;LS=/bin/ls
 30&nbsp;MV=/bin/mv
 31&nbsp;ID=/usr/bin/id
 32&nbsp;CUT=/bin/cut
 33&nbsp;COL=/usr/bin/column
 34&nbsp;BZ2=/usr/bin/bzip2
 35&nbsp;
 36&nbsp;# Are we root?
 37&nbsp;USER=`$ID -u`
 38&nbsp;if [ "X$USER" != "X0" ]; then
 39&nbsp;  echo "PANIC: Only root can run this script!"
 40&nbsp;  exit $PROBLEM
 41&nbsp;fi
 42&nbsp;
 43&nbsp;# Backup dir exists/writable?
 44&nbsp;if [ ! -x $BKP_DIR ]; then
 45&nbsp;  echo "PANIC: $BKP_DIR doesn't exist or isn't writable!"
 46&nbsp;  exit $PROBLEM
 47&nbsp;fi
 48&nbsp;
 49&nbsp;# Move, rename and bzip2 the logs
 50&nbsp;for logday in $LOG_DAYS; do
 51&nbsp;  for logfile in $LOG_FILES; do
 52&nbsp;    MYFILE="$LOG_DIR/$logfile.$logday"
 53&nbsp;    if [ -w $MYFILE ]; then
 54&nbsp;      DTS=`$LS -lgo --time-style=+%Y%m%d $MYFILE | $COL -t | $CUT -d ' ' -f7`
 55&nbsp;      $MV $MYFILE $BKP_DIR/$logfile.$DTS
 56&nbsp;      $BZ2 $BKP_DIR/$logfile.$DTS
 57&nbsp;    else
 58&nbsp;      # Only spew an error if the file exits (ergo non-writable).
 59&nbsp;      if [ -f $MYFILE ]; then
 60&nbsp;        echo "ERROR: $MYFILE not writable. Skipping."
 61&nbsp;      fi
 62&nbsp;    fi
 63&nbsp;  done
 64&nbsp;done
 65&nbsp;
 66&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>你怎么做才能阻止shell扩展或者重新解释字符串? 
      </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="PROTECTLITERAL"
></A
><P
><B
>例子 A-26. 保护字符串的字面含义</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#! /bin/bash
  2&nbsp;# protect_literal.sh
  3&nbsp;
  4&nbsp;# set -vx
  5&nbsp;
  6&nbsp;:&#60;&#60;-'_Protect_Literal_String_Doc'
  7&nbsp;
  8&nbsp;    Copyright (c) Michael S. Zick, 2003; All Rights Reserved
  9&nbsp;    License: Unrestricted reuse in any form, for any purpose.
 10&nbsp;    Warranty: None
 11&nbsp;    Revision: $ID$
 12&nbsp;
 13&nbsp;    Documentation redirected to the Bash no-operation.
 14&nbsp;    Bash will '/dev/null' this block when the script is first read.
 15&nbsp;    (Uncomment the above set command to see this action.)
 16&nbsp;
 17&nbsp;    Remove the first (Sha-Bang) line when sourcing this as a library
 18&nbsp;    procedure.  Also comment out the example use code in the two
 19&nbsp;    places where shown.
 20&nbsp;
 21&nbsp;
 22&nbsp;    Usage:
 23&nbsp;        _protect_literal_str 'Whatever string meets your ${fancy}'
 24&nbsp;        Just echos the argument to standard out, hard quotes
 25&nbsp;        restored.
 26&nbsp;
 27&nbsp;        $(_protect_literal_str 'Whatever string meets your ${fancy}')
 28&nbsp;        as the right-hand-side of an assignment statement.
 29&nbsp;
 30&nbsp;    Does:
 31&nbsp;        As the right-hand-side of an assignment, preserves the
 32&nbsp;        hard quotes protecting the contents of the literal during
 33&nbsp;        assignment.
 34&nbsp;
 35&nbsp;    Notes:
 36&nbsp;        The strange names (_*) are used to avoid trampling on
 37&nbsp;        the user's chosen names when this is sourced as a
 38&nbsp;        library.
 39&nbsp;
 40&nbsp;_Protect_Literal_String_Doc
 41&nbsp;
 42&nbsp;# The 'for illustration' function form
 43&nbsp;
 44&nbsp;_protect_literal_str() {
 45&nbsp;
 46&nbsp;# Pick an un-used, non-printing character as local IFS.
 47&nbsp;# Not required, but shows that we are ignoring it.
 48&nbsp;    local IFS=$'\x1B'               # \ESC character
 49&nbsp;
 50&nbsp;# Enclose the All-Elements-Of in hard quotes during assignment.
 51&nbsp;    local tmp=$'\x27'$@$'\x27'
 52&nbsp;#    local tmp=$'\''$@$'\''         # Even uglier.
 53&nbsp;
 54&nbsp;    local len=${#tmp}               # Info only.
 55&nbsp;    echo $tmp is $len long.         # Output AND information.
 56&nbsp;}
 57&nbsp;
 58&nbsp;# This is the short-named version.
 59&nbsp;_pls() {
 60&nbsp;    local IFS=$'x1B'                # \ESC character (not required)
 61&nbsp;    echo $'\x27'$@$'\x27'           # Hard quoted parameter glob
 62&nbsp;}
 63&nbsp;
 64&nbsp;# :&#60;&#60;-'_Protect_Literal_String_Test'
 65&nbsp;# # # Remove the above "# " to disable this code. # # #
 66&nbsp;
 67&nbsp;# See how that looks when printed.
 68&nbsp;echo
 69&nbsp;echo "- - Test One - -"
 70&nbsp;_protect_literal_str 'Hello $user'
 71&nbsp;_protect_literal_str 'Hello "${username}"'
 72&nbsp;echo
 73&nbsp;
 74&nbsp;# Which yields:
 75&nbsp;# - - Test One - -
 76&nbsp;# 'Hello $user' is 13 long.
 77&nbsp;# 'Hello "${username}"' is 21 long.
 78&nbsp;
 79&nbsp;#  Looks as expected, but why all of the trouble?
 80&nbsp;#  The difference is hidden inside the Bash internal order
 81&nbsp;#+ of operations.
 82&nbsp;#  Which shows when you use it on the RHS of an assignment.
 83&nbsp;
 84&nbsp;# Declare an array for test values.
 85&nbsp;declare -a arrayZ
 86&nbsp;
 87&nbsp;# Assign elements with various types of quotes and escapes.
 88&nbsp;arrayZ=( zero "$(_pls 'Hello ${Me}')" 'Hello ${You}' "\'Pass: ${pw}\'" )
 89&nbsp;
 90&nbsp;# Now list that array and see what is there.
 91&nbsp;echo "- - Test Two - -"
 92&nbsp;for (( i=0 ; i&#60;${#arrayZ[*]} ; i++ ))
 93&nbsp;do
 94&nbsp;    echo  Element $i: ${arrayZ[$i]} is: ${#arrayZ[$i]} long.
 95&nbsp;done
 96&nbsp;echo
 97&nbsp;
 98&nbsp;# Which yields:
 99&nbsp;# - - Test Two - -
100&nbsp;# Element 0: zero is: 4 long.           # Our marker element
101&nbsp;# Element 1: 'Hello ${Me}' is: 13 long. # Our "$(_pls '...' )"
102&nbsp;# Element 2: Hello ${You} is: 12 long.  # Quotes are missing
103&nbsp;# Element 3: \'Pass: \' is: 10 long.    # ${pw} expanded to nothing
104&nbsp;
105&nbsp;# Now make an assignment with that result.
106&nbsp;declare -a array2=( ${arrayZ[@]} )
107&nbsp;
108&nbsp;# And print what happened.
109&nbsp;echo "- - Test Three - -"
110&nbsp;for (( i=0 ; i&#60;${#array2[*]} ; i++ ))
111&nbsp;do
112&nbsp;    echo  Element $i: ${array2[$i]} is: ${#array2[$i]} long.
113&nbsp;done
114&nbsp;echo
115&nbsp;
116&nbsp;# Which yields:
117&nbsp;# - - Test Three - -
118&nbsp;# Element 0: zero is: 4 long.           # Our marker element.
119&nbsp;# Element 1: Hello ${Me} is: 11 long.   # Intended result.
120&nbsp;# Element 2: Hello is: 5 long.          # ${You} expanded to nothing.
121&nbsp;# Element 3: 'Pass: is: 6 long.         # Split on the whitespace.
122&nbsp;# Element 4: ' is: 1 long.              # The end quote is here now.
123&nbsp;
124&nbsp;#  Our Element 1 has had its leading and trailing hard quotes stripped.
125&nbsp;#  Although not shown, leading and trailing whitespace is also stripped.
126&nbsp;#  Now that the string contents are set, Bash will always, internally,
127&nbsp;#+ hard quote the contents as required during its operations.
128&nbsp;
129&nbsp;#  Why?
130&nbsp;#  Considering our "$(_pls 'Hello ${Me}')" construction:
131&nbsp;#  " ... " -&#62; Expansion required, strip the quotes.
132&nbsp;#  $( ... ) -&#62; Replace with the result of..., strip this.
133&nbsp;#  _pls ' ... ' -&#62; called with literal arguments, strip the quotes.
134&nbsp;#  The result returned includes hard quotes; BUT the above processing
135&nbsp;#+ has already been done, so they become part of the value assigned.
136&nbsp;#
137&nbsp;#  Similarly, during further usage of the string variable, the ${Me}
138&nbsp;#+ is part of the contents (result) and survives any operations
139&nbsp;#  (Until explicitly told to evaluate the string).
140&nbsp;
141&nbsp;#  Hint: See what happens when the hard quotes ($'\x27') are replaced
142&nbsp;#+ with soft quotes ($'\x22') in the above procedures.
143&nbsp;#  Interesting also is to remove the addition of any quoting.
144&nbsp;
145&nbsp;# _Protect_Literal_String_Test
146&nbsp;# # # Remove the above "# " to disable this code. # # #
147&nbsp;
148&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>如果你<EM
>确实想让</EM
>shell扩展或者重新解释字符串的话, 该怎么办? </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="UNPROTECTLITERAL"
></A
><P
><B
>例子 A-27. 不保护字符串的字面含义</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#! /bin/bash
  2&nbsp;# unprotect_literal.sh
  3&nbsp;
  4&nbsp;# set -vx
  5&nbsp;
  6&nbsp;:&#60;&#60;-'_UnProtect_Literal_String_Doc'
  7&nbsp;
  8&nbsp;    Copyright (c) Michael S. Zick, 2003; All Rights Reserved
  9&nbsp;    License: Unrestricted reuse in any form, for any purpose.
 10&nbsp;    Warranty: None
 11&nbsp;    Revision: $ID$
 12&nbsp;
 13&nbsp;    Documentation redirected to the Bash no-operation. Bash will
 14&nbsp;    '/dev/null' this block when the script is first read.
 15&nbsp;    (Uncomment the above set command to see this action.)
 16&nbsp;
 17&nbsp;    Remove the first (Sha-Bang) line when sourcing this as a library
 18&nbsp;    procedure.  Also comment out the example use code in the two
 19&nbsp;    places where shown.
 20&nbsp;
 21&nbsp;
 22&nbsp;    Usage:
 23&nbsp;        Complement of the "$(_pls 'Literal String')" function.
 24&nbsp;        (See the protect_literal.sh example.)
 25&nbsp;
 26&nbsp;        StringVar=$(_upls ProtectedSringVariable)
 27&nbsp;
 28&nbsp;    Does:
 29&nbsp;        When used on the right-hand-side of an assignment statement;
 30&nbsp;        makes the substitions embedded in the protected string.
 31&nbsp;
 32&nbsp;    Notes:
 33&nbsp;        The strange names (_*) are used to avoid trampling on
 34&nbsp;        the user's chosen names when this is sourced as a
 35&nbsp;        library.
 36&nbsp;
 37&nbsp;
 38&nbsp;_UnProtect_Literal_String_Doc
 39&nbsp;
 40&nbsp;_upls() {
 41&nbsp;    local IFS=$'x1B'                # \ESC character (not required)
 42&nbsp;    eval echo $@                    # Substitution on the glob.
 43&nbsp;}
 44&nbsp;
 45&nbsp;# :&#60;&#60;-'_UnProtect_Literal_String_Test'
 46&nbsp;# # # Remove the above "# " to disable this code. # # #
 47&nbsp;
 48&nbsp;
 49&nbsp;_pls() {
 50&nbsp;    local IFS=$'x1B'                # \ESC character (not required)
 51&nbsp;    echo $'\x27'$@$'\x27'           # Hard quoted parameter glob
 52&nbsp;}
 53&nbsp;
 54&nbsp;# Declare an array for test values.
 55&nbsp;declare -a arrayZ
 56&nbsp;
 57&nbsp;# Assign elements with various types of quotes and escapes.
 58&nbsp;arrayZ=( zero "$(_pls 'Hello ${Me}')" 'Hello ${You}' "\'Pass: ${pw}\'" )
 59&nbsp;
 60&nbsp;# Now make an assignment with that result.
 61&nbsp;declare -a array2=( ${arrayZ[@]} )
 62&nbsp;
 63&nbsp;# Which yielded:
 64&nbsp;# - - Test Three - -
 65&nbsp;# Element 0: zero is: 4 long            # Our marker element.
 66&nbsp;# Element 1: Hello ${Me} is: 11 long    # Intended result.
 67&nbsp;# Element 2: Hello is: 5 long           # ${You} expanded to nothing.
 68&nbsp;# Element 3: 'Pass: is: 6 long          # Split on the whitespace.
 69&nbsp;# Element 4: ' is: 1 long               # The end quote is here now.
 70&nbsp;
 71&nbsp;# set -vx
 72&nbsp;
 73&nbsp;#  Initialize 'Me' to something for the embedded ${Me} substitution.
 74&nbsp;#  This needs to be done ONLY just prior to evaluating the
 75&nbsp;#+ protected string.
 76&nbsp;#  (This is why it was protected to begin with.)
 77&nbsp;
 78&nbsp;Me="to the array guy."
 79&nbsp;
 80&nbsp;# Set a string variable destination to the result.
 81&nbsp;newVar=$(_upls ${array2[1]})
 82&nbsp;
 83&nbsp;# Show what the contents are.
 84&nbsp;echo $newVar
 85&nbsp;
 86&nbsp;# Do we really need a function to do this?
 87&nbsp;newerVar=$(eval echo ${array2[1]})
 88&nbsp;echo $newerVar
 89&nbsp;
 90&nbsp;#  I guess not, but the _upls function gives us a place to hang
 91&nbsp;#+ the documentation on.
 92&nbsp;#  This helps when we forget what a # construction like:
 93&nbsp;#+ $(eval echo ... ) means.
 94&nbsp;
 95&nbsp;# What if Me isn't set when the protected string is evaluated?
 96&nbsp;unset Me
 97&nbsp;newestVar=$(_upls ${array2[1]})
 98&nbsp;echo $newestVar
 99&nbsp;
100&nbsp;# Just gone, no hints, no runs, no errors.
101&nbsp;
102&nbsp;#  Why in the world?
103&nbsp;#  Setting the contents of a string variable containing character
104&nbsp;#+ sequences that have a meaning in Bash is a general problem in
105&nbsp;#+ script programming.
106&nbsp;#
107&nbsp;#  This problem is now solved in eight lines of code
108&nbsp;#+ (and four pages of description).
109&nbsp;
110&nbsp;#  Where is all this going?
111&nbsp;#  Dynamic content Web pages as an array of Bash strings.
112&nbsp;#  Content set per request by a Bash 'eval' command
113&nbsp;#+ on the stored page template.
114&nbsp;#  Not intended to replace PHP, just an interesting thing to do.
115&nbsp;###
116&nbsp;#  Don't have a webserver application?
117&nbsp;#  No problem, check the example directory of the Bash source;
118&nbsp;#+ there is a Bash script for that also.
119&nbsp;
120&nbsp;# _UnProtect_Literal_String_Test
121&nbsp;# # # Remove the above "# " to disable this code. # # #
122&nbsp;
123&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>这个强大的脚本帮助我们抓住垃圾邮件服务器. </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ISSPAMMER2"
></A
><P
><B
>例子 A-28. 鉴定是否是垃圾邮件服务器</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# $Id: is_spammer.bash,v 1.12.2.11 2004/10/01 21:42:33 mszick Exp $
   4&nbsp;# Above line is RCS info.
   5&nbsp;
   6&nbsp;# The latest version of this script is available from http://www.morethan.org.
   7&nbsp;#
   8&nbsp;# Spammer-identification
   9&nbsp;# by Michael S. Zick
  10&nbsp;# Used in the ABS Guide with permission.
  11&nbsp;
  12&nbsp;
  13&nbsp;
  14&nbsp;#######################################################
  15&nbsp;# Documentation
  16&nbsp;# See also "Quickstart" at end of script.
  17&nbsp;#######################################################
  18&nbsp;
  19&nbsp;:&#60;&#60;-'__is_spammer_Doc_'
  20&nbsp;
  21&nbsp;    Copyright (c) Michael S. Zick, 2004
  22&nbsp;    License: Unrestricted reuse in any form, for any purpose.
  23&nbsp;    Warranty: None -{Its a script; the user is on their own.}-
  24&nbsp;
  25&nbsp;Impatient?
  26&nbsp;    Application code: goto "# # # Hunt the Spammer' program code # # #"
  27&nbsp;    Example output: ":&#60;&#60;-'_is_spammer_outputs_'"
  28&nbsp;    How to use: Enter script name without arguments.
  29&nbsp;                Or goto "Quickstart" at end of script.
  30&nbsp;
  31&nbsp;Provides
  32&nbsp;    Given a domain name or IP(v4) address as input:
  33&nbsp;
  34&nbsp;    Does an exhaustive set of queries to find the associated
  35&nbsp;    network resources (short of recursing into TLDs).
  36&nbsp;
  37&nbsp;    Checks the IP(v4) addresses found against Blacklist
  38&nbsp;    nameservers.
  39&nbsp;
  40&nbsp;    If found to be a blacklisted IP(v4) address,
  41&nbsp;    reports the blacklist text records.
  42&nbsp;    (Usually hyper-links to the specific report.)
  43&nbsp;
  44&nbsp;Requires
  45&nbsp;    A working Internet connection.
  46&nbsp;    (Exercise: Add check and/or abort if not on-line when running script.)
  47&nbsp;    Bash with arrays (2.05b+).
  48&nbsp;
  49&nbsp;    The external program 'dig' --
  50&nbsp;    a utility program provided with the 'bind' set of programs.
  51&nbsp;    Specifically, the version which is part of Bind series 9.x
  52&nbsp;    See: http://www.isc.org
  53&nbsp;
  54&nbsp;    All usages of 'dig' are limited to wrapper functions,
  55&nbsp;    which may be rewritten as required.
  56&nbsp;    See: dig_wrappers.bash for details.
  57&nbsp;         ("Additional documentation" -- below)
  58&nbsp;
  59&nbsp;Usage
  60&nbsp;    Script requires a single argument, which may be:
  61&nbsp;    1) A domain name;
  62&nbsp;    2) An IP(v4) address;
  63&nbsp;    3) A filename, with one name or address per line.
  64&nbsp;
  65&nbsp;    Script accepts an optional second argument, which may be:
  66&nbsp;    1) A Blacklist server name;
  67&nbsp;    2) A filename, with one Blacklist server name per line.
  68&nbsp;
  69&nbsp;    If the second argument is not provided, the script uses
  70&nbsp;    a built-in set of (free) Blacklist servers.
  71&nbsp;
  72&nbsp;    See also, the Quickstart at the end of this script (after 'exit').
  73&nbsp;
  74&nbsp;Return Codes
  75&nbsp;    0 - All OK
  76&nbsp;    1 - Script failure
  77&nbsp;    2 - Something is Blacklisted
  78&nbsp;
  79&nbsp;Optional environment variables
  80&nbsp;    SPAMMER_TRACE
  81&nbsp;        If set to a writable file,
  82&nbsp;        script will log an execution flow trace.
  83&nbsp;
  84&nbsp;    SPAMMER_DATA
  85&nbsp;        If set to a writable file, script will dump its
  86&nbsp;        discovered data in the form of GraphViz file.
  87&nbsp;        See: http://www.research.att.com/sw/tools/graphviz
  88&nbsp;
  89&nbsp;    SPAMMER_LIMIT
  90&nbsp;        Limits the depth of resource tracing.
  91&nbsp;
  92&nbsp;        Default is 2 levels.
  93&nbsp;
  94&nbsp;        A setting of 0 (zero) means 'unlimited' . . .
  95&nbsp;          Caution: script might recurse the whole Internet!
  96&nbsp;
  97&nbsp;        A limit of 1 or 2 is most useful when processing
  98&nbsp;        a file of domain names and addresses.
  99&nbsp;        A higher limit can be useful when hunting spam gangs.
 100&nbsp;
 101&nbsp;
 102&nbsp;Additional documentation
 103&nbsp;    Download the archived set of scripts
 104&nbsp;    explaining and illustrating the function contained within this script.
 105&nbsp;    http://personal.riverusers.com/mszick_clf.tar.bz2
 106&nbsp;
 107&nbsp;
 108&nbsp;Study notes
 109&nbsp;    This script uses a large number of functions.
 110&nbsp;    Nearly all general functions have their own example script.
 111&nbsp;    Each of the example scripts have tutorial level comments.
 112&nbsp;
 113&nbsp;Scripting project
 114&nbsp;    Add support for IP(v6) addresses.
 115&nbsp;    IP(v6) addresses are recognized but not processed.
 116&nbsp;
 117&nbsp;Advanced project
 118&nbsp;    Add the reverse lookup detail to the discovered information.
 119&nbsp;
 120&nbsp;    Report the delegation chain and abuse contacts.
 121&nbsp;
 122&nbsp;    Modify the GraphViz file output to include the
 123&nbsp;    newly discovered information.
 124&nbsp;
 125&nbsp;__is_spammer_Doc_
 126&nbsp;
 127&nbsp;#######################################################
 128&nbsp;
 129&nbsp;
 130&nbsp;
 131&nbsp;
 132&nbsp;#### Special IFS settings used for string parsing. ####
 133&nbsp;
 134&nbsp;# Whitespace == :Space:Tab:Line Feed:Carriage Return:
 135&nbsp;WSP_IFS=$'\x20'$'\x09'$'\x0A'$'\x0D'
 136&nbsp;
 137&nbsp;# No Whitespace == Line Feed:Carriage Return
 138&nbsp;NO_WSP=$'\x0A'$'\x0D'
 139&nbsp;
 140&nbsp;# Field separator for dotted decimal IP addresses
 141&nbsp;ADR_IFS=${NO_WSP}'.'
 142&nbsp;
 143&nbsp;# Array to dotted string conversions
 144&nbsp;DOT_IFS='.'${WSP_IFS}
 145&nbsp;
 146&nbsp;# # # Pending operations stack machine # # #
 147&nbsp;# This set of functions described in func_stack.bash.
 148&nbsp;# (See "Additional documentation" above.)
 149&nbsp;# # #
 150&nbsp;
 151&nbsp;# Global stack of pending operations.
 152&nbsp;declare -f -a _pending_
 153&nbsp;# Global sentinel for stack runners
 154&nbsp;declare -i _p_ctrl_
 155&nbsp;# Global holder for currently executing function
 156&nbsp;declare -f _pend_current_
 157&nbsp;
 158&nbsp;# # # Debug version only - remove for regular use # # #
 159&nbsp;#
 160&nbsp;# The function stored in _pend_hook_ is called
 161&nbsp;# immediately before each pending function is
 162&nbsp;# evaluated.  Stack clean, _pend_current_ set.
 163&nbsp;#
 164&nbsp;# This thingy demonstrated in pend_hook.bash.
 165&nbsp;declare -f _pend_hook_
 166&nbsp;# # #
 167&nbsp;
 168&nbsp;# The do nothing function
 169&nbsp;pend_dummy() { : ; }
 170&nbsp;
 171&nbsp;# Clear and initialize the function stack.
 172&nbsp;pend_init() {
 173&nbsp;    unset _pending_[@]
 174&nbsp;    pend_func pend_stop_mark
 175&nbsp;    _pend_hook_='pend_dummy'  # Debug only.
 176&nbsp;}
 177&nbsp;
 178&nbsp;# Discard the top function on the stack.
 179&nbsp;pend_pop() {
 180&nbsp;    if [ ${#_pending_[@]} -gt 0 ]
 181&nbsp;    then
 182&nbsp;        local -i _top_
 183&nbsp;        _top_=${#_pending_[@]}-1
 184&nbsp;        unset _pending_[$_top_]
 185&nbsp;    fi
 186&nbsp;}
 187&nbsp;
 188&nbsp;# pend_func function_name [$(printf '%q\n' arguments)]
 189&nbsp;pend_func() {
 190&nbsp;    local IFS=${NO_WSP}
 191&nbsp;    set -f
 192&nbsp;    _pending_[${#_pending_[@]}]=$@
 193&nbsp;    set +f
 194&nbsp;}
 195&nbsp;
 196&nbsp;# The function which stops the release:
 197&nbsp;pend_stop_mark() {
 198&nbsp;    _p_ctrl_=0
 199&nbsp;}
 200&nbsp;
 201&nbsp;pend_mark() {
 202&nbsp;    pend_func pend_stop_mark
 203&nbsp;}
 204&nbsp;
 205&nbsp;# Execute functions until 'pend_stop_mark' . . .
 206&nbsp;pend_release() {
 207&nbsp;    local -i _top_             # Declare _top_ as integer.
 208&nbsp;    _p_ctrl_=${#_pending_[@]}
 209&nbsp;    while [ ${_p_ctrl_} -gt 0 ]
 210&nbsp;    do
 211&nbsp;       _top_=${#_pending_[@]}-1
 212&nbsp;       _pend_current_=${_pending_[$_top_]}
 213&nbsp;       unset _pending_[$_top_]
 214&nbsp;       $_pend_hook_            # Debug only.
 215&nbsp;       eval $_pend_current_
 216&nbsp;    done
 217&nbsp;}
 218&nbsp;
 219&nbsp;# Drop functions until 'pend_stop_mark' . . .
 220&nbsp;pend_drop() {
 221&nbsp;    local -i _top_
 222&nbsp;    local _pd_ctrl_=${#_pending_[@]}
 223&nbsp;    while [ ${_pd_ctrl_} -gt 0 ]
 224&nbsp;    do
 225&nbsp;       _top_=$_pd_ctrl_-1
 226&nbsp;       if [ "${_pending_[$_top_]}" == 'pend_stop_mark' ]
 227&nbsp;       then
 228&nbsp;           unset _pending_[$_top_]
 229&nbsp;           break
 230&nbsp;       else
 231&nbsp;           unset _pending_[$_top_]
 232&nbsp;           _pd_ctrl_=$_top_
 233&nbsp;       fi
 234&nbsp;    done
 235&nbsp;    if [ ${#_pending_[@]} -eq 0 ]
 236&nbsp;    then
 237&nbsp;        pend_func pend_stop_mark
 238&nbsp;    fi
 239&nbsp;}
 240&nbsp;
 241&nbsp;#### Array editors ####
 242&nbsp;
 243&nbsp;# This function described in edit_exact.bash.
 244&nbsp;# (See "Additional documentation," above.)
 245&nbsp;# edit_exact &#60;excludes_array_name&#62; &#60;target_array_name&#62;
 246&nbsp;edit_exact() {
 247&nbsp;    [ $# -eq 2 ] ||
 248&nbsp;    [ $# -eq 3 ] || return 1
 249&nbsp;    local -a _ee_Excludes
 250&nbsp;    local -a _ee_Target
 251&nbsp;    local _ee_x
 252&nbsp;    local _ee_t
 253&nbsp;    local IFS=${NO_WSP}
 254&nbsp;    set -f
 255&nbsp;    eval _ee_Excludes=\( \$\{$1\[@\]\} \)
 256&nbsp;    eval _ee_Target=\( \$\{$2\[@\]\} \)
 257&nbsp;    local _ee_len=${#_ee_Target[@]}     # Original length.
 258&nbsp;    local _ee_cnt=${#_ee_Excludes[@]}   # Exclude list length.
 259&nbsp;    [ ${_ee_len} -ne 0 ] || return 0    # Can't edit zero length.
 260&nbsp;    [ ${_ee_cnt} -ne 0 ] || return 0    # Can't edit zero length.
 261&nbsp;    for (( x = 0; x &#60; ${_ee_cnt} ; x++ ))
 262&nbsp;    do
 263&nbsp;        _ee_x=${_ee_Excludes[$x]}
 264&nbsp;        for (( n = 0 ; n &#60; ${_ee_len} ; n++ ))
 265&nbsp;        do
 266&nbsp;            _ee_t=${_ee_Target[$n]}
 267&nbsp;            if [ x"${_ee_t}" == x"${_ee_x}" ]
 268&nbsp;            then
 269&nbsp;                unset _ee_Target[$n]     # Discard match.
 270&nbsp;                [ $# -eq 2 ] &#38;&#38; break    # If 2 arguments, then done.
 271&nbsp;            fi
 272&nbsp;        done
 273&nbsp;    done
 274&nbsp;    eval $2=\( \$\{_ee_Target\[@\]\} \)
 275&nbsp;    set +f
 276&nbsp;    return 0
 277&nbsp;}
 278&nbsp;
 279&nbsp;# This function described in edit_by_glob.bash.
 280&nbsp;# edit_by_glob &#60;excludes_array_name&#62; &#60;target_array_name&#62;
 281&nbsp;edit_by_glob() {
 282&nbsp;    [ $# -eq 2 ] ||
 283&nbsp;    [ $# -eq 3 ] || return 1
 284&nbsp;    local -a _ebg_Excludes
 285&nbsp;    local -a _ebg_Target
 286&nbsp;    local _ebg_x
 287&nbsp;    local _ebg_t
 288&nbsp;    local IFS=${NO_WSP}
 289&nbsp;    set -f
 290&nbsp;    eval _ebg_Excludes=\( \$\{$1\[@\]\} \)
 291&nbsp;    eval _ebg_Target=\( \$\{$2\[@\]\} \)
 292&nbsp;    local _ebg_len=${#_ebg_Target[@]}
 293&nbsp;    local _ebg_cnt=${#_ebg_Excludes[@]}
 294&nbsp;    [ ${_ebg_len} -ne 0 ] || return 0
 295&nbsp;    [ ${_ebg_cnt} -ne 0 ] || return 0
 296&nbsp;    for (( x = 0; x &#60; ${_ebg_cnt} ; x++ ))
 297&nbsp;    do
 298&nbsp;        _ebg_x=${_ebg_Excludes[$x]}
 299&nbsp;        for (( n = 0 ; n &#60; ${_ebg_len} ; n++ ))
 300&nbsp;        do
 301&nbsp;            [ $# -eq 3 ] &#38;&#38; _ebg_x=${_ebg_x}'*'  #  Do prefix edit
 302&nbsp;            if [ ${_ebg_Target[$n]:=} ]          #+ if defined &#38; set.
 303&nbsp;            then
 304&nbsp;                _ebg_t=${_ebg_Target[$n]/#${_ebg_x}/}
 305&nbsp;                [ ${#_ebg_t} -eq 0 ] &#38;&#38; unset _ebg_Target[$n]
 306&nbsp;            fi
 307&nbsp;        done
 308&nbsp;    done
 309&nbsp;    eval $2=\( \$\{_ebg_Target\[@\]\} \)
 310&nbsp;    set +f
 311&nbsp;    return 0
 312&nbsp;}
 313&nbsp;
 314&nbsp;# This function described in unique_lines.bash.
 315&nbsp;# unique_lines &#60;in_name&#62; &#60;out_name&#62;
 316&nbsp;unique_lines() {
 317&nbsp;    [ $# -eq 2 ] || return 1
 318&nbsp;    local -a _ul_in
 319&nbsp;    local -a _ul_out
 320&nbsp;    local -i _ul_cnt
 321&nbsp;    local -i _ul_pos
 322&nbsp;    local _ul_tmp
 323&nbsp;    local IFS=${NO_WSP}
 324&nbsp;    set -f
 325&nbsp;    eval _ul_in=\( \$\{$1\[@\]\} \)
 326&nbsp;    _ul_cnt=${#_ul_in[@]}
 327&nbsp;    for (( _ul_pos = 0 ; _ul_pos &#60; ${_ul_cnt} ; _ul_pos++ ))
 328&nbsp;    do
 329&nbsp;        if [ ${_ul_in[${_ul_pos}]:=} ]      # If defined &#38; not empty
 330&nbsp;        then
 331&nbsp;            _ul_tmp=${_ul_in[${_ul_pos}]}
 332&nbsp;            _ul_out[${#_ul_out[@]}]=${_ul_tmp}
 333&nbsp;            for (( zap = _ul_pos ; zap &#60; ${_ul_cnt} ; zap++ ))
 334&nbsp;            do
 335&nbsp;                [ ${_ul_in[${zap}]:=} ] &#38;&#38;
 336&nbsp;                [ 'x'${_ul_in[${zap}]} == 'x'${_ul_tmp} ] &#38;&#38;
 337&nbsp;                    unset _ul_in[${zap}]
 338&nbsp;            done
 339&nbsp;        fi
 340&nbsp;    done
 341&nbsp;    eval $2=\( \$\{_ul_out\[@\]\} \)
 342&nbsp;    set +f
 343&nbsp;    return 0
 344&nbsp;}
 345&nbsp;
 346&nbsp;# This function described in char_convert.bash.
 347&nbsp;# to_lower &#60;string&#62;
 348&nbsp;to_lower() {
 349&nbsp;    [ $# -eq 1 ] || return 1
 350&nbsp;    local _tl_out
 351&nbsp;    _tl_out=${1//A/a}
 352&nbsp;    _tl_out=${_tl_out//B/b}
 353&nbsp;    _tl_out=${_tl_out//C/c}
 354&nbsp;    _tl_out=${_tl_out//D/d}
 355&nbsp;    _tl_out=${_tl_out//E/e}
 356&nbsp;    _tl_out=${_tl_out//F/f}
 357&nbsp;    _tl_out=${_tl_out//G/g}
 358&nbsp;    _tl_out=${_tl_out//H/h}
 359&nbsp;    _tl_out=${_tl_out//I/i}
 360&nbsp;    _tl_out=${_tl_out//J/j}
 361&nbsp;    _tl_out=${_tl_out//K/k}
 362&nbsp;    _tl_out=${_tl_out//L/l}
 363&nbsp;    _tl_out=${_tl_out//M/m}
 364&nbsp;    _tl_out=${_tl_out//N/n}
 365&nbsp;    _tl_out=${_tl_out//O/o}
 366&nbsp;    _tl_out=${_tl_out//P/p}
 367&nbsp;    _tl_out=${_tl_out//Q/q}
 368&nbsp;    _tl_out=${_tl_out//R/r}
 369&nbsp;    _tl_out=${_tl_out//S/s}
 370&nbsp;    _tl_out=${_tl_out//T/t}
 371&nbsp;    _tl_out=${_tl_out//U/u}
 372&nbsp;    _tl_out=${_tl_out//V/v}
 373&nbsp;    _tl_out=${_tl_out//W/w}
 374&nbsp;    _tl_out=${_tl_out//X/x}
 375&nbsp;    _tl_out=${_tl_out//Y/y}
 376&nbsp;    _tl_out=${_tl_out//Z/z}
 377&nbsp;    echo ${_tl_out}
 378&nbsp;    return 0
 379&nbsp;}
 380&nbsp;
 381&nbsp;#### Application helper functions ####
 382&nbsp;
 383&nbsp;# Not everybody uses dots as separators (APNIC, for example).
 384&nbsp;# This function described in to_dot.bash
 385&nbsp;# to_dot &#60;string&#62;
 386&nbsp;to_dot() {
 387&nbsp;    [ $# -eq 1 ] || return 1
 388&nbsp;    echo ${1//[#|@|%]/.}
 389&nbsp;    return 0
 390&nbsp;}
 391&nbsp;
 392&nbsp;# This function described in is_number.bash.
 393&nbsp;# is_number &#60;input&#62;
 394&nbsp;is_number() {
 395&nbsp;    [ "$#" -eq 1 ]    || return 1  # is blank?
 396&nbsp;    [ x"$1" == 'x0' ] &#38;&#38; return 0  # is zero?
 397&nbsp;    local -i tst
 398&nbsp;    let tst=$1 2&#62;/dev/null         # else is numeric!
 399&nbsp;    return $?
 400&nbsp;}
 401&nbsp;
 402&nbsp;# This function described in is_address.bash.
 403&nbsp;# is_address &#60;input&#62;
 404&nbsp;is_address() {
 405&nbsp;    [ $# -eq 1 ] || return 1    # Blank ==&#62; false
 406&nbsp;    local -a _ia_input
 407&nbsp;    local IFS=${ADR_IFS}
 408&nbsp;    _ia_input=( $1 )
 409&nbsp;    if  [ ${#_ia_input[@]} -eq 4 ]  &#38;&#38;
 410&nbsp;        is_number ${_ia_input[0]}   &#38;&#38;
 411&nbsp;        is_number ${_ia_input[1]}   &#38;&#38;
 412&nbsp;        is_number ${_ia_input[2]}   &#38;&#38;
 413&nbsp;        is_number ${_ia_input[3]}   &#38;&#38;
 414&nbsp;        [ ${_ia_input[0]} -lt 256 ] &#38;&#38;
 415&nbsp;        [ ${_ia_input[1]} -lt 256 ] &#38;&#38;
 416&nbsp;        [ ${_ia_input[2]} -lt 256 ] &#38;&#38;
 417&nbsp;        [ ${_ia_input[3]} -lt 256 ]
 418&nbsp;    then
 419&nbsp;        return 0
 420&nbsp;    else
 421&nbsp;        return 1
 422&nbsp;    fi
 423&nbsp;}
 424&nbsp;
 425&nbsp;# This function described in split_ip.bash.
 426&nbsp;# split_ip &#60;IP_address&#62; &#60;array_name_norm&#62; [&#60;array_name_rev&#62;]
 427&nbsp;split_ip() {
 428&nbsp;    [ $# -eq 3 ] ||              #  Either three
 429&nbsp;    [ $# -eq 2 ] || return 1     #+ or two arguments
 430&nbsp;    local -a _si_input
 431&nbsp;    local IFS=${ADR_IFS}
 432&nbsp;    _si_input=( $1 )
 433&nbsp;    IFS=${WSP_IFS}
 434&nbsp;    eval $2=\(\ \$\{_si_input\[@\]\}\ \)
 435&nbsp;    if [ $# -eq 3 ]
 436&nbsp;    then
 437&nbsp;        # Build query order array.
 438&nbsp;        local -a _dns_ip
 439&nbsp;        _dns_ip[0]=${_si_input[3]}
 440&nbsp;        _dns_ip[1]=${_si_input[2]}
 441&nbsp;        _dns_ip[2]=${_si_input[1]}
 442&nbsp;        _dns_ip[3]=${_si_input[0]}
 443&nbsp;        eval $3=\(\ \$\{_dns_ip\[@\]\}\ \)
 444&nbsp;    fi
 445&nbsp;    return 0
 446&nbsp;}
 447&nbsp;
 448&nbsp;# This function described in dot_array.bash.
 449&nbsp;# dot_array &#60;array_name&#62;
 450&nbsp;dot_array() {
 451&nbsp;    [ $# -eq 1 ] || return 1     # Single argument required.
 452&nbsp;    local -a _da_input
 453&nbsp;    eval _da_input=\(\ \$\{$1\[@\]\}\ \)
 454&nbsp;    local IFS=${DOT_IFS}
 455&nbsp;    local _da_output=${_da_input[@]}
 456&nbsp;    IFS=${WSP_IFS}
 457&nbsp;    echo ${_da_output}
 458&nbsp;    return 0
 459&nbsp;}
 460&nbsp;
 461&nbsp;# This function described in file_to_array.bash
 462&nbsp;# file_to_array &#60;file_name&#62; &#60;line_array_name&#62;
 463&nbsp;file_to_array() {
 464&nbsp;    [ $# -eq 2 ] || return 1  # Two arguments required.
 465&nbsp;    local IFS=${NO_WSP}
 466&nbsp;    local -a _fta_tmp_
 467&nbsp;    _fta_tmp_=( $(cat $1) )
 468&nbsp;    eval $2=\( \$\{_fta_tmp_\[@\]\} \)
 469&nbsp;    return 0
 470&nbsp;}
 471&nbsp;
 472&nbsp;# Columnized print of an array of multi-field strings.
 473&nbsp;# col_print &#60;array_name&#62; &#60;min_space&#62; &#60;tab_stop [tab_stops]&#62;
 474&nbsp;col_print() {
 475&nbsp;    [ $# -gt 2 ] || return 0
 476&nbsp;    local -a _cp_inp
 477&nbsp;    local -a _cp_spc
 478&nbsp;    local -a _cp_line
 479&nbsp;    local _cp_min
 480&nbsp;    local _cp_mcnt
 481&nbsp;    local _cp_pos
 482&nbsp;    local _cp_cnt
 483&nbsp;    local _cp_tab
 484&nbsp;    local -i _cp
 485&nbsp;    local -i _cpf
 486&nbsp;    local _cp_fld
 487&nbsp;    # WARNING: FOLLOWING LINE NOT BLANK -- IT IS QUOTED SPACES.
 488&nbsp;    local _cp_max='                                                            '
 489&nbsp;    set -f
 490&nbsp;    local IFS=${NO_WSP}
 491&nbsp;    eval _cp_inp=\(\ \$\{$1\[@\]\}\ \)
 492&nbsp;    [ ${#_cp_inp[@]} -gt 0 ] || return 0 # Empty is easy.
 493&nbsp;    _cp_mcnt=$2
 494&nbsp;    _cp_min=${_cp_max:1:${_cp_mcnt}}
 495&nbsp;    shift
 496&nbsp;    shift
 497&nbsp;    _cp_cnt=$#
 498&nbsp;    for (( _cp = 0 ; _cp &#60; _cp_cnt ; _cp++ ))
 499&nbsp;    do
 500&nbsp;        _cp_spc[${#_cp_spc[@]}]="${_cp_max:2:$1}" #"
 501&nbsp;        shift
 502&nbsp;    done
 503&nbsp;    _cp_cnt=${#_cp_inp[@]}
 504&nbsp;    for (( _cp = 0 ; _cp &#60; _cp_cnt ; _cp++ ))
 505&nbsp;    do
 506&nbsp;        _cp_pos=1
 507&nbsp;        IFS=${NO_WSP}$'\x20'
 508&nbsp;        _cp_line=( ${_cp_inp[${_cp}]} )
 509&nbsp;        IFS=${NO_WSP}
 510&nbsp;        for (( _cpf = 0 ; _cpf &#60; ${#_cp_line[@]} ; _cpf++ ))
 511&nbsp;        do
 512&nbsp;            _cp_tab=${_cp_spc[${_cpf}]:${_cp_pos}}
 513&nbsp;            if [ ${#_cp_tab} -lt ${_cp_mcnt} ]
 514&nbsp;            then
 515&nbsp;                _cp_tab="${_cp_min}"
 516&nbsp;            fi
 517&nbsp;            echo -n "${_cp_tab}"
 518&nbsp;            (( _cp_pos = ${_cp_pos} + ${#_cp_tab} ))
 519&nbsp;            _cp_fld="${_cp_line[${_cpf}]}"
 520&nbsp;            echo -n ${_cp_fld}
 521&nbsp;            (( _cp_pos = ${_cp_pos} + ${#_cp_fld} ))
 522&nbsp;        done
 523&nbsp;        echo
 524&nbsp;    done
 525&nbsp;    set +f
 526&nbsp;    return 0
 527&nbsp;}
 528&nbsp;
 529&nbsp;# # # # 'Hunt the Spammer' data flow # # # #
 530&nbsp;
 531&nbsp;# Application return code
 532&nbsp;declare -i _hs_RC
 533&nbsp;
 534&nbsp;# Original input, from which IP addresses are removed
 535&nbsp;# After which, domain names to check
 536&nbsp;declare -a uc_name
 537&nbsp;
 538&nbsp;# Original input IP addresses are moved here
 539&nbsp;# After which, IP addresses to check
 540&nbsp;declare -a uc_address
 541&nbsp;
 542&nbsp;# Names against which address expansion run
 543&nbsp;# Ready for name detail lookup
 544&nbsp;declare -a chk_name
 545&nbsp;
 546&nbsp;# Addresses against which name expansion run
 547&nbsp;# Ready for address detail lookup
 548&nbsp;declare -a chk_address
 549&nbsp;
 550&nbsp;#  Recursion is depth-first-by-name.
 551&nbsp;#  The expand_input_address maintains this list
 552&nbsp;#+ to prohibit looking up addresses twice during
 553&nbsp;#+ domain name recursion.
 554&nbsp;declare -a been_there_addr
 555&nbsp;been_there_addr=( '127.0.0.1' ) # Whitelist localhost
 556&nbsp;
 557&nbsp;# Names which we have checked (or given up on)
 558&nbsp;declare -a known_name
 559&nbsp;
 560&nbsp;# Addresses which we have checked (or given up on)
 561&nbsp;declare -a known_address
 562&nbsp;
 563&nbsp;#  List of zero or more Blacklist servers to check.
 564&nbsp;#  Each 'known_address' will be checked against each server,
 565&nbsp;#+ with negative replies and failures suppressed.
 566&nbsp;declare -a list_server
 567&nbsp;
 568&nbsp;# Indirection limit - set to zero == no limit
 569&nbsp;indirect=${SPAMMER_LIMIT:=2}
 570&nbsp;
 571&nbsp;# # # # 'Hunt the Spammer' information output data # # # #
 572&nbsp;
 573&nbsp;# Any domain name may have multiple IP addresses.
 574&nbsp;# Any IP address may have multiple domain names.
 575&nbsp;# Therefore, track unique address-name pairs.
 576&nbsp;declare -a known_pair
 577&nbsp;declare -a reverse_pair
 578&nbsp;
 579&nbsp;#  In addition to the data flow variables; known_address
 580&nbsp;#+ known_name and list_server, the following are output to the
 581&nbsp;#+ external graphics interface file.
 582&nbsp;
 583&nbsp;# Authority chain, parent -&#62; SOA fields.
 584&nbsp;declare -a auth_chain
 585&nbsp;
 586&nbsp;# Reference chain, parent name -&#62; child name
 587&nbsp;declare -a ref_chain
 588&nbsp;
 589&nbsp;# DNS chain - domain name -&#62; address
 590&nbsp;declare -a name_address
 591&nbsp;
 592&nbsp;# Name and service pairs - domain name -&#62; service
 593&nbsp;declare -a name_srvc
 594&nbsp;
 595&nbsp;# Name and resource pairs - domain name -&#62; Resource Record
 596&nbsp;declare -a name_resource
 597&nbsp;
 598&nbsp;# Parent and Child pairs - parent name -&#62; child name
 599&nbsp;# This MAY NOT be the same as the ref_chain followed!
 600&nbsp;declare -a parent_child
 601&nbsp;
 602&nbsp;# Address and Blacklist hit pairs - address-&#62;server
 603&nbsp;declare -a address_hits
 604&nbsp;
 605&nbsp;# Dump interface file data
 606&nbsp;declare -f _dot_dump
 607&nbsp;_dot_dump=pend_dummy   # Initially a no-op
 608&nbsp;
 609&nbsp;#  Data dump is enabled by setting the environment variable SPAMMER_DATA
 610&nbsp;#+ to the name of a writable file.
 611&nbsp;declare _dot_file
 612&nbsp;
 613&nbsp;# Helper function for the dump-to-dot-file function
 614&nbsp;# dump_to_dot &#60;array_name&#62; &#60;prefix&#62;
 615&nbsp;dump_to_dot() {
 616&nbsp;    local -a _dda_tmp
 617&nbsp;    local -i _dda_cnt
 618&nbsp;    local _dda_form='    '${2}'%04u %s\n'
 619&nbsp;    local IFS=${NO_WSP}
 620&nbsp;    eval _dda_tmp=\(\ \$\{$1\[@\]\}\ \)
 621&nbsp;    _dda_cnt=${#_dda_tmp[@]}
 622&nbsp;    if [ ${_dda_cnt} -gt 0 ]
 623&nbsp;    then
 624&nbsp;        for (( _dda = 0 ; _dda &#60; _dda_cnt ; _dda++ ))
 625&nbsp;        do
 626&nbsp;            printf "${_dda_form}" \
 627&nbsp;                   "${_dda}" "${_dda_tmp[${_dda}]}" &#62;&#62;${_dot_file}
 628&nbsp;        done
 629&nbsp;    fi
 630&nbsp;}
 631&nbsp;
 632&nbsp;# Which will also set _dot_dump to this function . . .
 633&nbsp;dump_dot() {
 634&nbsp;    local -i _dd_cnt
 635&nbsp;    echo '# Data vintage: '$(date -R) &#62;${_dot_file}
 636&nbsp;    echo '# ABS Guide: is_spammer.bash; v2, 2004-msz' &#62;&#62;${_dot_file}
 637&nbsp;    echo &#62;&#62;${_dot_file}
 638&nbsp;    echo 'digraph G {' &#62;&#62;${_dot_file}
 639&nbsp;
 640&nbsp;    if [ ${#known_name[@]} -gt 0 ]
 641&nbsp;    then
 642&nbsp;        echo &#62;&#62;${_dot_file}
 643&nbsp;        echo '# Known domain name nodes' &#62;&#62;${_dot_file}
 644&nbsp;        _dd_cnt=${#known_name[@]}
 645&nbsp;        for (( _dd = 0 ; _dd &#60; _dd_cnt ; _dd++ ))
 646&nbsp;        do
 647&nbsp;            printf '    N%04u [label="%s"] ;\n' \
 648&nbsp;                   "${_dd}" "${known_name[${_dd}]}" &#62;&#62;${_dot_file}
 649&nbsp;        done
 650&nbsp;    fi
 651&nbsp;
 652&nbsp;    if [ ${#known_address[@]} -gt 0 ]
 653&nbsp;    then
 654&nbsp;        echo &#62;&#62;${_dot_file}
 655&nbsp;        echo '# Known address nodes' &#62;&#62;${_dot_file}
 656&nbsp;        _dd_cnt=${#known_address[@]}
 657&nbsp;        for (( _dd = 0 ; _dd &#60; _dd_cnt ; _dd++ ))
 658&nbsp;        do
 659&nbsp;            printf '    A%04u [label="%s"] ;\n' \
 660&nbsp;                   "${_dd}" "${known_address[${_dd}]}" &#62;&#62;${_dot_file}
 661&nbsp;        done
 662&nbsp;    fi
 663&nbsp;
 664&nbsp;    echo                                   &#62;&#62;${_dot_file}
 665&nbsp;    echo '/*'                              &#62;&#62;${_dot_file}
 666&nbsp;    echo ' * Known relationships :: User conversion to'  &#62;&#62;${_dot_file}
 667&nbsp;    echo ' * graphic form by hand or program required.'  &#62;&#62;${_dot_file}
 668&nbsp;    echo ' *'                              &#62;&#62;${_dot_file}
 669&nbsp;
 670&nbsp;    if [ ${#auth_chain[@]} -gt 0 ]
 671&nbsp;    then
 672&nbsp;        echo &#62;&#62;${_dot_file}
 673&nbsp;        echo '# Authority reference edges followed and field source.'  &#62;&#62;${_dot_file}
 674&nbsp;        dump_to_dot auth_chain AC
 675&nbsp;    fi
 676&nbsp;
 677&nbsp;    if [ ${#ref_chain[@]} -gt 0 ]
 678&nbsp;    then
 679&nbsp;        echo &#62;&#62;${_dot_file}
 680&nbsp;        echo '# Name reference edges followed and field source.'  &#62;&#62;${_dot_file}
 681&nbsp;        dump_to_dot ref_chain RC
 682&nbsp;    fi
 683&nbsp;
 684&nbsp;    if [ ${#name_address[@]} -gt 0 ]
 685&nbsp;    then
 686&nbsp;        echo &#62;&#62;${_dot_file}
 687&nbsp;        echo '# Known name-&#62;address edges' &#62;&#62;${_dot_file}
 688&nbsp;        dump_to_dot name_address NA
 689&nbsp;    fi
 690&nbsp;
 691&nbsp;    if [ ${#name_srvc[@]} -gt 0 ]
 692&nbsp;    then
 693&nbsp;        echo &#62;&#62;${_dot_file}
 694&nbsp;        echo '# Known name-&#62;service edges' &#62;&#62;${_dot_file}
 695&nbsp;        dump_to_dot name_srvc NS
 696&nbsp;    fi
 697&nbsp;
 698&nbsp;    if [ ${#name_resource[@]} -gt 0 ]
 699&nbsp;    then
 700&nbsp;        echo &#62;&#62;${_dot_file}
 701&nbsp;        echo '# Known name-&#62;resource edges' &#62;&#62;${_dot_file}
 702&nbsp;        dump_to_dot name_resource NR
 703&nbsp;    fi
 704&nbsp;
 705&nbsp;    if [ ${#parent_child[@]} -gt 0 ]
 706&nbsp;    then
 707&nbsp;        echo &#62;&#62;${_dot_file}
 708&nbsp;        echo '# Known parent-&#62;child edges' &#62;&#62;${_dot_file}
 709&nbsp;        dump_to_dot parent_child PC
 710&nbsp;    fi
 711&nbsp;
 712&nbsp;    if [ ${#list_server[@]} -gt 0 ]
 713&nbsp;    then
 714&nbsp;        echo &#62;&#62;${_dot_file}
 715&nbsp;        echo '# Known Blacklist nodes' &#62;&#62;${_dot_file}
 716&nbsp;        _dd_cnt=${#list_server[@]}
 717&nbsp;        for (( _dd = 0 ; _dd &#60; _dd_cnt ; _dd++ ))
 718&nbsp;        do
 719&nbsp;            printf '    LS%04u [label="%s"] ;\n' \
 720&nbsp;                   "${_dd}" "${list_server[${_dd}]}" &#62;&#62;${_dot_file}
 721&nbsp;        done
 722&nbsp;    fi
 723&nbsp;
 724&nbsp;    unique_lines address_hits address_hits
 725&nbsp;    if [ ${#address_hits[@]} -gt 0 ]
 726&nbsp;    then
 727&nbsp;        echo &#62;&#62;${_dot_file}
 728&nbsp;        echo '# Known address-&#62;Blacklist_hit edges' &#62;&#62;${_dot_file}
 729&nbsp;        echo '# CAUTION: dig warnings can trigger false hits.' &#62;&#62;${_dot_file}
 730&nbsp;        dump_to_dot address_hits AH
 731&nbsp;    fi
 732&nbsp;    echo          &#62;&#62;${_dot_file}
 733&nbsp;    echo ' *'     &#62;&#62;${_dot_file}
 734&nbsp;    echo ' * That is a lot of relationships. Happy graphing.' &#62;&#62;${_dot_file}
 735&nbsp;    echo ' */'    &#62;&#62;${_dot_file}
 736&nbsp;    echo '}'      &#62;&#62;${_dot_file}
 737&nbsp;    return 0
 738&nbsp;}
 739&nbsp;
 740&nbsp;# # # # 'Hunt the Spammer' execution flow # # # #
 741&nbsp;
 742&nbsp;#  Execution trace is enabled by setting the
 743&nbsp;#+ environment variable SPAMMER_TRACE to the name of a writable file.
 744&nbsp;declare -a _trace_log
 745&nbsp;declare _log_file
 746&nbsp;
 747&nbsp;# Function to fill the trace log
 748&nbsp;trace_logger() {
 749&nbsp;    _trace_log[${#_trace_log[@]}]=${_pend_current_}
 750&nbsp;}
 751&nbsp;
 752&nbsp;# Dump trace log to file function variable.
 753&nbsp;declare -f _log_dump
 754&nbsp;_log_dump=pend_dummy   # Initially a no-op.
 755&nbsp;
 756&nbsp;# Dump the trace log to a file.
 757&nbsp;dump_log() {
 758&nbsp;    local -i _dl_cnt
 759&nbsp;    _dl_cnt=${#_trace_log[@]}
 760&nbsp;    for (( _dl = 0 ; _dl &#60; _dl_cnt ; _dl++ ))
 761&nbsp;    do
 762&nbsp;        echo ${_trace_log[${_dl}]} &#62;&#62; ${_log_file}
 763&nbsp;    done
 764&nbsp;    _dl_cnt=${#_pending_[@]}
 765&nbsp;    if [ ${_dl_cnt} -gt 0 ]
 766&nbsp;    then
 767&nbsp;        _dl_cnt=${_dl_cnt}-1
 768&nbsp;        echo '# # # Operations stack not empty # # #' &#62;&#62; ${_log_file}
 769&nbsp;        for (( _dl = ${_dl_cnt} ; _dl &#62;= 0 ; _dl-- ))
 770&nbsp;        do
 771&nbsp;            echo ${_pending_[${_dl}]} &#62;&#62; ${_log_file}
 772&nbsp;        done
 773&nbsp;    fi
 774&nbsp;}
 775&nbsp;
 776&nbsp;# # # Utility program 'dig' wrappers # # #
 777&nbsp;#
 778&nbsp;#  These wrappers are derived from the
 779&nbsp;#+ examples shown in dig_wrappers.bash.
 780&nbsp;#
 781&nbsp;#  The major difference is these return
 782&nbsp;#+ their results as a list in an array.
 783&nbsp;#
 784&nbsp;#  See dig_wrappers.bash for details and
 785&nbsp;#+ use that script to develop any changes.
 786&nbsp;#
 787&nbsp;# # #
 788&nbsp;
 789&nbsp;# Short form answer: 'dig' parses answer.
 790&nbsp;
 791&nbsp;# Forward lookup :: Name -&#62; Address
 792&nbsp;# short_fwd &#60;domain_name&#62; &#60;array_name&#62;
 793&nbsp;short_fwd() {
 794&nbsp;    local -a _sf_reply
 795&nbsp;    local -i _sf_rc
 796&nbsp;    local -i _sf_cnt
 797&nbsp;    IFS=${NO_WSP}
 798&nbsp;echo -n '.'
 799&nbsp;# echo 'sfwd: '${1}
 800&nbsp;    _sf_reply=( $(dig +short ${1} -c in -t a 2&#62;/dev/null) )
 801&nbsp;    _sf_rc=$?
 802&nbsp;    if [ ${_sf_rc} -ne 0 ]
 803&nbsp;    then
 804&nbsp;        _trace_log[${#_trace_log[@]}]='# # # Lookup error '${_sf_rc}' on '${1}' # # #'
 805&nbsp;# [ ${_sf_rc} -ne 9 ] &#38;&#38; pend_drop
 806&nbsp;        return ${_sf_rc}
 807&nbsp;    else
 808&nbsp;        # Some versions of 'dig' return warnings on stdout.
 809&nbsp;        _sf_cnt=${#_sf_reply[@]}
 810&nbsp;        for (( _sf = 0 ; _sf &#60; ${_sf_cnt} ; _sf++ ))
 811&nbsp;        do
 812&nbsp;            [ 'x'${_sf_reply[${_sf}]:0:2} == 'x;;' ] &#38;&#38;
 813&nbsp;                unset _sf_reply[${_sf}]
 814&nbsp;        done
 815&nbsp;        eval $2=\( \$\{_sf_reply\[@\]\} \)
 816&nbsp;    fi
 817&nbsp;    return 0
 818&nbsp;}
 819&nbsp;
 820&nbsp;# Reverse lookup :: Address -&#62; Name
 821&nbsp;# short_rev &#60;ip_address&#62; &#60;array_name&#62;
 822&nbsp;short_rev() {
 823&nbsp;    local -a _sr_reply
 824&nbsp;    local -i _sr_rc
 825&nbsp;    local -i _sr_cnt
 826&nbsp;    IFS=${NO_WSP}
 827&nbsp;echo -n '.'
 828&nbsp;# echo 'srev: '${1}
 829&nbsp;    _sr_reply=( $(dig +short -x ${1} 2&#62;/dev/null) )
 830&nbsp;    _sr_rc=$?
 831&nbsp;    if [ ${_sr_rc} -ne 0 ]
 832&nbsp;    then
 833&nbsp;        _trace_log[${#_trace_log[@]}]='# # # Lookup error '${_sr_rc}' on '${1}' # # #'
 834&nbsp;# [ ${_sr_rc} -ne 9 ] &#38;&#38; pend_drop
 835&nbsp;        return ${_sr_rc}
 836&nbsp;    else
 837&nbsp;        # Some versions of 'dig' return warnings on stdout.
 838&nbsp;        _sr_cnt=${#_sr_reply[@]}
 839&nbsp;        for (( _sr = 0 ; _sr &#60; ${_sr_cnt} ; _sr++ ))
 840&nbsp;        do
 841&nbsp;            [ 'x'${_sr_reply[${_sr}]:0:2} == 'x;;' ] &#38;&#38;
 842&nbsp;                unset _sr_reply[${_sr}]
 843&nbsp;        done
 844&nbsp;        eval $2=\( \$\{_sr_reply\[@\]\} \)
 845&nbsp;    fi
 846&nbsp;    return 0
 847&nbsp;}
 848&nbsp;
 849&nbsp;# Special format lookup used to query blacklist servers.
 850&nbsp;# short_text &#60;ip_address&#62; &#60;array_name&#62;
 851&nbsp;short_text() {
 852&nbsp;    local -a _st_reply
 853&nbsp;    local -i _st_rc
 854&nbsp;    local -i _st_cnt
 855&nbsp;    IFS=${NO_WSP}
 856&nbsp;# echo 'stxt: '${1}
 857&nbsp;    _st_reply=( $(dig +short ${1} -c in -t txt 2&#62;/dev/null) )
 858&nbsp;    _st_rc=$?
 859&nbsp;    if [ ${_st_rc} -ne 0 ]
 860&nbsp;    then
 861&nbsp;        _trace_log[${#_trace_log[@]}]='# # # Text lookup error '${_st_rc}' on '${1}' # # #'
 862&nbsp;# [ ${_st_rc} -ne 9 ] &#38;&#38; pend_drop
 863&nbsp;        return ${_st_rc}
 864&nbsp;    else
 865&nbsp;        # Some versions of 'dig' return warnings on stdout.
 866&nbsp;        _st_cnt=${#_st_reply[@]}
 867&nbsp;        for (( _st = 0 ; _st &#60; ${#_st_cnt} ; _st++ ))
 868&nbsp;        do
 869&nbsp;            [ 'x'${_st_reply[${_st}]:0:2} == 'x;;' ] &#38;&#38;
 870&nbsp;                unset _st_reply[${_st}]
 871&nbsp;        done
 872&nbsp;        eval $2=\( \$\{_st_reply\[@\]\} \)
 873&nbsp;    fi
 874&nbsp;    return 0
 875&nbsp;}
 876&nbsp;
 877&nbsp;# The long forms, a.k.a., the parse it yourself versions
 878&nbsp;
 879&nbsp;# RFC 2782   Service lookups
 880&nbsp;# dig +noall +nofail +answer _ldap._tcp.openldap.org -t srv
 881&nbsp;# _&#60;service&#62;._&#60;protocol&#62;.&#60;domain_name&#62;
 882&nbsp;# _ldap._tcp.openldap.org. 3600   IN      SRV     0 0 389 ldap.openldap.org.
 883&nbsp;# domain TTL Class SRV Priority Weight Port Target
 884&nbsp;
 885&nbsp;# Forward lookup :: Name -&#62; poor man's zone transfer
 886&nbsp;# long_fwd &#60;domain_name&#62; &#60;array_name&#62;
 887&nbsp;long_fwd() {
 888&nbsp;    local -a _lf_reply
 889&nbsp;    local -i _lf_rc
 890&nbsp;    local -i _lf_cnt
 891&nbsp;    IFS=${NO_WSP}
 892&nbsp;echo -n ':'
 893&nbsp;# echo 'lfwd: '${1}
 894&nbsp;    _lf_reply=( $(
 895&nbsp;        dig +noall +nofail +answer +authority +additional \
 896&nbsp;            ${1} -t soa ${1} -t mx ${1} -t any 2&#62;/dev/null) )
 897&nbsp;    _lf_rc=$?
 898&nbsp;    if [ ${_lf_rc} -ne 0 ]
 899&nbsp;    then
 900&nbsp;        _trace_log[${#_trace_log[@]}]='# # # Zone lookup error '${_lf_rc}' on '${1}' # # #'
 901&nbsp;# [ ${_lf_rc} -ne 9 ] &#38;&#38; pend_drop
 902&nbsp;        return ${_lf_rc}
 903&nbsp;    else
 904&nbsp;        # Some versions of 'dig' return warnings on stdout.
 905&nbsp;        _lf_cnt=${#_lf_reply[@]}
 906&nbsp;        for (( _lf = 0 ; _lf &#60; ${_lf_cnt} ; _lf++ ))
 907&nbsp;        do
 908&nbsp;            [ 'x'${_lf_reply[${_lf}]:0:2} == 'x;;' ] &#38;&#38;
 909&nbsp;                unset _lf_reply[${_lf}]
 910&nbsp;        done
 911&nbsp;        eval $2=\( \$\{_lf_reply\[@\]\} \)
 912&nbsp;    fi
 913&nbsp;    return 0
 914&nbsp;}
 915&nbsp;#   The reverse lookup domain name corresponding to the IPv6 address:
 916&nbsp;#       4321:0:1:2:3:4:567:89ab
 917&nbsp;#   would be (nibble, I.E: Hexdigit) reversed:
 918&nbsp;#   b.a.9.8.7.6.5.0.4.0.0.0.3.0.0.0.2.0.0.0.1.0.0.0.0.0.0.0.1.2.3.4.IP6.ARPA.
 919&nbsp;
 920&nbsp;# Reverse lookup :: Address -&#62; poor man's delegation chain
 921&nbsp;# long_rev &#60;rev_ip_address&#62; &#60;array_name&#62;
 922&nbsp;long_rev() {
 923&nbsp;    local -a _lr_reply
 924&nbsp;    local -i _lr_rc
 925&nbsp;    local -i _lr_cnt
 926&nbsp;    local _lr_dns
 927&nbsp;    _lr_dns=${1}'.in-addr.arpa.'
 928&nbsp;    IFS=${NO_WSP}
 929&nbsp;echo -n ':'
 930&nbsp;# echo 'lrev: '${1}
 931&nbsp;    _lr_reply=( $(
 932&nbsp;         dig +noall +nofail +answer +authority +additional \
 933&nbsp;             ${_lr_dns} -t soa ${_lr_dns} -t any 2&#62;/dev/null) )
 934&nbsp;    _lr_rc=$?
 935&nbsp;    if [ ${_lr_rc} -ne 0 ]
 936&nbsp;    then
 937&nbsp;        _trace_log[${#_trace_log[@]}]='# # # Delegation lookup error '${_lr_rc}' on '${1}' # # #'
 938&nbsp;# [ ${_lr_rc} -ne 9 ] &#38;&#38; pend_drop
 939&nbsp;        return ${_lr_rc}
 940&nbsp;    else
 941&nbsp;        # Some versions of 'dig' return warnings on stdout.
 942&nbsp;        _lr_cnt=${#_lr_reply[@]}
 943&nbsp;        for (( _lr = 0 ; _lr &#60; ${_lr_cnt} ; _lr++ ))
 944&nbsp;        do
 945&nbsp;            [ 'x'${_lr_reply[${_lr}]:0:2} == 'x;;' ] &#38;&#38;
 946&nbsp;                unset _lr_reply[${_lr}]
 947&nbsp;        done
 948&nbsp;        eval $2=\( \$\{_lr_reply\[@\]\} \)
 949&nbsp;    fi
 950&nbsp;    return 0
 951&nbsp;}
 952&nbsp;
 953&nbsp;# # # Application specific functions # # #
 954&nbsp;
 955&nbsp;# Mung a possible name; suppresses root and TLDs.
 956&nbsp;# name_fixup &#60;string&#62;
 957&nbsp;name_fixup(){
 958&nbsp;    local -a _nf_tmp
 959&nbsp;    local -i _nf_end
 960&nbsp;    local _nf_str
 961&nbsp;    local IFS
 962&nbsp;    _nf_str=$(to_lower ${1})
 963&nbsp;    _nf_str=$(to_dot ${_nf_str})
 964&nbsp;    _nf_end=${#_nf_str}-1
 965&nbsp;    [ ${_nf_str:${_nf_end}} != '.' ] &#38;&#38;
 966&nbsp;        _nf_str=${_nf_str}'.'
 967&nbsp;    IFS=${ADR_IFS}
 968&nbsp;    _nf_tmp=( ${_nf_str} )
 969&nbsp;    IFS=${WSP_IFS}
 970&nbsp;    _nf_end=${#_nf_tmp[@]}
 971&nbsp;    case ${_nf_end} in
 972&nbsp;    0) # No dots, only dots.
 973&nbsp;        echo
 974&nbsp;        return 1
 975&nbsp;    ;;
 976&nbsp;    1) # Only a TLD.
 977&nbsp;        echo
 978&nbsp;        return 1
 979&nbsp;    ;;
 980&nbsp;    2) # Maybe okay.
 981&nbsp;       echo ${_nf_str}
 982&nbsp;       return 0
 983&nbsp;       # Needs a lookup table?
 984&nbsp;       if [ ${#_nf_tmp[1]} -eq 2 ]
 985&nbsp;       then # Country coded TLD.
 986&nbsp;           echo
 987&nbsp;           return 1
 988&nbsp;       else
 989&nbsp;           echo ${_nf_str}
 990&nbsp;           return 0
 991&nbsp;       fi
 992&nbsp;    ;;
 993&nbsp;    esac
 994&nbsp;    echo ${_nf_str}
 995&nbsp;    return 0
 996&nbsp;}
 997&nbsp;
 998&nbsp;# Grope and mung original input(s).
 999&nbsp;split_input() {
1000&nbsp;    [ ${#uc_name[@]} -gt 0 ] || return 0
1001&nbsp;    local -i _si_cnt
1002&nbsp;    local -i _si_len
1003&nbsp;    local _si_str
1004&nbsp;    unique_lines uc_name uc_name
1005&nbsp;    _si_cnt=${#uc_name[@]}
1006&nbsp;    for (( _si = 0 ; _si &#60; _si_cnt ; _si++ ))
1007&nbsp;    do
1008&nbsp;        _si_str=${uc_name[$_si]}
1009&nbsp;        if is_address ${_si_str}
1010&nbsp;        then
1011&nbsp;            uc_address[${#uc_address[@]}]=${_si_str}
1012&nbsp;            unset uc_name[$_si]
1013&nbsp;        else
1014&nbsp;            if ! uc_name[$_si]=$(name_fixup ${_si_str})
1015&nbsp;            then
1016&nbsp;                unset ucname[$_si]
1017&nbsp;            fi
1018&nbsp;        fi
1019&nbsp;    done
1020&nbsp;    uc_name=( ${uc_name[@]} )
1021&nbsp;    _si_cnt=${#uc_name[@]}
1022&nbsp;    _trace_log[${#_trace_log[@]}]='# # # Input '${_si_cnt}' unchecked name input(s). # # #'
1023&nbsp;    _si_cnt=${#uc_address[@]}
1024&nbsp;    _trace_log[${#_trace_log[@]}]='# # # Input '${_si_cnt}' unchecked address input(s). # # #'
1025&nbsp;    return 0
1026&nbsp;}
1027&nbsp;
1028&nbsp;# # # Discovery functions -- recursively interlocked by external data # # #
1029&nbsp;# # # The leading 'if list is empty; return 0' in each is required. # # #
1030&nbsp;
1031&nbsp;# Recursion limiter
1032&nbsp;# limit_chk() &#60;next_level&#62;
1033&nbsp;limit_chk() {
1034&nbsp;    local -i _lc_lmt
1035&nbsp;    # Check indirection limit.
1036&nbsp;    if [ ${indirect} -eq 0 ] || [ $# -eq 0 ]
1037&nbsp;    then
1038&nbsp;        # The 'do-forever' choice
1039&nbsp;        echo 1                 # Any value will do.
1040&nbsp;        return 0               # OK to continue.
1041&nbsp;    else
1042&nbsp;        # Limiting is in effect.
1043&nbsp;        if [ ${indirect} -lt ${1} ]
1044&nbsp;        then
1045&nbsp;            echo ${1}          # Whatever.
1046&nbsp;            return 1           # Stop here.
1047&nbsp;        else
1048&nbsp;            _lc_lmt=${1}+1     # Bump the given limit.
1049&nbsp;            echo ${_lc_lmt}    # Echo it.
1050&nbsp;            return 0           # OK to continue.
1051&nbsp;        fi
1052&nbsp;    fi
1053&nbsp;}
1054&nbsp;
1055&nbsp;# For each name in uc_name:
1056&nbsp;#     Move name to chk_name.
1057&nbsp;#     Add addresses to uc_address.
1058&nbsp;#     Pend expand_input_address.
1059&nbsp;#     Repeat until nothing new found.
1060&nbsp;# expand_input_name &#60;indirection_limit&#62;
1061&nbsp;expand_input_name() {
1062&nbsp;    [ ${#uc_name[@]} -gt 0 ] || return 0
1063&nbsp;    local -a _ein_addr
1064&nbsp;    local -a _ein_new
1065&nbsp;    local -i _ucn_cnt
1066&nbsp;    local -i _ein_cnt
1067&nbsp;    local _ein_tst
1068&nbsp;    _ucn_cnt=${#uc_name[@]}
1069&nbsp;
1070&nbsp;    if  ! _ein_cnt=$(limit_chk ${1})
1071&nbsp;    then
1072&nbsp;        return 0
1073&nbsp;    fi
1074&nbsp;
1075&nbsp;    for (( _ein = 0 ; _ein &#60; _ucn_cnt ; _ein++ ))
1076&nbsp;    do
1077&nbsp;        if short_fwd ${uc_name[${_ein}]} _ein_new
1078&nbsp;        then
1079&nbsp;            for (( _ein_cnt = 0 ; _ein_cnt &#60; ${#_ein_new[@]}; _ein_cnt++ ))
1080&nbsp;            do
1081&nbsp;                _ein_tst=${_ein_new[${_ein_cnt}]}
1082&nbsp;                if is_address ${_ein_tst}
1083&nbsp;                then
1084&nbsp;                    _ein_addr[${#_ein_addr[@]}]=${_ein_tst}
1085&nbsp;                fi
1086&nbsp;           done
1087&nbsp;        fi
1088&nbsp;    done
1089&nbsp;    unique_lines _ein_addr _ein_addr     # Scrub duplicates.
1090&nbsp;    edit_exact chk_address _ein_addr     # Scrub pending detail.
1091&nbsp;    edit_exact known_address _ein_addr   # Scrub already detailed.
1092&nbsp;    if [ ${#_ein_addr[@]} -gt 0 ]        # Anything new?
1093&nbsp;    then
1094&nbsp;        uc_address=( ${uc_address[@]} ${_ein_addr[@]} )
1095&nbsp;        pend_func expand_input_address ${1}
1096&nbsp;        _trace_log[${#_trace_log[@]}]='# # # Added '${#_ein_addr[@]}' unchecked address input(s). # # #'
1097&nbsp;    fi
1098&nbsp;    edit_exact chk_name uc_name          # Scrub pending detail.
1099&nbsp;    edit_exact known_name uc_name        # Scrub already detailed.
1100&nbsp;    if [ ${#uc_name[@]} -gt 0 ]
1101&nbsp;    then
1102&nbsp;        chk_name=( ${chk_name[@]} ${uc_name[@]}  )
1103&nbsp;        pend_func detail_each_name ${1}
1104&nbsp;    fi
1105&nbsp;    unset uc_name[@]
1106&nbsp;    return 0
1107&nbsp;}
1108&nbsp;
1109&nbsp;# For each address in uc_address:
1110&nbsp;#     Move address to chk_address.
1111&nbsp;#     Add names to uc_name.
1112&nbsp;#     Pend expand_input_name.
1113&nbsp;#     Repeat until nothing new found.
1114&nbsp;# expand_input_address &#60;indirection_limit&#62;
1115&nbsp;expand_input_address() {
1116&nbsp;    [ ${#uc_address[@]} -gt 0 ] || return 0
1117&nbsp;    local -a _eia_addr
1118&nbsp;    local -a _eia_name
1119&nbsp;    local -a _eia_new
1120&nbsp;    local -i _uca_cnt
1121&nbsp;    local -i _eia_cnt
1122&nbsp;    local _eia_tst
1123&nbsp;    unique_lines uc_address _eia_addr
1124&nbsp;    unset uc_address[@]
1125&nbsp;    edit_exact been_there_addr _eia_addr
1126&nbsp;    _uca_cnt=${#_eia_addr[@]}
1127&nbsp;    [ ${_uca_cnt} -gt 0 ] &#38;&#38;
1128&nbsp;        been_there_addr=( ${been_there_addr[@]} ${_eia_addr[@]} )
1129&nbsp;
1130&nbsp;    for (( _eia = 0 ; _eia &#60; _uca_cnt ; _eia++ ))
1131&nbsp;    do
1132&nbsp;            if short_rev ${_eia_addr[${_eia}]} _eia_new
1133&nbsp;            then
1134&nbsp;                for (( _eia_cnt = 0 ; _eia_cnt &#60; ${#_eia_new[@]} ; _eia_cnt++ ))
1135&nbsp;                do
1136&nbsp;                    _eia_tst=${_eia_new[${_eia_cnt}]}
1137&nbsp;                    if _eia_tst=$(name_fixup ${_eia_tst})
1138&nbsp;                    then
1139&nbsp;                        _eia_name[${#_eia_name[@]}]=${_eia_tst}
1140&nbsp;                    fi
1141&nbsp;                done
1142&nbsp;            fi
1143&nbsp;    done
1144&nbsp;    unique_lines _eia_name _eia_name     # Scrub duplicates.
1145&nbsp;    edit_exact chk_name _eia_name        # Scrub pending detail.
1146&nbsp;    edit_exact known_name _eia_name      # Scrub already detailed.
1147&nbsp;    if [ ${#_eia_name[@]} -gt 0 ]        # Anything new?
1148&nbsp;    then
1149&nbsp;        uc_name=( ${uc_name[@]} ${_eia_name[@]} )
1150&nbsp;        pend_func expand_input_name ${1}
1151&nbsp;        _trace_log[${#_trace_log[@]}]='# # # Added '${#_eia_name[@]}' unchecked name input(s). # # #'
1152&nbsp;    fi
1153&nbsp;    edit_exact chk_address _eia_addr     # Scrub pending detail.
1154&nbsp;    edit_exact known_address _eia_addr   # Scrub already detailed.
1155&nbsp;    if [ ${#_eia_addr[@]} -gt 0 ]        # Anything new?
1156&nbsp;    then
1157&nbsp;        chk_address=( ${chk_address[@]} ${_eia_addr[@]} )
1158&nbsp;        pend_func detail_each_address ${1}
1159&nbsp;    fi
1160&nbsp;    return 0
1161&nbsp;}
1162&nbsp;
1163&nbsp;# The parse-it-yourself zone reply.
1164&nbsp;# The input is the chk_name list.
1165&nbsp;# detail_each_name &#60;indirection_limit&#62;
1166&nbsp;detail_each_name() {
1167&nbsp;    [ ${#chk_name[@]} -gt 0 ] || return 0
1168&nbsp;    local -a _den_chk       # Names to check
1169&nbsp;    local -a _den_name      # Names found here
1170&nbsp;    local -a _den_address   # Addresses found here
1171&nbsp;    local -a _den_pair      # Pairs found here
1172&nbsp;    local -a _den_rev       # Reverse pairs found here
1173&nbsp;    local -a _den_tmp       # Line being parsed
1174&nbsp;    local -a _den_auth      # SOA contact being parsed
1175&nbsp;    local -a _den_new       # The zone reply
1176&nbsp;    local -a _den_pc        # Parent-Child gets big fast
1177&nbsp;    local -a _den_ref       # So does reference chain
1178&nbsp;    local -a _den_nr        # Name-Resource can be big
1179&nbsp;    local -a _den_na        # Name-Address
1180&nbsp;    local -a _den_ns        # Name-Service
1181&nbsp;    local -a _den_achn      # Chain of Authority
1182&nbsp;    local -i _den_cnt       # Count of names to detail
1183&nbsp;    local -i _den_lmt       # Indirection limit
1184&nbsp;    local _den_who          # Named being processed
1185&nbsp;    local _den_rec          # Record type being processed
1186&nbsp;    local _den_cont         # Contact domain
1187&nbsp;    local _den_str          # Fixed up name string
1188&nbsp;    local _den_str2         # Fixed up reverse
1189&nbsp;    local IFS=${WSP_IFS}
1190&nbsp;
1191&nbsp;    # Local, unique copy of names to check
1192&nbsp;    unique_lines chk_name _den_chk
1193&nbsp;    unset chk_name[@]       # Done with globals.
1194&nbsp;
1195&nbsp;    # Less any names already known
1196&nbsp;    edit_exact known_name _den_chk
1197&nbsp;    _den_cnt=${#_den_chk[@]}
1198&nbsp;
1199&nbsp;    # If anything left, add to known_name.
1200&nbsp;    [ ${_den_cnt} -gt 0 ] &#38;&#38;
1201&nbsp;        known_name=( ${known_name[@]} ${_den_chk[@]} )
1202&nbsp;
1203&nbsp;    # for the list of (previously) unknown names . . .
1204&nbsp;    for (( _den = 0 ; _den &#60; _den_cnt ; _den++ ))
1205&nbsp;    do
1206&nbsp;        _den_who=${_den_chk[${_den}]}
1207&nbsp;        if long_fwd ${_den_who} _den_new
1208&nbsp;        then
1209&nbsp;            unique_lines _den_new _den_new
1210&nbsp;            if [ ${#_den_new[@]} -eq 0 ]
1211&nbsp;            then
1212&nbsp;                _den_pair[${#_den_pair[@]}]='0.0.0.0 '${_den_who}
1213&nbsp;            fi
1214&nbsp;
1215&nbsp;            # Parse each line in the reply.
1216&nbsp;            for (( _line = 0 ; _line &#60; ${#_den_new[@]} ; _line++ ))
1217&nbsp;            do
1218&nbsp;                IFS=${NO_WSP}$'\x09'$'\x20'
1219&nbsp;                _den_tmp=( ${_den_new[${_line}]} )
1220&nbsp;                IFS=${WSP_IFS}
1221&nbsp;                # If usable record and not a warning message . . .
1222&nbsp;                if [ ${#_den_tmp[@]} -gt 4 ] &#38;&#38; [ 'x'${_den_tmp[0]} != 'x;;' ]
1223&nbsp;                then
1224&nbsp;                    _den_rec=${_den_tmp[3]}
1225&nbsp;                    _den_nr[${#_den_nr[@]}]=${_den_who}' '${_den_rec}
1226&nbsp;                    # Begin at RFC1033 (+++)
1227&nbsp;                    case ${_den_rec} in
1228&nbsp;
1229&nbsp;                         #&#60;name&#62;  [&#60;ttl&#62;]  [&#60;class&#62;]  SOA  &#60;origin&#62;  &#60;person&#62;
1230&nbsp;                    SOA) # Start Of Authority
1231&nbsp;                        if _den_str=$(name_fixup ${_den_tmp[0]})
1232&nbsp;                        then
1233&nbsp;                            _den_name[${#_den_name[@]}]=${_den_str}
1234&nbsp;                            _den_achn[${#_den_achn[@]}]=${_den_who}' '${_den_str}' SOA'
1235&nbsp;                            # SOA origin -- domain name of master zone record
1236&nbsp;                            if _den_str2=$(name_fixup ${_den_tmp[4]})
1237&nbsp;                            then
1238&nbsp;                                _den_name[${#_den_name[@]}]=${_den_str2}
1239&nbsp;                                _den_achn[${#_den_achn[@]}]=${_den_who}' '${_den_str2}' SOA.O'
1240&nbsp;                            fi
1241&nbsp;                            # Responsible party e-mail address (possibly bogus).
1242&nbsp;                            # Possibility of first.last@domain.name ignored.
1243&nbsp;                            set -f
1244&nbsp;                            if _den_str2=$(name_fixup ${_den_tmp[5]})
1245&nbsp;                            then
1246&nbsp;                                IFS=${ADR_IFS}
1247&nbsp;                                _den_auth=( ${_den_str2} )
1248&nbsp;                                IFS=${WSP_IFS}
1249&nbsp;                                if [ ${#_den_auth[@]} -gt 2 ]
1250&nbsp;                                then
1251&nbsp;                                     _den_cont=${_den_auth[1]}
1252&nbsp;                                     for (( _auth = 2 ; _auth &#60; ${#_den_auth[@]} ; _auth++ ))
1253&nbsp;                                     do
1254&nbsp;                                       _den_cont=${_den_cont}'.'${_den_auth[${_auth}]}
1255&nbsp;                                     done
1256&nbsp;                                     _den_name[${#_den_name[@]}]=${_den_cont}'.'
1257&nbsp;                                     _den_achn[${#_den_achn[@]}]=${_den_who}' '${_den_cont}'. SOA.C'
1258&nbsp;                                fi
1259&nbsp;                            fi
1260&nbsp;                            set +f
1261&nbsp;                        fi
1262&nbsp;                    ;;
1263&nbsp;
1264&nbsp;
1265&nbsp;                    A) # IP(v4) Address Record
1266&nbsp;                        if _den_str=$(name_fixup ${_den_tmp[0]})
1267&nbsp;                        then
1268&nbsp;                            _den_name[${#_den_name[@]}]=${_den_str}
1269&nbsp;                            _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' '${_den_str}
1270&nbsp;                            _den_na[${#_den_na[@]}]=${_den_str}' '${_den_tmp[4]}
1271&nbsp;                            _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' A'
1272&nbsp;                        else
1273&nbsp;                            _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' unknown.domain'
1274&nbsp;                            _den_na[${#_den_na[@]}]='unknown.domain '${_den_tmp[4]}
1275&nbsp;                            _den_ref[${#_den_ref[@]}]=${_den_who}' unknown.domain A'
1276&nbsp;                        fi
1277&nbsp;                        _den_address[${#_den_address[@]}]=${_den_tmp[4]}
1278&nbsp;                        _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_tmp[4]}
1279&nbsp;                    ;;
1280&nbsp;
1281&nbsp;                    NS) # Name Server Record
1282&nbsp;                        # Domain name being serviced (may be other than current)
1283&nbsp;                        if _den_str=$(name_fixup ${_den_tmp[0]})
1284&nbsp;                        then
1285&nbsp;                            _den_name[${#_den_name[@]}]=${_den_str}
1286&nbsp;                            _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' NS'
1287&nbsp;
1288&nbsp;                            # Domain name of service provider
1289&nbsp;                            if _den_str2=$(name_fixup ${_den_tmp[4]})
1290&nbsp;                            then
1291&nbsp;                                _den_name[${#_den_name[@]}]=${_den_str2}
1292&nbsp;                                _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str2}' NSH'
1293&nbsp;                                _den_ns[${#_den_ns[@]}]=${_den_str2}' NS'
1294&nbsp;                                _den_pc[${#_den_pc[@]}]=${_den_str}' '${_den_str2}
1295&nbsp;                            fi
1296&nbsp;                        fi
1297&nbsp;                    ;;
1298&nbsp;
1299&nbsp;                    MX) # Mail Server Record
1300&nbsp;                        # Domain name being serviced (wildcards not handled here)
1301&nbsp;                        if _den_str=$(name_fixup ${_den_tmp[0]})
1302&nbsp;                        then
1303&nbsp;                            _den_name[${#_den_name[@]}]=${_den_str}
1304&nbsp;                            _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' MX'
1305&nbsp;                        fi
1306&nbsp;                        # Domain name of service provider
1307&nbsp;                        if _den_str=$(name_fixup ${_den_tmp[5]})
1308&nbsp;                        then
1309&nbsp;                            _den_name[${#_den_name[@]}]=${_den_str}
1310&nbsp;                            _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' MXH'
1311&nbsp;                            _den_ns[${#_den_ns[@]}]=${_den_str}' MX'
1312&nbsp;                            _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}
1313&nbsp;                        fi
1314&nbsp;                    ;;
1315&nbsp;
1316&nbsp;                    PTR) # Reverse address record
1317&nbsp;                         # Special name
1318&nbsp;                        if _den_str=$(name_fixup ${_den_tmp[0]})
1319&nbsp;                        then
1320&nbsp;                            _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' PTR'
1321&nbsp;                            # Host name (not a CNAME)
1322&nbsp;                            if _den_str2=$(name_fixup ${_den_tmp[4]})
1323&nbsp;                            then
1324&nbsp;                                _den_rev[${#_den_rev[@]}]=${_den_str}' '${_den_str2}
1325&nbsp;                                _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str2}' PTRH'
1326&nbsp;                                _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}
1327&nbsp;                            fi
1328&nbsp;                        fi
1329&nbsp;                    ;;
1330&nbsp;
1331&nbsp;                    AAAA) # IP(v6) Address Record
1332&nbsp;                        if _den_str=$(name_fixup ${_den_tmp[0]})
1333&nbsp;                        then
1334&nbsp;                            _den_name[${#_den_name[@]}]=${_den_str}
1335&nbsp;                            _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' '${_den_str}
1336&nbsp;                            _den_na[${#_den_na[@]}]=${_den_str}' '${_den_tmp[4]}
1337&nbsp;                            _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' AAAA'
1338&nbsp;                        else
1339&nbsp;                            _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' unknown.domain'
1340&nbsp;                            _den_na[${#_den_na[@]}]='unknown.domain '${_den_tmp[4]}
1341&nbsp;                            _den_ref[${#_den_ref[@]}]=${_den_who}' unknown.domain'
1342&nbsp;                        fi
1343&nbsp;                        # No processing for IPv6 addresses
1344&nbsp;                            _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_tmp[4]}
1345&nbsp;                    ;;
1346&nbsp;
1347&nbsp;                    CNAME) # Alias name record
1348&nbsp;                           # Nickname
1349&nbsp;                        if _den_str=$(name_fixup ${_den_tmp[0]})
1350&nbsp;                        then
1351&nbsp;                            _den_name[${#_den_name[@]}]=${_den_str}
1352&nbsp;                            _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' CNAME'
1353&nbsp;                            _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}
1354&nbsp;                        fi
1355&nbsp;                        # Hostname
1356&nbsp;                        if _den_str=$(name_fixup ${_den_tmp[4]})
1357&nbsp;                        then
1358&nbsp;                            _den_name[${#_den_name[@]}]=${_den_str}
1359&nbsp;                            _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' CHOST'
1360&nbsp;                            _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}
1361&nbsp;                        fi
1362&nbsp;                    ;;
1363&nbsp;#                   TXT)
1364&nbsp;#                   ;;
1365&nbsp;                    esac
1366&nbsp;                fi
1367&nbsp;            done
1368&nbsp;        else # Lookup error == 'A' record 'unknown address'
1369&nbsp;            _den_pair[${#_den_pair[@]}]='0.0.0.0 '${_den_who}
1370&nbsp;        fi
1371&nbsp;    done
1372&nbsp;
1373&nbsp;    # Control dot array growth.
1374&nbsp;    unique_lines _den_achn _den_achn      # Works best, all the same.
1375&nbsp;    edit_exact auth_chain _den_achn       # Works best, unique items.
1376&nbsp;    if [ ${#_den_achn[@]} -gt 0 ]
1377&nbsp;    then
1378&nbsp;        IFS=${NO_WSP}
1379&nbsp;        auth_chain=( ${auth_chain[@]} ${_den_achn[@]} )
1380&nbsp;        IFS=${WSP_IFS}
1381&nbsp;    fi
1382&nbsp;
1383&nbsp;    unique_lines _den_ref _den_ref      # Works best, all the same.
1384&nbsp;    edit_exact ref_chain _den_ref       # Works best, unique items.
1385&nbsp;    if [ ${#_den_ref[@]} -gt 0 ]
1386&nbsp;    then
1387&nbsp;        IFS=${NO_WSP}
1388&nbsp;        ref_chain=( ${ref_chain[@]} ${_den_ref[@]} )
1389&nbsp;        IFS=${WSP_IFS}
1390&nbsp;    fi
1391&nbsp;
1392&nbsp;    unique_lines _den_na _den_na
1393&nbsp;    edit_exact name_address _den_na
1394&nbsp;    if [ ${#_den_na[@]} -gt 0 ]
1395&nbsp;    then
1396&nbsp;        IFS=${NO_WSP}
1397&nbsp;        name_address=( ${name_address[@]} ${_den_na[@]} )
1398&nbsp;        IFS=${WSP_IFS}
1399&nbsp;    fi
1400&nbsp;
1401&nbsp;    unique_lines _den_ns _den_ns
1402&nbsp;    edit_exact name_srvc _den_ns
1403&nbsp;    if [ ${#_den_ns[@]} -gt 0 ]
1404&nbsp;    then
1405&nbsp;        IFS=${NO_WSP}
1406&nbsp;        name_srvc=( ${name_srvc[@]} ${_den_ns[@]} )
1407&nbsp;        IFS=${WSP_IFS}
1408&nbsp;    fi
1409&nbsp;
1410&nbsp;    unique_lines _den_nr _den_nr
1411&nbsp;    edit_exact name_resource _den_nr
1412&nbsp;    if [ ${#_den_nr[@]} -gt 0 ]
1413&nbsp;    then
1414&nbsp;        IFS=${NO_WSP}
1415&nbsp;        name_resource=( ${name_resource[@]} ${_den_nr[@]} )
1416&nbsp;        IFS=${WSP_IFS}
1417&nbsp;    fi
1418&nbsp;
1419&nbsp;    unique_lines _den_pc _den_pc
1420&nbsp;    edit_exact parent_child _den_pc
1421&nbsp;    if [ ${#_den_pc[@]} -gt 0 ]
1422&nbsp;    then
1423&nbsp;        IFS=${NO_WSP}
1424&nbsp;        parent_child=( ${parent_child[@]} ${_den_pc[@]} )
1425&nbsp;        IFS=${WSP_IFS}
1426&nbsp;    fi
1427&nbsp;
1428&nbsp;    # Update list known_pair (Address and Name).
1429&nbsp;    unique_lines _den_pair _den_pair
1430&nbsp;    edit_exact known_pair _den_pair
1431&nbsp;    if [ ${#_den_pair[@]} -gt 0 ]  # Anything new?
1432&nbsp;    then
1433&nbsp;        IFS=${NO_WSP}
1434&nbsp;        known_pair=( ${known_pair[@]} ${_den_pair[@]} )
1435&nbsp;        IFS=${WSP_IFS}
1436&nbsp;    fi
1437&nbsp;
1438&nbsp;    # Update list of reverse pairs.
1439&nbsp;    unique_lines _den_rev _den_rev
1440&nbsp;    edit_exact reverse_pair _den_rev
1441&nbsp;    if [ ${#_den_rev[@]} -gt 0 ]   # Anything new?
1442&nbsp;    then
1443&nbsp;        IFS=${NO_WSP}
1444&nbsp;        reverse_pair=( ${reverse_pair[@]} ${_den_rev[@]} )
1445&nbsp;        IFS=${WSP_IFS}
1446&nbsp;    fi
1447&nbsp;
1448&nbsp;    # Check indirection limit -- give up if reached.
1449&nbsp;    if ! _den_lmt=$(limit_chk ${1})
1450&nbsp;    then
1451&nbsp;        return 0
1452&nbsp;    fi
1453&nbsp;
1454&nbsp;    # Execution engine is LIFO. Order of pend operations is important.
1455&nbsp;    # Did we define any new addresses?
1456&nbsp;    unique_lines _den_address _den_address    # Scrub duplicates.
1457&nbsp;    edit_exact known_address _den_address     # Scrub already processed.
1458&nbsp;    edit_exact un_address _den_address        # Scrub already waiting.
1459&nbsp;    if [ ${#_den_address[@]} -gt 0 ]          # Anything new?
1460&nbsp;    then
1461&nbsp;        uc_address=( ${uc_address[@]} ${_den_address[@]} )
1462&nbsp;        pend_func expand_input_address ${_den_lmt}
1463&nbsp;        _trace_log[${#_trace_log[@]}]='# # # Added '${#_den_address[@]}' unchecked address(s). # # #'
1464&nbsp;    fi
1465&nbsp;
1466&nbsp;    # Did we find any new names?
1467&nbsp;    unique_lines _den_name _den_name          # Scrub duplicates.
1468&nbsp;    edit_exact known_name _den_name           # Scrub already processed.
1469&nbsp;    edit_exact uc_name _den_name              # Scrub already waiting.
1470&nbsp;    if [ ${#_den_name[@]} -gt 0 ]             # Anything new?
1471&nbsp;    then
1472&nbsp;        uc_name=( ${uc_name[@]} ${_den_name[@]} )
1473&nbsp;        pend_func expand_input_name ${_den_lmt}
1474&nbsp;        _trace_log[${#_trace_log[@]}]='# # # Added '${#_den_name[@]}' unchecked name(s). # # #'
1475&nbsp;    fi
1476&nbsp;    return 0
1477&nbsp;}
1478&nbsp;
1479&nbsp;# The parse-it-yourself delegation reply
1480&nbsp;# Input is the chk_address list.
1481&nbsp;# detail_each_address &#60;indirection_limit&#62;
1482&nbsp;detail_each_address() {
1483&nbsp;    [ ${#chk_address[@]} -gt 0 ] || return 0
1484&nbsp;    unique_lines chk_address chk_address
1485&nbsp;    edit_exact known_address chk_address
1486&nbsp;    if [ ${#chk_address[@]} -gt 0 ]
1487&nbsp;    then
1488&nbsp;        known_address=( ${known_address[@]} ${chk_address[@]} )
1489&nbsp;        unset chk_address[@]
1490&nbsp;    fi
1491&nbsp;    return 0
1492&nbsp;}
1493&nbsp;
1494&nbsp;# # # Application specific output functions # # #
1495&nbsp;
1496&nbsp;# Pretty print the known pairs.
1497&nbsp;report_pairs() {
1498&nbsp;    echo
1499&nbsp;    echo 'Known network pairs.'
1500&nbsp;    col_print known_pair 2 5 30
1501&nbsp;
1502&nbsp;    if [ ${#auth_chain[@]} -gt 0 ]
1503&nbsp;    then
1504&nbsp;        echo
1505&nbsp;        echo 'Known chain of authority.'
1506&nbsp;        col_print auth_chain 2 5 30 55
1507&nbsp;    fi
1508&nbsp;
1509&nbsp;    if [ ${#reverse_pair[@]} -gt 0 ]
1510&nbsp;    then
1511&nbsp;        echo
1512&nbsp;        echo 'Known reverse pairs.'
1513&nbsp;        col_print reverse_pair 2 5 55
1514&nbsp;    fi
1515&nbsp;    return 0
1516&nbsp;}
1517&nbsp;
1518&nbsp;# Check an address against the list of blacklist servers.
1519&nbsp;# A good place to capture for GraphViz: address-&#62;status(server(reports))
1520&nbsp;# check_lists &#60;ip_address&#62;
1521&nbsp;check_lists() {
1522&nbsp;    [ $# -eq 1 ] || return 1
1523&nbsp;    local -a _cl_fwd_addr
1524&nbsp;    local -a _cl_rev_addr
1525&nbsp;    local -a _cl_reply
1526&nbsp;    local -i _cl_rc
1527&nbsp;    local -i _ls_cnt
1528&nbsp;    local _cl_dns_addr
1529&nbsp;    local _cl_lkup
1530&nbsp;
1531&nbsp;    split_ip ${1} _cl_fwd_addr _cl_rev_addr
1532&nbsp;    _cl_dns_addr=$(dot_array _cl_rev_addr)'.'
1533&nbsp;    _ls_cnt=${#list_server[@]}
1534&nbsp;    echo '    Checking address '${1}
1535&nbsp;    for (( _cl = 0 ; _cl &#60; _ls_cnt ; _cl++ ))
1536&nbsp;    do
1537&nbsp;        _cl_lkup=${_cl_dns_addr}${list_server[${_cl}]}
1538&nbsp;        if short_text ${_cl_lkup} _cl_reply
1539&nbsp;        then
1540&nbsp;            if [ ${#_cl_reply[@]} -gt 0 ]
1541&nbsp;            then
1542&nbsp;                echo '        Records from '${list_server[${_cl}]}
1543&nbsp;                address_hits[${#address_hits[@]}]=${1}' '${list_server[${_cl}]}
1544&nbsp;                _hs_RC=2
1545&nbsp;                for (( _clr = 0 ; _clr &#60; ${#_cl_reply[@]} ; _clr++ ))
1546&nbsp;                do
1547&nbsp;                    echo '            '${_cl_reply[${_clr}]}
1548&nbsp;                done
1549&nbsp;            fi
1550&nbsp;        fi
1551&nbsp;    done
1552&nbsp;    return 0
1553&nbsp;}
1554&nbsp;
1555&nbsp;# # # The usual application glue # # #
1556&nbsp;
1557&nbsp;# Who did it?
1558&nbsp;credits() {
1559&nbsp;   echo
1560&nbsp;   echo 'Advanced Bash Scripting Guide: is_spammer.bash, v2, 2004-msz'
1561&nbsp;}
1562&nbsp;
1563&nbsp;# How to use it?
1564&nbsp;# (See also, "Quickstart" at end of script.)
1565&nbsp;usage() {
1566&nbsp;    cat &#60;&#60;-'_usage_statement_'
1567&nbsp;    The script is_spammer.bash requires either one or two arguments.
1568&nbsp;
1569&nbsp;    arg 1) May be one of:
1570&nbsp;        a) A domain name
1571&nbsp;        b) An IPv4 address
1572&nbsp;        c) The name of a file with any mix of names
1573&nbsp;           and addresses, one per line.
1574&nbsp;
1575&nbsp;    arg 2) May be one of:
1576&nbsp;        a) A Blacklist server domain name
1577&nbsp;        b) The name of a file with Blacklist server
1578&nbsp;           domain names, one per line.
1579&nbsp;        c) If not present, a default list of (free)
1580&nbsp;           Blacklist servers is used.
1581&nbsp;        d) If a filename of an empty, readable, file
1582&nbsp;           is given,
1583&nbsp;           Blacklist server lookup is disabled.
1584&nbsp;
1585&nbsp;    All script output is written to stdout.
1586&nbsp;
1587&nbsp;    Return codes: 0 -&#62; All OK, 1 -&#62; Script failure,
1588&nbsp;                  2 -&#62; Something is Blacklisted.
1589&nbsp;
1590&nbsp;    Requires the external program 'dig' from the 'bind-9'
1591&nbsp;    set of DNS programs.  See: http://www.isc.org
1592&nbsp;
1593&nbsp;    The domain name lookup depth limit defaults to 2 levels.
1594&nbsp;    Set the environment variable SPAMMER_LIMIT to change.
1595&nbsp;    SPAMMER_LIMIT=0 means 'unlimited'
1596&nbsp;
1597&nbsp;    Limit may also be set on the command line.
1598&nbsp;    If arg#1 is an integer, the limit is set to that value
1599&nbsp;    and then the above argument rules are applied.
1600&nbsp;
1601&nbsp;    Setting the environment variable 'SPAMMER_DATA' to a filename
1602&nbsp;    will cause the script to write a GraphViz graphic file.
1603&nbsp;
1604&nbsp;    For the development version;
1605&nbsp;    Setting the environment variable 'SPAMMER_TRACE' to a filename
1606&nbsp;    will cause the execution engine to log a function call trace.
1607&nbsp;
1608&nbsp;_usage_statement_
1609&nbsp;}
1610&nbsp;
1611&nbsp;# The default list of Blacklist servers:
1612&nbsp;# Many choices, see: http://www.spews.org/lists.html
1613&nbsp;
1614&nbsp;declare -a default_servers
1615&nbsp;# See: http://www.spamhaus.org (Conservative, well maintained)
1616&nbsp;default_servers[0]='sbl-xbl.spamhaus.org'
1617&nbsp;# See: http://ordb.org (Open mail relays)
1618&nbsp;default_servers[1]='relays.ordb.org'
1619&nbsp;# See: http://www.spamcop.net/ (You can report spammers here)
1620&nbsp;default_servers[2]='bl.spamcop.net'
1621&nbsp;# See: http://www.spews.org (An 'early detect' system)
1622&nbsp;default_servers[3]='l2.spews.dnsbl.sorbs.net'
1623&nbsp;# See: http://www.dnsbl.us.sorbs.net/using.shtml
1624&nbsp;default_servers[4]='dnsbl.sorbs.net'
1625&nbsp;# See: http://dsbl.org/usage (Various mail relay lists)
1626&nbsp;default_servers[5]='list.dsbl.org'
1627&nbsp;default_servers[6]='multihop.dsbl.org'
1628&nbsp;default_servers[7]='unconfirmed.dsbl.org'
1629&nbsp;
1630&nbsp;# User input argument #1
1631&nbsp;setup_input() {
1632&nbsp;    if [ -e ${1} ] &#38;&#38; [ -r ${1} ]  # Name of readable file
1633&nbsp;    then
1634&nbsp;        file_to_array ${1} uc_name
1635&nbsp;        echo 'Using filename &#62;'${1}'&#60; as input.'
1636&nbsp;    else
1637&nbsp;        if is_address ${1}          # IP address?
1638&nbsp;        then
1639&nbsp;            uc_address=( ${1} )
1640&nbsp;            echo 'Starting with address &#62;'${1}'&#60;'
1641&nbsp;        else                       # Must be a name.
1642&nbsp;            uc_name=( ${1} )
1643&nbsp;            echo 'Starting with domain name &#62;'${1}'&#60;'
1644&nbsp;        fi
1645&nbsp;    fi
1646&nbsp;    return 0
1647&nbsp;}
1648&nbsp;
1649&nbsp;# User input argument #2
1650&nbsp;setup_servers() {
1651&nbsp;    if [ -e ${1} ] &#38;&#38; [ -r ${1} ]  # Name of a readable file
1652&nbsp;    then
1653&nbsp;        file_to_array ${1} list_server
1654&nbsp;        echo 'Using filename &#62;'${1}'&#60; as blacklist server list.'
1655&nbsp;    else
1656&nbsp;        list_server=( ${1} )
1657&nbsp;        echo 'Using blacklist server &#62;'${1}'&#60;'
1658&nbsp;    fi
1659&nbsp;    return 0
1660&nbsp;}
1661&nbsp;
1662&nbsp;# User environment variable SPAMMER_TRACE
1663&nbsp;live_log_die() {
1664&nbsp;    if [ ${SPAMMER_TRACE:=} ]    # Wants trace log?
1665&nbsp;    then
1666&nbsp;        if [ ! -e ${SPAMMER_TRACE} ]
1667&nbsp;        then
1668&nbsp;            if ! touch ${SPAMMER_TRACE} 2&#62;/dev/null
1669&nbsp;            then
1670&nbsp;                pend_func echo $(printf '%q\n' \
1671&nbsp;                'Unable to create log file &#62;'${SPAMMER_TRACE}'&#60;')
1672&nbsp;                pend_release
1673&nbsp;                exit 1
1674&nbsp;            fi
1675&nbsp;            _log_file=${SPAMMER_TRACE}
1676&nbsp;            _pend_hook_=trace_logger
1677&nbsp;            _log_dump=dump_log
1678&nbsp;        else
1679&nbsp;            if [ ! -w ${SPAMMER_TRACE} ]
1680&nbsp;            then
1681&nbsp;                pend_func echo $(printf '%q\n' \
1682&nbsp;                'Unable to write log file &#62;'${SPAMMER_TRACE}'&#60;')
1683&nbsp;                pend_release
1684&nbsp;                exit 1
1685&nbsp;            fi
1686&nbsp;            _log_file=${SPAMMER_TRACE}
1687&nbsp;            echo '' &#62; ${_log_file}
1688&nbsp;            _pend_hook_=trace_logger
1689&nbsp;            _log_dump=dump_log
1690&nbsp;        fi
1691&nbsp;    fi
1692&nbsp;    return 0
1693&nbsp;}
1694&nbsp;
1695&nbsp;# User environment variable SPAMMER_DATA
1696&nbsp;data_capture() {
1697&nbsp;    if [ ${SPAMMER_DATA:=} ]    # Wants a data dump?
1698&nbsp;    then
1699&nbsp;        if [ ! -e ${SPAMMER_DATA} ]
1700&nbsp;       then
1701&nbsp;           if ! touch ${SPAMMER_DATA} 2&#62;/dev/null
1702&nbsp;           then
1703&nbsp;               pend_func echo $(printf '%q]n' \
1704&nbsp;               'Unable to create data output file &#62;'${SPAMMER_DATA}'&#60;')
1705&nbsp;               pend_release
1706&nbsp;               exit 1
1707&nbsp;           fi
1708&nbsp;           _dot_file=${SPAMMER_DATA}
1709&nbsp;           _dot_dump=dump_dot
1710&nbsp;       else
1711&nbsp;           if [ ! -w ${SPAMMER_DATA} ]
1712&nbsp;           then
1713&nbsp;               pend_func echo $(printf '%q\n' \
1714&nbsp;               'Unable to write data output file &#62;'${SPAMMER_DATA}'&#60;')
1715&nbsp;               pend_release
1716&nbsp;               exit 1
1717&nbsp;           fi
1718&nbsp;           _dot_file=${SPAMMER_DATA}
1719&nbsp;           _dot_dump=dump_dot
1720&nbsp;       fi
1721&nbsp;   fi
1722&nbsp;   return 0
1723&nbsp;
1724&nbsp;
1725&nbsp; Grope user specified arguments.
1726&nbsp;o_user_args() {
1727&nbsp;   if [ $# -gt 0 ] &#38;&#38; is_number $1
1728&nbsp;   then
1729&nbsp;       indirect=$1
1730&nbsp;       shift
1731&nbsp;   fi
1732&nbsp;
1733&nbsp;   case $# in                     # Did user treat us well?
1734&nbsp;       1)
1735&nbsp;           if ! setup_input $1    # Needs error checking.
1736&nbsp;           then
1737&nbsp;               pend_release
1738&nbsp;               $_log_dump
1739&nbsp;               exit 1
1740&nbsp;           fi
1741&nbsp;           list_server=( ${default_servers[@]} )
1742&nbsp;           _list_cnt=${#list_server[@]}
1743&nbsp;           echo 'Using default blacklist server list.'
1744&nbsp;           echo 'Search depth limit: '${indirect}
1745&nbsp;           ;;
1746&nbsp;       2)
1747&nbsp;           if ! setup_input $1    # Needs error checking.
1748&nbsp;           then
1749&nbsp;               pend_release
1750&nbsp;               $_log_dump
1751&nbsp;               exit 1
1752&nbsp;           fi
1753&nbsp;           if ! setup_servers $2  # Needs error checking.
1754&nbsp;           then
1755&nbsp;               pend_release
1756&nbsp;               $_log_dump
1757&nbsp;               exit 1
1758&nbsp;           fi
1759&nbsp;           echo 'Search depth limit: '${indirect}
1760&nbsp;           ;;
1761&nbsp;       *)
1762&nbsp;           pend_func usage
1763&nbsp;           pend_release
1764&nbsp;           $_log_dump
1765&nbsp;           exit 1
1766&nbsp;           ;;
1767&nbsp;   esac
1768&nbsp;   return 0
1769&nbsp;
1770&nbsp;
1771&nbsp; A general purpose debug tool.
1772&nbsp; list_array &#60;array_name&#62;
1773&nbsp;ist_array() {
1774&nbsp;   [ $# -eq 1 ] || return 1  # One argument required.
1775&nbsp;
1776&nbsp;   local -a _la_lines
1777&nbsp;   set -f
1778&nbsp;   local IFS=${NO_WSP}
1779&nbsp;   eval _la_lines=\(\ \$\{$1\[@\]\}\ \)
1780&nbsp;   echo
1781&nbsp;   echo "Element count "${#_la_lines[@]}" array "${1}
1782&nbsp;   local _ln_cnt=${#_la_lines[@]}
1783&nbsp;
1784&nbsp;   for (( _i = 0; _i &#60; ${_ln_cnt}; _i++ ))
1785&nbsp;   do
1786&nbsp;       echo 'Element '$_i' &#62;'${_la_lines[$_i]}'&#60;'
1787&nbsp;   done
1788&nbsp;   set +f
1789&nbsp;   return 0
1790&nbsp;
1791&nbsp;
1792&nbsp; # # 'Hunt the Spammer' program code # # #
1793&nbsp;end_init                               # Ready stack engine.
1794&nbsp;end_func credits                       # Last thing to print.
1795&nbsp;
1796&nbsp; # # Deal with user # # #
1797&nbsp;ive_log_die                            # Setup debug trace log.
1798&nbsp;ata_capture                            # Setup data capture file.
1799&nbsp;cho
1800&nbsp;do_user_args $@
1801&nbsp;
1802&nbsp;# # # Haven't exited yet - There is some hope # # #
1803&nbsp;# Discovery group - Execution engine is LIFO - pend
1804&nbsp;# in reverse order of execution.
1805&nbsp;_hs_RC=0                                # Hunt the Spammer return code
1806&nbsp;pend_mark
1807&nbsp;    pend_func report_pairs              # Report name-address pairs.
1808&nbsp;
1809&nbsp;    # The two detail_* are mutually recursive functions.
1810&nbsp;    # They also pend expand_* functions as required.
1811&nbsp;    # These two (the last of ???) exit the recursion.
1812&nbsp;    pend_func detail_each_address       # Get all resources of addresses.
1813&nbsp;    pend_func detail_each_name          # Get all resources of names.
1814&nbsp;
1815&nbsp;    #  The two expand_* are mutually recursive functions,
1816&nbsp;    #+ which pend additional detail_* functions as required.
1817&nbsp;    pend_func expand_input_address 1    # Expand input names by address.
1818&nbsp;    pend_func expand_input_name 1       # #xpand input addresses by name.
1819&nbsp;
1820&nbsp;    # Start with a unique set of names and addresses.
1821&nbsp;    pend_func unique_lines uc_address uc_address
1822&nbsp;    pend_func unique_lines uc_name uc_name
1823&nbsp;
1824&nbsp;    # Separate mixed input of names and addresses.
1825&nbsp;    pend_func split_input
1826&nbsp;pend_release
1827&nbsp;
1828&nbsp;# # # Pairs reported -- Unique list of IP addresses found
1829&nbsp;echo
1830&nbsp;_ip_cnt=${#known_address[@]}
1831&nbsp;if [ ${#list_server[@]} -eq 0 ]
1832&nbsp;then
1833&nbsp;    echo 'Blacklist server list empty, none checked.'
1834&nbsp;else
1835&nbsp;    if [ ${_ip_cnt} -eq 0 ]
1836&nbsp;    then
1837&nbsp;        echo 'Known address list empty, none checked.'
1838&nbsp;    else
1839&nbsp;        _ip_cnt=${_ip_cnt}-1   # Start at top.
1840&nbsp;        echo 'Checking Blacklist servers.'
1841&nbsp;        for (( _ip = _ip_cnt ; _ip &#62;= 0 ; _ip-- ))
1842&nbsp;        do
1843&nbsp;            pend_func check_lists $( printf '%q\n' ${known_address[$_ip]} )
1844&nbsp;        done
1845&nbsp;    fi
1846&nbsp;fi
1847&nbsp;pend_release
1848&nbsp;$_dot_dump                   # Graphics file dump
1849&nbsp;$_log_dump                   # Execution trace
1850&nbsp;echo
1851&nbsp;
1852&nbsp;
1853&nbsp;##############################
1854&nbsp;# Example output from script #
1855&nbsp;##############################
1856&nbsp;:&#60;&#60;-'_is_spammer_outputs_'
1857&nbsp;
1858&nbsp;./is_spammer.bash 0 web4.alojamentos7.com
1859&nbsp;
1860&nbsp;Starting with domain name &#62;web4.alojamentos7.com&#60;
1861&nbsp;Using default blacklist server list.
1862&nbsp;Search depth limit: 0
1863&nbsp;.:....::::...:::...:::.......::..::...:::.......::
1864&nbsp;Known network pairs.
1865&nbsp;    66.98.208.97             web4.alojamentos7.com.
1866&nbsp;    66.98.208.97             ns1.alojamentos7.com.
1867&nbsp;    69.56.202.147            ns2.alojamentos.ws.
1868&nbsp;    66.98.208.97             alojamentos7.com.
1869&nbsp;    66.98.208.97             web.alojamentos7.com.
1870&nbsp;    69.56.202.146            ns1.alojamentos.ws.
1871&nbsp;    69.56.202.146            alojamentos.ws.
1872&nbsp;    66.235.180.113           ns1.alojamentos.org.
1873&nbsp;    66.235.181.192           ns2.alojamentos.org.
1874&nbsp;    66.235.180.113           alojamentos.org.
1875&nbsp;    66.235.180.113           web6.alojamentos.org.
1876&nbsp;    216.234.234.30           ns1.theplanet.com.
1877&nbsp;    12.96.160.115            ns2.theplanet.com.
1878&nbsp;    216.185.111.52           mail1.theplanet.com.
1879&nbsp;    69.56.141.4              spooling.theplanet.com.
1880&nbsp;    216.185.111.40           theplanet.com.
1881&nbsp;    216.185.111.40           www.theplanet.com.
1882&nbsp;    216.185.111.52           mail.theplanet.com.
1883&nbsp;
1884&nbsp;Checking Blacklist servers.
1885&nbsp;    Checking address 66.98.208.97
1886&nbsp;        Records from dnsbl.sorbs.net
1887&nbsp;            "Spam Received See: http://www.dnsbl.sorbs.net/lookup.shtml?66.98.208.97"
1888&nbsp;    Checking address 69.56.202.147
1889&nbsp;    Checking address 69.56.202.146
1890&nbsp;    Checking address 66.235.180.113
1891&nbsp;    Checking address 66.235.181.192
1892&nbsp;    Checking address 216.185.111.40
1893&nbsp;    Checking address 216.234.234.30
1894&nbsp;    Checking address 12.96.160.115
1895&nbsp;    Checking address 216.185.111.52
1896&nbsp;    Checking address 69.56.141.4
1897&nbsp;
1898&nbsp;Advanced Bash Scripting Guide: is_spammer.bash, v2, 2004-msz
1899&nbsp;
1900&nbsp;_is_spammer_outputs_
1901&nbsp;
1902&nbsp;exit ${_hs_RC}
1903&nbsp;
1904&nbsp;####################################################
1905&nbsp;#  The script ignores everything from here on down #
1906&nbsp;#+ because of the 'exit' command, just above.      #
1907&nbsp;####################################################
1908&nbsp;
1909&nbsp;
1910&nbsp;
1911&nbsp;Quickstart
1912&nbsp;==========
1913&nbsp;
1914&nbsp; Prerequisites
1915&nbsp;
1916&nbsp;  Bash version 2.05b or 3.00 (bash --version)
1917&nbsp;  A version of Bash which supports arrays. Array 
1918&nbsp;  support is included by default Bash configurations.
1919&nbsp;
1920&nbsp;  'dig,' version 9.x.x (dig $HOSTNAME, see first line of output)
1921&nbsp;  A version of dig which supports the +short options. 
1922&nbsp;  See: dig_wrappers.bash for details.
1923&nbsp;
1924&nbsp;
1925&nbsp; Optional Prerequisites
1926&nbsp;
1927&nbsp;  'named,' a local DNS caching program. Any flavor will do.
1928&nbsp;  Do twice: dig $HOSTNAME 
1929&nbsp;  Check near bottom of output for: SERVER: 127.0.0.1#53
1930&nbsp;  That means you have one running.
1931&nbsp;
1932&nbsp;
1933&nbsp; Optional Graphics Support
1934&nbsp;
1935&nbsp;  'date,' a standard *nix thing. (date -R)
1936&nbsp;
1937&nbsp;  dot Program to convert graphic description file to a 
1938&nbsp;  diagram. (dot -V)
1939&nbsp;  A part of the Graph-Viz set of programs.
1940&nbsp;  See: [http://www.research.att.com/sw/tools/graphviz||GraphViz]
1941&nbsp;
1942&nbsp;  'dotty,' a visual editor for graphic description files.
1943&nbsp;  Also a part of the Graph-Viz set of programs.
1944&nbsp;
1945&nbsp;
1946&nbsp;
1947&nbsp;
1948&nbsp; Quick Start
1949&nbsp;
1950&nbsp;In the same directory as the is_spammer.bash script; 
1951&nbsp;Do: ./is_spammer.bash
1952&nbsp;
1953&nbsp; Usage Details
1954&nbsp;
1955&nbsp;1. Blacklist server choices.
1956&nbsp;
1957&nbsp;  (a) To use default, built-in list: Do nothing.
1958&nbsp;
1959&nbsp;  (b) To use your own list: 
1960&nbsp;
1961&nbsp;    i. Create a file with a single Blacklist server 
1962&nbsp;       domain name per line.
1963&nbsp;
1964&nbsp;    ii. Provide that filename as the last argument to 
1965&nbsp;        the script.
1966&nbsp;
1967&nbsp;  (c) To use a single Blacklist server: Last argument 
1968&nbsp;      to the script.
1969&nbsp;
1970&nbsp;  (d) To disable Blacklist lookups:
1971&nbsp;
1972&nbsp;    i. Create an empty file (touch spammer.nul)
1973&nbsp;       Your choice of filename.
1974&nbsp;
1975&nbsp;    ii. Provide the filename of that empty file as the 
1976&nbsp;        last argument to the script.
1977&nbsp;
1978&nbsp;2. Search depth limit.
1979&nbsp;
1980&nbsp;  (a) To use the default value of 2: Do nothing.
1981&nbsp;
1982&nbsp;  (b) To set a different limit: 
1983&nbsp;      A limit of 0 means: no limit.
1984&nbsp;
1985&nbsp;    i. export SPAMMER_LIMIT=1
1986&nbsp;       or whatever limit you want.
1987&nbsp;
1988&nbsp;    ii. OR provide the desired limit as the first 
1989&nbsp;       argument to the script.
1990&nbsp;
1991&nbsp;3. Optional execution trace log.
1992&nbsp;
1993&nbsp;  (a) To use the default setting of no log output: Do nothing.
1994&nbsp;
1995&nbsp;  (b) To write an execution trace log:
1996&nbsp;      export SPAMMER_TRACE=spammer.log
1997&nbsp;      or whatever filename you want.
1998&nbsp;
1999&nbsp;4. Optional graphic description file.
2000&nbsp;
2001&nbsp;  (a) To use the default setting of no graphic file: Do nothing.
2002&nbsp;
2003&nbsp;  (b) To write a Graph-Viz graphic description file:
2004&nbsp;      export SPAMMER_DATA=spammer.dot
2005&nbsp;      or whatever filename you want.
2006&nbsp;
2007&nbsp;5. Where to start the search.
2008&nbsp;
2009&nbsp;  (a) Starting with a single domain name:
2010&nbsp;
2011&nbsp;    i. Without a command line search limit: First 
2012&nbsp;       argument to script.
2013&nbsp;
2014&nbsp;    ii. With a command line search limit: Second 
2015&nbsp;        argument to script.
2016&nbsp;
2017&nbsp;  (b) Starting with a single IP address:
2018&nbsp;
2019&nbsp;    i. Without a command line search limit: First 
2020&nbsp;       argument to script.
2021&nbsp;
2022&nbsp;    ii. With a command line search limit: Second 
2023&nbsp;        argument to script.
2024&nbsp;
2025&nbsp;  (c) Starting with (mixed) multiple name(s) and/or address(es):
2026&nbsp;      Create a file with one name or address per line.
2027&nbsp;      Your choice of filename.
2028&nbsp;
2029&nbsp;    i. Without a command line search limit: Filename as 
2030&nbsp;       first argument to script.
2031&nbsp;
2032&nbsp;    ii. With a command line search limit: Filename as 
2033&nbsp;        second argument to script.
2034&nbsp;
2035&nbsp;6. What to do with the display output.
2036&nbsp;
2037&nbsp;  (a) To view display output on screen: Do nothing.
2038&nbsp;
2039&nbsp;  (b) To save display output to a file: Redirect stdout to a filename.
2040&nbsp;
2041&nbsp;  (c) To discard display output: Redirect stdout to /dev/null.
2042&nbsp;
2043&nbsp;7. Temporary end of decision making. 
2044&nbsp;   press RETURN 
2045&nbsp;   wait (optionally, watch the dots and colons).
2046&nbsp;
2047&nbsp;8. Optionally check the return code.
2048&nbsp;
2049&nbsp;  (a) Return code 0: All OK
2050&nbsp;
2051&nbsp;  (b) Return code 1: Script setup failure
2052&nbsp;
2053&nbsp;  (c) Return code 2: Something was blacklisted.
2054&nbsp;
2055&nbsp;9. Where is my graph (diagram)?
2056&nbsp;
2057&nbsp;The script does not directly produce a graph (diagram). 
2058&nbsp;It only produces a graphic description file. You can 
2059&nbsp;process the graphic descriptor file that was output 
2060&nbsp;with the 'dot' program.
2061&nbsp;
2062&nbsp;Until you edit that descriptor file, to describe the 
2063&nbsp;relationships you want shown, all that you will get is 
2064&nbsp;a bunch of labeled name and address nodes.
2065&nbsp;
2066&nbsp;All of the script's discovered relationships are within 
2067&nbsp;a comment block in the graphic descriptor file, each 
2068&nbsp;with a descriptive heading.
2069&nbsp;
2070&nbsp;The editing required to draw a line between a pair of 
2071&nbsp;nodes from the information in the descriptor file may 
2072&nbsp;be done with a text editor. 
2073&nbsp;
2074&nbsp;Given these lines somewhere in the descriptor file:
2075&nbsp;
2076&nbsp;# Known domain name nodes
2077&nbsp;
2078&nbsp;N0000 [label="guardproof.info."] ;
2079&nbsp;
2080&nbsp;N0002 [label="third.guardproof.info."] ;
2081&nbsp;
2082&nbsp;
2083&nbsp;
2084&nbsp;# Known address nodes
2085&nbsp;
2086&nbsp;A0000 [label="61.141.32.197"] ;
2087&nbsp;
2088&nbsp;
2089&nbsp;
2090&nbsp;/*
2091&nbsp;
2092&nbsp;# Known name-&#62;address edges
2093&nbsp;
2094&nbsp;NA0000 third.guardproof.info. 61.141.32.197
2095&nbsp;
2096&nbsp;
2097&nbsp;
2098&nbsp;# Known parent-&#62;child edges
2099&nbsp;
2100&nbsp;PC0000 guardproof.info. third.guardproof.info.
2101&nbsp;
2102&nbsp; */
2103&nbsp;
2104&nbsp;Turn that into the following lines by substituting node 
2105&nbsp;identifiers into the relationships:
2106&nbsp;
2107&nbsp;# Known domain name nodes
2108&nbsp;
2109&nbsp;N0000 [label="guardproof.info."] ;
2110&nbsp;
2111&nbsp;N0002 [label="third.guardproof.info."] ;
2112&nbsp;
2113&nbsp;
2114&nbsp;
2115&nbsp;# Known address nodes
2116&nbsp;
2117&nbsp;A0000 [label="61.141.32.197"] ;
2118&nbsp;
2119&nbsp;
2120&nbsp;
2121&nbsp;# PC0000 guardproof.info. third.guardproof.info.
2122&nbsp;
2123&nbsp;N0000-&#62;N0002 ;
2124&nbsp;
2125&nbsp;
2126&nbsp;
2127&nbsp;# NA0000 third.guardproof.info. 61.141.32.197
2128&nbsp;
2129&nbsp;N0002-&#62;A0000 ;
2130&nbsp;
2131&nbsp;
2132&nbsp;
2133&nbsp;/*
2134&nbsp;
2135&nbsp;# Known name-&#62;address edges
2136&nbsp;
2137&nbsp;NA0000 third.guardproof.info. 61.141.32.197
2138&nbsp;
2139&nbsp;
2140&nbsp;
2141&nbsp;# Known parent-&#62;child edges
2142&nbsp;
2143&nbsp;PC0000 guardproof.info. third.guardproof.info.
2144&nbsp;
2145&nbsp; */
2146&nbsp;
2147&nbsp;Process that with the 'dot' program, and you have your 
2148&nbsp;first network diagram.
2149&nbsp;
2150&nbsp;In addition to the conventional graphic edges, the 
2151&nbsp;descriptor file includes similar format pair-data that 
2152&nbsp;describes services, zone records (sub-graphs?), 
2153&nbsp;blacklisted addresses, and other things which might be 
2154&nbsp;interesting to include in your graph. This additional 
2155&nbsp;information could be displayed as different node 
2156&nbsp;shapes, colors, line sizes, etc.
2157&nbsp;
2158&nbsp;The descriptor file can also be read and edited by a 
2159&nbsp;Bash script (of course). You should be able to find 
2160&nbsp;most of the functions required within the 
2161&nbsp;"is_spammer.bash" script.
2162&nbsp;
2163&nbsp;# End Quickstart.
2164&nbsp;
2165&nbsp;
2166&nbsp;
2167&nbsp;Additional Note
2168&nbsp;========== ====
2169&nbsp;
2170&nbsp;Michael Zick points out that there is a "makeviz.bash" interactive
2171&nbsp;Web site at rediris.es. Can't give the full URL, since this is not
2172&nbsp;a publically accessible site.</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>另一个阻挡垃圾邮件的脚本. </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="WHX"
></A
><P
><B
>例子 A-29. 垃圾邮件服务器猎手</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# whx.sh: "whois" spammer lookup
  3&nbsp;# Author: Walter Dnes
  4&nbsp;# Slight revisions (first section) by ABS Guide author.
  5&nbsp;# Used in ABS Guide with permission.
  6&nbsp;
  7&nbsp;# Needs version 3.x or greater of Bash to run (because of =~ operator).
  8&nbsp;# Commented by script author and ABS Guide author.
  9&nbsp;
 10&nbsp;
 11&nbsp;
 12&nbsp;E_BADARGS=65        # Missing command-line arg.
 13&nbsp;E_NOHOST=66         # Host not found.
 14&nbsp;E_TIMEOUT=67        # Host lookup timed out.
 15&nbsp;E_UNDEF=68          # Some other (undefined) error.
 16&nbsp;HOSTWAIT=10         # Specify up to 10 seconds for host query reply.
 17&nbsp;                    # The actual wait may be a bit longer.
 18&nbsp;OUTFILE=whois.txt   # Output file.
 19&nbsp;PORT=4321
 20&nbsp;
 21&nbsp;
 22&nbsp;if [ -z "$1" ]      # Check for (required) command-line arg.
 23&nbsp;then
 24&nbsp;  echo "Usage: $0 domain name or IP address"
 25&nbsp;  exit $E_BADARGS
 26&nbsp;fi
 27&nbsp;
 28&nbsp;
 29&nbsp;if [[ "$1" =~ "[a-zA-Z][a-zA-Z]$" ]]  # Ends in two alpha chars?
 30&nbsp;then                                  # It's a domain name &#38;&#38; must do host lookup.
 31&nbsp;  IPADDR=$(host -W $HOSTWAIT $1 | awk '{print $4}')
 32&nbsp;                                      # Doing host lookup to get IP address.
 33&nbsp;				      # Extract final field.
 34&nbsp;else
 35&nbsp;  IPADDR="$1"                         # Command-line arg was IP address.
 36&nbsp;fi
 37&nbsp;
 38&nbsp;echo; echo "IP Address is: "$IPADDR""; echo
 39&nbsp;
 40&nbsp;if [ -e "$OUTFILE" ]
 41&nbsp;then
 42&nbsp;  rm -f "$OUTFILE"
 43&nbsp;  echo "Stale output file \"$OUTFILE\" removed."; echo
 44&nbsp;fi
 45&nbsp;
 46&nbsp;
 47&nbsp;#  Sanity checks.
 48&nbsp;#  (This section needs more work.)
 49&nbsp;#  ===============================
 50&nbsp;if [ -z "$IPADDR" ]
 51&nbsp;# No response.
 52&nbsp;then
 53&nbsp;  echo "Host not found!"
 54&nbsp;  exit $E_NOHOST    # Bail out.
 55&nbsp;fi
 56&nbsp;
 57&nbsp;if [[ "$IPADDR" =~ "^[;;]" ]]
 58&nbsp;#  ;; connection timed out; no servers could be reached
 59&nbsp;then
 60&nbsp;  echo "Host lookup timed out!"
 61&nbsp;  exit $E_TIMEOUT   # Bail out.
 62&nbsp;fi
 63&nbsp;
 64&nbsp;if [[ "$IPADDR" =~ "[(NXDOMAIN)]$" ]]
 65&nbsp;#  Host xxxxxxxxx.xxx not found: 3(NXDOMAIN)
 66&nbsp;then
 67&nbsp;  echo "Host not found!"
 68&nbsp;  exit $E_NOHOST    # Bail out.
 69&nbsp;fi
 70&nbsp;
 71&nbsp;if [[ "$IPADDR" =~ "[(SERVFAIL)]$" ]]
 72&nbsp;#  Host xxxxxxxxx.xxx not found: 2(SERVFAIL)
 73&nbsp;then
 74&nbsp;  echo "Host not found!"
 75&nbsp;  exit $E_NOHOST    # Bail out.
 76&nbsp;fi
 77&nbsp;
 78&nbsp;
 79&nbsp;
 80&nbsp;
 81&nbsp;# ======================== Main body of script ========================
 82&nbsp;
 83&nbsp;AFRINICquery() {
 84&nbsp;#  Define the function that queries AFRINIC. Echo a notification to the
 85&nbsp;#+ screen, and then run the actual query, redirecting output to $OUTFILE.
 86&nbsp;
 87&nbsp;  echo "Searching for $IPADDR in whois.afrinic.net"
 88&nbsp;  whois -h whois.afrinic.net "$IPADDR" &#62; $OUTFILE
 89&nbsp;
 90&nbsp;#  Check for presence of reference to an rwhois.
 91&nbsp;#  Warn about non-functional rwhois.infosat.net server
 92&nbsp;#+ and attempt rwhois query.
 93&nbsp;  if grep -e "^remarks: .*rwhois\.[^ ]\+" "$OUTFILE"
 94&nbsp;  then
 95&nbsp;    echo " " &#62;&#62; $OUTFILE
 96&nbsp;    echo "***" &#62;&#62; $OUTFILE
 97&nbsp;    echo "***" &#62;&#62; $OUTFILE
 98&nbsp;    echo "Warning: rwhois.infosat.net was not working as of 2005/02/02" &#62;&#62; $OUTFILE
 99&nbsp;    echo "         when this script was written." &#62;&#62; $OUTFILE
100&nbsp;    echo "***" &#62;&#62; $OUTFILE
101&nbsp;    echo "***" &#62;&#62; $OUTFILE
102&nbsp;    echo " " &#62;&#62; $OUTFILE
103&nbsp;    RWHOIS=`grep "^remarks: .*rwhois\.[^ ]\+" "$OUTFILE" | tail -n 1 |\
104&nbsp;    sed "s/\(^.*\)\(rwhois\..*\)\(:4.*\)/\2/"`
105&nbsp;    whois -h ${RWHOIS}:${PORT} "$IPADDR" &#62;&#62; $OUTFILE
106&nbsp;  fi
107&nbsp;}
108&nbsp;
109&nbsp;APNICquery() {
110&nbsp;  echo "Searching for $IPADDR in whois.apnic.net"
111&nbsp;  whois -h whois.apnic.net "$IPADDR" &#62; $OUTFILE
112&nbsp;
113&nbsp;#  Just  about  every  country has its own internet registrar.
114&nbsp;#  I don't normally bother consulting them, because the regional registry
115&nbsp;#+ usually supplies sufficient information.
116&nbsp;#  There are a few exceptions, where the regional registry simply
117&nbsp;#+ refers to the national registry for direct data.
118&nbsp;#  These are Japan and South Korea in APNIC, and Brasil in LACNIC.
119&nbsp;#  The following if statement checks $OUTFILE (whois.txt) for the presence
120&nbsp;#+ of "KR" (South Korea) or "JP" (Japan) in the country field.
121&nbsp;#  If either is found, the query is re-run against the appropriate
122&nbsp;#+ national registry.
123&nbsp;
124&nbsp;  if grep -E "^country:[ ]+KR$" "$OUTFILE"
125&nbsp;  then
126&nbsp;    echo "Searching for $IPADDR in whois.krnic.net"
127&nbsp;    whois -h whois.krnic.net "$IPADDR" &#62;&#62; $OUTFILE
128&nbsp;  elif grep -E "^country:[ ]+JP$" "$OUTFILE"
129&nbsp;  then
130&nbsp;    echo "Searching for $IPADDR in whois.nic.ad.jp"
131&nbsp;    whois -h whois.nic.ad.jp "$IPADDR"/e &#62;&#62; $OUTFILE
132&nbsp;  fi
133&nbsp;}
134&nbsp;
135&nbsp;ARINquery() {
136&nbsp;  echo "Searching for $IPADDR in whois.arin.net"
137&nbsp;  whois -h whois.arin.net "$IPADDR" &#62; $OUTFILE
138&nbsp;
139&nbsp;#  Several large internet providers listed by ARIN have their own
140&nbsp;#+ internal whois service, referred to as "rwhois".
141&nbsp;#  A large block of IP addresses is listed with the provider
142&nbsp;#+ under the ARIN registry.
143&nbsp;#  To get the IP addresses of 2nd-level ISPs or other large customers,
144&nbsp;#+ one has to refer to the rwhois server on port 4321.
145&nbsp;#  I originally started with a bunch of "if" statements checking for
146&nbsp;#+ the larger providers.
147&nbsp;#  This approach is unwieldy, and there's always another rwhois server
148&nbsp;#+ that I didn't know about.
149&nbsp;#  A more elegant approach is to check $OUTFILE for a reference
150&nbsp;#+ to a whois server, parse that server name out of the comment section,
151&nbsp;#+ and re-run the query against the appropriate rwhois server.
152&nbsp;#  The parsing looks a bit ugly, with a long continued line inside
153&nbsp;#+ backticks.
154&nbsp;#  But it only has to be done once, and will work as new servers are added.
155&nbsp;#@   ABS Guide author comment: it isn't all that ugly, and is, in fact,
156&nbsp;#@+  an instructive use of Regular Expressions.
157&nbsp;
158&nbsp;  if grep -E "^Comment: .*rwhois.[^ ]+" "$OUTFILE"
159&nbsp;  then
160&nbsp;    RWHOIS=`grep -e "^Comment:.*rwhois\.[^ ]\+" "$OUTFILE" | tail -n 1 |\
161&nbsp;    sed "s/^\(.*\)\(rwhois\.[^ ]\+\)\(.*$\)/\2/"`
162&nbsp;    echo "Searching for $IPADDR in ${RWHOIS}"
163&nbsp;    whois -h ${RWHOIS}:${PORT} "$IPADDR" &#62;&#62; $OUTFILE
164&nbsp;  fi
165&nbsp;}
166&nbsp;
167&nbsp;LACNICquery() {
168&nbsp;  echo "Searching for $IPADDR in whois.lacnic.net"
169&nbsp;  whois -h whois.lacnic.net "$IPADDR" &#62; $OUTFILE
170&nbsp;
171&nbsp;#  The  following if statement checks $OUTFILE (whois.txt) for the presence of
172&nbsp;#+ "BR" (Brasil) in the country field.
173&nbsp;#  If it is found, the query is re-run against whois.registro.br.
174&nbsp;
175&nbsp;  if grep -E "^country:[ ]+BR$" "$OUTFILE"
176&nbsp;  then
177&nbsp;    echo "Searching for $IPADDR in whois.registro.br"
178&nbsp;    whois -h whois.registro.br "$IPADDR" &#62;&#62; $OUTFILE
179&nbsp;  fi
180&nbsp;}
181&nbsp;
182&nbsp;RIPEquery() {
183&nbsp;  echo "Searching for $IPADDR in whois.ripe.net"
184&nbsp;  whois -h whois.ripe.net "$IPADDR" &#62; $OUTFILE
185&nbsp;}
186&nbsp;
187&nbsp;#  Initialize a few variables.
188&nbsp;#  * slash8 is the most significant octet
189&nbsp;#  * slash16 consists of the two most significant octets
190&nbsp;#  * octet2 is the second most significant octet
191&nbsp;
192&nbsp;
193&nbsp;
194&nbsp;
195&nbsp;slash8=`echo $IPADDR | cut -d. -f 1`
196&nbsp;  if [ -z "$slash8" ]  # Yet another sanity check.
197&nbsp;  then
198&nbsp;    echo "Undefined error!"
199&nbsp;    exit $E_UNDEF
200&nbsp;  fi
201&nbsp;slash16=`echo $IPADDR | cut -d. -f 1-2`
202&nbsp;#                             ^ Period specified as 'cut" delimiter.
203&nbsp;  if [ -z "$slash16" ]
204&nbsp;  then
205&nbsp;    echo "Undefined error!"
206&nbsp;    exit $E_UNDEF
207&nbsp;  fi
208&nbsp;octet2=`echo $slash16 | cut -d. -f 2`
209&nbsp;  if [ -z "$octet2" ]
210&nbsp;  then
211&nbsp;    echo "Undefined error!"
212&nbsp;    exit $E_UNDEF
213&nbsp;  fi
214&nbsp;
215&nbsp;
216&nbsp;#  Check for various odds and ends of reserved space.
217&nbsp;#  There is no point in querying for those addresses.
218&nbsp;
219&nbsp;if [ $slash8 == 0 ]; then
220&nbsp;  echo $IPADDR is '"This Network"' space\; Not querying
221&nbsp;elif [ $slash8 == 10 ]; then
222&nbsp;  echo $IPADDR is RFC1918 space\; Not querying
223&nbsp;elif [ $slash8 == 14 ]; then
224&nbsp;  echo $IPADDR is '"Public Data Network"' space\; Not querying
225&nbsp;elif [ $slash8 == 127 ]; then
226&nbsp;  echo $IPADDR is loopback space\; Not querying
227&nbsp;elif [ $slash16 == 169.254 ]; then
228&nbsp;  echo $IPADDR is link-local space\; Not querying
229&nbsp;elif [ $slash8 == 172 ] &#38;&#38; [ $octet2 -ge 16 ] &#38;&#38; [ $octet2 -le 31 ];then
230&nbsp;  echo $IPADDR is RFC1918 space\; Not querying
231&nbsp;elif [ $slash16 == 192.168 ]; then
232&nbsp;  echo $IPADDR is RFC1918 space\; Not querying
233&nbsp;elif [ $slash8 -ge 224 ]; then
234&nbsp;  echo $IPADDR is either Multicast or reserved space\; Not querying
235&nbsp;elif [ $slash8 -ge 200 ] &#38;&#38; [ $slash8 -le 201 ]; then LACNICquery "$IPADDR"
236&nbsp;elif [ $slash8 -ge 202 ] &#38;&#38; [ $slash8 -le 203 ]; then APNICquery "$IPADDR"
237&nbsp;elif [ $slash8 -ge 210 ] &#38;&#38; [ $slash8 -le 211 ]; then APNICquery "$IPADDR"
238&nbsp;elif [ $slash8 -ge 218 ] &#38;&#38; [ $slash8 -le 223 ]; then APNICquery "$IPADDR"
239&nbsp;
240&nbsp;#  If we got this far without making a decision, query ARIN.
241&nbsp;#  If a reference is found in $OUTFILE to APNIC, AFRINIC, LACNIC, or RIPE,
242&nbsp;#+ query the appropriate whois server.
243&nbsp;
244&nbsp;else
245&nbsp;  ARINquery "$IPADDR"
246&nbsp;  if grep "whois.afrinic.net" "$OUTFILE"; then
247&nbsp;    AFRINICquery "$IPADDR"
248&nbsp;  elif grep -E "^OrgID:[ ]+RIPE$" "$OUTFILE"; then
249&nbsp;    RIPEquery "$IPADDR"
250&nbsp;  elif grep -E "^OrgID:[ ]+APNIC$" "$OUTFILE"; then
251&nbsp;    APNICquery "$IPADDR"
252&nbsp;  elif grep -E "^OrgID:[ ]+LACNIC$" "$OUTFILE"; then
253&nbsp;    LACNICquery "$IPADDR"
254&nbsp;  fi
255&nbsp;fi
256&nbsp;
257&nbsp;#@  ---------------------------------------------------------------
258&nbsp;#   Try also:
259&nbsp;#   wget http://logi.cc/nw/whois.php3?ACTION=doQuery&#38;DOMAIN=$IPADDR
260&nbsp;#@  ---------------------------------------------------------------
261&nbsp;
262&nbsp;#  We've  now  finished  the querying.
263&nbsp;#  Echo a copy of the final result to the screen.
264&nbsp;
265&nbsp;cat $OUTFILE
266&nbsp;# Or "less $OUTFILE" . . .
267&nbsp;
268&nbsp;
269&nbsp;exit 0
270&nbsp;
271&nbsp;#@  ABS Guide author comments:
272&nbsp;#@  Nothing fancy here, but still a very useful tool for hunting spammers.
273&nbsp;#@  Sure, the script can be cleaned up some, and it's still a bit buggy,
274&nbsp;#@+ (exercise for reader), but all the same, it's a nice piece of coding
275&nbsp;#@+ by Walter Dnes.
276&nbsp;#@  Thank you!</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
><SPAN
CLASS="QUOTE"
>"Little Monster的"</SPAN
>之前的<A
HREF="communications.html#WGETREF"
>wget</A
>. </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="WGETTER2"
></A
><P
><B
>例子 A-30. 使得<B
CLASS="COMMAND"
>wget</B
>更易用</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# wgetter2.bash
  3&nbsp;
  4&nbsp;# Author: Little Monster [monster@monstruum.co.uk]
  5&nbsp;# ==&#62; Used in ABS Guide with permission of script author.
  6&nbsp;# ==&#62; This script still needs debugging and fixups (exercise for reader).
  7&nbsp;# ==&#62; It could also use some additional editing in the comments.
  8&nbsp;
  9&nbsp;
 10&nbsp;#  This is wgetter2 --
 11&nbsp;#+ a Bash script to make wget a bit more friendly, and save typing.
 12&nbsp;
 13&nbsp;#  Carefully crafted by Little Monster.
 14&nbsp;#  More or less complete on 02/02/2005.
 15&nbsp;#  If you think this script can be improved,
 16&nbsp;#+ email me at: monster@monstruum.co.uk
 17&nbsp;# ==&#62; and cc: to the author of the ABS Guide, please.
 18&nbsp;#  This script is licenced under the GPL.
 19&nbsp;#  You are free to copy, alter and re-use it,
 20&nbsp;#+ but please don't try to claim you wrote it.
 21&nbsp;#  Log your changes here instead.
 22&nbsp;
 23&nbsp;# =======================================================================
 24&nbsp;# changelog:
 25&nbsp;
 26&nbsp;# 07/02/2005.  Fixups by Little Monster.
 27&nbsp;# 02/02/2005.  Minor additions by Little Monster.
 28&nbsp;#              (See after # +++++++++++ )
 29&nbsp;# 29/01/2005.  Minor stylistic edits and cleanups by author of ABS Guide.
 30&nbsp;#              Added exit error codes.
 31&nbsp;# 22/11/2004.  Finished initial version of second version of wgetter:
 32&nbsp;#              wgetter2 is born.
 33&nbsp;# 01/12/2004.  Changed 'runn' function so it can be run 2 ways --
 34&nbsp;#              either ask for a file name or have one input on the CL.
 35&nbsp;# 01/12/2004.  Made sensible handling of no URL's given.
 36&nbsp;# 01/12/2004.  Made loop of main options, so you don't
 37&nbsp;#              have to keep calling wgetter 2 all the time.
 38&nbsp;#              Runs as a session instead.
 39&nbsp;# 01/12/2004.  Added looping to 'runn' function.
 40&nbsp;#              Simplified and improved.
 41&nbsp;# 01/12/2004.  Added state to recursion setting.
 42&nbsp;#              Enables re-use of previous value.
 43&nbsp;# 05/12/2004.  Modified the file detection routine in the 'runn' function
 44&nbsp;#              so it's not fooled by empty values, and is cleaner.
 45&nbsp;# 01/02/2004.  Added cookie finding routine from later version (which 
 46&nbsp;#              isn't ready yet), so as not to have hard-coded paths.
 47&nbsp;# =======================================================================
 48&nbsp;
 49&nbsp;# Error codes for abnormal exit.
 50&nbsp;E_USAGE=67        # Usage message, then quit.
 51&nbsp;E_NO_OPTS=68      # No command-line args entered.
 52&nbsp;E_NO_URLS=69      # No URLs passed to script.
 53&nbsp;E_NO_SAVEFILE=70  # No save filename passed to script.
 54&nbsp;E_USER_EXIT=71    # User decides to quit.
 55&nbsp;
 56&nbsp;
 57&nbsp;#  Basic default wget command we want to use.
 58&nbsp;#  This is the place to change it, if required.
 59&nbsp;#  NB: if using a proxy, set http_proxy = yourproxy in .wgetrc.
 60&nbsp;#  Otherwise delete --proxy=on, below.
 61&nbsp;# ====================================================================
 62&nbsp;CommandA="wget -nc -c -t 5 --progress=bar --random-wait --proxy=on -r"
 63&nbsp;# ====================================================================
 64&nbsp;
 65&nbsp;
 66&nbsp;
 67&nbsp;# --------------------------------------------------------------------
 68&nbsp;# Set some other variables and explain them.
 69&nbsp;
 70&nbsp;pattern=" -A .jpg,.JPG,.jpeg,.JPEG,.gif,.GIF,.htm,.html,.shtml,.php"
 71&nbsp;                    # wget's option to only get certain types of file.
 72&nbsp;                    # comment out if not using
 73&nbsp;today=`date +%F`    # Used for a filename.
 74&nbsp;home=$HOME          # Set HOME to an internal variable.
 75&nbsp;                    # In case some other path is used, change it here.
 76&nbsp;depthDefault=3      # Set a sensible default recursion.
 77&nbsp;Depth=$depthDefault # Otherwise user feedback doesn't tie in properly.
 78&nbsp;RefA=""             # Set blank referring page.
 79&nbsp;Flag=""             #  Default to not saving anything,
 80&nbsp;                    #+ or whatever else might be wanted in future.
 81&nbsp;lister=""           # Used for passing a list of urls directly to wget.
 82&nbsp;Woptions=""         # Used for passing wget some options for itself.
 83&nbsp;inFile=""           # Used for the run function.
 84&nbsp;newFile=""          # Used for the run function.
 85&nbsp;savePath="$home/w-save"
 86&nbsp;Config="$home/.wgetter2rc"
 87&nbsp;                    #  This is where some variables can be stored, 
 88&nbsp;                    #+ if permanently changed from within the script.
 89&nbsp;Cookie_List="$home/.cookielist"
 90&nbsp;                    # So we know where the cookies are kept . . .
 91&nbsp;cFlag=""            # Part of the cookie file selection routine.
 92&nbsp;
 93&nbsp;# Define the options available. Easy to change letters here if needed.
 94&nbsp;# These are the optional options; you don't just wait to be asked.
 95&nbsp;
 96&nbsp;save=s   # Save command instead of executing it.
 97&nbsp;cook=c   # Change cookie file for this session.
 98&nbsp;help=h   # Usage guide.
 99&nbsp;list=l   # Pass wget the -i option and URL list.
100&nbsp;runn=r   # Run saved commands as an argument to the option.
101&nbsp;inpu=i   # Run saved commands interactively.
102&nbsp;wopt=w   # Allow to enter options to pass directly to wget.
103&nbsp;# --------------------------------------------------------------------
104&nbsp;
105&nbsp;
106&nbsp;if [ -z "$1" ]; then   # Make sure we get something for wget to eat.
107&nbsp;   echo "You must at least enter a URL or option!"
108&nbsp;   echo "-$help for usage."
109&nbsp;   exit $E_NO_OPTS
110&nbsp;fi
111&nbsp;
112&nbsp;
113&nbsp;
114&nbsp;# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
115&nbsp;# added added added added added added added added added added added added
116&nbsp;
117&nbsp;if [ ! -e "$Config" ]; then   # See if configuration file exists.
118&nbsp;   echo "Creating configuration file, $Config"
119&nbsp;   echo "# This is the configuration file for wgetter2" &#62; "$Config"
120&nbsp;   echo "# Your customised settings will be saved in this file" &#62;&#62; "$Config"
121&nbsp;else
122&nbsp;   source $Config             # Import variables we set outside the script.
123&nbsp;fi
124&nbsp;
125&nbsp;if [ ! -e "$Cookie_List" ]; then
126&nbsp;   # Set up a list of cookie files, if there isn't one.
127&nbsp;   echo "Hunting for cookies . . ."
128&nbsp;   find -name cookies.txt &#62;&#62; $Cookie_List   # Create the list of cookie files.
129&nbsp;fi #  Isolate this in its own 'if' statement,
130&nbsp;   #+ in case we got interrupted while searching.
131&nbsp;
132&nbsp;if [ -z "$cFlag" ]; then # If we haven't already done this . . .
133&nbsp;   echo                  # Make a nice space after the command prompt.
134&nbsp;   echo "Looks like you haven't set up your source of cookies yet."
135&nbsp;   n=0                   # Make sure the counter doesn't contain random values.
136&nbsp;   while read; do
137&nbsp;      Cookies[$n]=$REPLY # Put the cookie files we found into an array.
138&nbsp;      echo "$n) ${Cookies[$n]}"  # Create a menu.
139&nbsp;      n=$(( n + 1 ))     # Increment the counter.
140&nbsp;   done &#60; $Cookie_List   # Feed the read statement.
141&nbsp;   echo "Enter the number of the cookie file you want to use."
142&nbsp;   echo "If you won't be using cookies, just press RETURN."
143&nbsp;   echo
144&nbsp;   echo "I won't be asking this again. Edit $Config"
145&nbsp;   echo "If you decide to change at a later date"
146&nbsp;   echo "or use the -${cook} option for per session changes."
147&nbsp;   read
148&nbsp;   if [ ! -z $REPLY ]; then   # User didn't just press return.
149&nbsp;      Cookie=" --load-cookies ${Cookies[$REPLY]}"
150&nbsp;      # Set the variable here as well as in the config file.
151&nbsp;
152&nbsp;      echo "Cookie=\" --load-cookies ${Cookies[$REPLY]}\"" &#62;&#62; $Config
153&nbsp;   fi
154&nbsp;   echo "cFlag=1" &#62;&#62; $Config  # So we know not to ask again.
155&nbsp;fi
156&nbsp;
157&nbsp;# end added section end added section end added section end added section end
158&nbsp;# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
159&nbsp;
160&nbsp;
161&nbsp;
162&nbsp;# Another variable.
163&nbsp;# This one may or may not be subject to variation.
164&nbsp;# A bit like the small print.
165&nbsp;CookiesON=$Cookie
166&nbsp;# echo "cookie file is $CookiesON" # For debugging.
167&nbsp;# echo "home is ${home}"           # For debugging. Got caught with this one!
168&nbsp;
169&nbsp;
170&nbsp;wopts()
171&nbsp;{
172&nbsp;echo "Enter options to pass to wget."
173&nbsp;echo "It is assumed you know what you're doing."
174&nbsp;echo
175&nbsp;echo "You can pass their arguments here too."
176&nbsp;# That is to say, everything passed here is passed to wget.
177&nbsp;
178&nbsp;read Wopts
179&nbsp;# Read in the options to be passed to wget.
180&nbsp;
181&nbsp;Woptions=" $Wopts"
182&nbsp;# Assign to another variable.
183&nbsp;# Just for fun, or something . . .
184&nbsp;
185&nbsp;echo "passing options ${Wopts} to wget"
186&nbsp;# Mainly for debugging.
187&nbsp;# Is cute.
188&nbsp;
189&nbsp;return
190&nbsp;}
191&nbsp;
192&nbsp;
193&nbsp;save_func()
194&nbsp;{
195&nbsp;echo "Settings will be saved."
196&nbsp;if [ ! -d $savePath ]; then  #  See if directory exists.
197&nbsp;   mkdir $savePath           #  Create the directory to save things in
198&nbsp;                             #+ if it isn't already there.
199&nbsp;fi
200&nbsp;
201&nbsp;Flag=S
202&nbsp;# Tell the final bit of code what to do.
203&nbsp;# Set a flag since stuff is done in main.
204&nbsp;
205&nbsp;return
206&nbsp;}
207&nbsp;
208&nbsp;
209&nbsp;usage() # Tell them how it works.
210&nbsp;{
211&nbsp;    echo "Welcome to wgetter.  This is a front end to wget."
212&nbsp;    echo "It will always run wget with these options:"
213&nbsp;    echo "$CommandA"
214&nbsp;    echo "and the pattern to match: $pattern (which you can change at the top of this script)."
215&nbsp;    echo "It will also ask you for recursion depth, and if you want to use a referring page."
216&nbsp;    echo "Wgetter accepts the following options:"
217&nbsp;    echo ""
218&nbsp;    echo "-$help : Display this help."
219&nbsp;    echo "-$save : Save the command to a file $savePath/wget-($today) instead of running it."
220&nbsp;    echo "-$runn : Run saved wget commands instead of starting a new one --"
221&nbsp;    echo "Enter filename as argument to this option."
222&nbsp;    echo "-$inpu : Run saved wget commands interactively --"
223&nbsp;    echo "The script will ask you for the filename."
224&nbsp;    echo "-$cook : Change the cookies file for this session."
225&nbsp;    echo "-$list : Tell wget to use URL's from a list instead of from the command line."
226&nbsp;    echo "-$wopt : Pass any other options direct to wget."
227&nbsp;    echo ""
228&nbsp;    echo "See the wget man page for additional options you can pass to wget."
229&nbsp;    echo ""
230&nbsp;
231&nbsp;    exit $E_USAGE  # End here. Don't process anything else.
232&nbsp;}
233&nbsp;
234&nbsp;
235&nbsp;
236&nbsp;list_func() #  Gives the user the option to use the -i option to wget,
237&nbsp;            #+ and a list of URLs.
238&nbsp;{
239&nbsp;while [ 1 ]; do
240&nbsp;   echo "Enter the name of the file containing URL's (press q to change your 
241&nbsp;mind)."
242&nbsp;   read urlfile
243&nbsp;   if [ ! -e "$urlfile" ] &#38;&#38; [ "$urlfile" != q ]; then
244&nbsp;       # Look for a file, or the quit option.
245&nbsp;       echo "That file does not exist!"
246&nbsp;   elif [ "$urlfile" = q ]; then # Check quit option.
247&nbsp;       echo "Not using a url list."
248&nbsp;       return
249&nbsp;   else
250&nbsp;      echo "using $urlfile."
251&nbsp;      echo "If you gave me url's on the command line, I'll use those first."
252&nbsp;                            # Report wget standard behaviour to the user.
253&nbsp;      lister=" -i $urlfile" # This is what we want to pass to wget.
254&nbsp;      return
255&nbsp;   fi
256&nbsp;done
257&nbsp;}
258&nbsp;
259&nbsp;
260&nbsp;cookie_func() # Give the user the option to use a different cookie file.
261&nbsp;{
262&nbsp;while [ 1 ]; do
263&nbsp;   echo "Change the cookies file. Press return if you don't want to change 
264&nbsp;it."
265&nbsp;   read Cookies
266&nbsp;   # NB: this is not the same as Cookie, earlier.
267&nbsp;   # There is an 's' on the end.
268&nbsp;   # Bit like chocolate chips.
269&nbsp;   if [ -z "$Cookies" ]; then                 # Escape clause for wusses.
270&nbsp;      return
271&nbsp;   elif [ ! -e "$Cookies" ]; then
272&nbsp;      echo "File does not exist.  Try again." # Keep em going . . .
273&nbsp;   else
274&nbsp;       CookiesON=" --load-cookies $Cookies"   # File is good -- let's use it!
275&nbsp;       return
276&nbsp;   fi
277&nbsp;done
278&nbsp;}
279&nbsp;
280&nbsp;
281&nbsp;
282&nbsp;run_func()
283&nbsp;{
284&nbsp;if [ -z "$OPTARG" ]; then
285&nbsp;# Test to see if we used the in-line option or the query one.
286&nbsp;   if [ ! -d "$savePath" ]; then      # In case directory doesn't exist . . .
287&nbsp;      echo "$savePath does not appear to exist."
288&nbsp;      echo "Please supply path and filename of saved wget commands:"
289&nbsp;      read newFile
290&nbsp;         until [ -f "$newFile" ]; do  # Keep going till we get something.
291&nbsp;            echo "Sorry, that file does not exist.  Please try again."
292&nbsp;            # Try really hard to get something.
293&nbsp;            read newFile
294&nbsp;         done
295&nbsp;
296&nbsp;
297&nbsp;# -------------------------------------------------------------------------
298&nbsp;#         if [ -z ( grep wget ${newfile} ) ]; then
299&nbsp;          # Assume they haven't got the right file and bail out.
300&nbsp;#         echo "Sorry, that file does not contain wget commands.  Aborting."
301&nbsp;#         exit
302&nbsp;#         fi
303&nbsp;#
304&nbsp;# This is bogus code.
305&nbsp;# It doesn't actually work.
306&nbsp;# If anyone wants to fix it, feel free!
307&nbsp;# -------------------------------------------------------------------------
308&nbsp;
309&nbsp;
310&nbsp;      filePath="${newFile}"
311&nbsp;   else
312&nbsp;   echo "Save path is $savePath"
313&nbsp;      echo "Please enter name of the file which you want to use."
314&nbsp;      echo "You have a choice of:"
315&nbsp;      ls $savePath                                    # Give them a choice.
316&nbsp;      read inFile
317&nbsp;         until [ -f "$savePath/$inFile" ]; do         # Keep going till we get something.
318&nbsp;            if [ ! -f "${savePath}/${inFile}" ]; then # If file doesn't exist.
319&nbsp;               echo "Sorry, that file does not exist.  Please choose from:"
320&nbsp;               ls $savePath                           # If a mistake is made.
321&nbsp;               read inFile
322&nbsp;            fi
323&nbsp;         done
324&nbsp;      filePath="${savePath}/${inFile}"  # Make one variable . . .
325&nbsp;   fi
326&nbsp;else filePath="${savePath}/${OPTARG}"   # Which can be many things . . .
327&nbsp;fi
328&nbsp;
329&nbsp;if [ ! -f "$filePath" ]; then           # If a bogus file got through.
330&nbsp;   echo "You did not specify a suitable file."
331&nbsp;   echo "Run this script with the -${save} option first."
332&nbsp;   echo "Aborting."
333&nbsp;   exit $E_NO_SAVEFILE
334&nbsp;fi
335&nbsp;echo "Using: $filePath"
336&nbsp;while read; do
337&nbsp;    eval $REPLY
338&nbsp;    echo "Completed: $REPLY"
339&nbsp;done &#60; $filePath  # Feed the actual file we are using into a 'while' loop.
340&nbsp;
341&nbsp;exit
342&nbsp;}
343&nbsp;
344&nbsp;
345&nbsp;
346&nbsp;# Fish out any options we are using for the script.
347&nbsp;# This is based on the demo in "Learning The Bash Shell" (O'Reilly).
348&nbsp;while getopts ":$save$cook$help$list$runn:$inpu$wopt" opt
349&nbsp;do
350&nbsp;  case $opt in
351&nbsp;     $save) save_func;;   #  Save some wgetter sessions for later.
352&nbsp;     $cook) cookie_func;; #  Change cookie file.
353&nbsp;     $help) usage;;       #  Get help.
354&nbsp;     $list) list_func;;   #  Allow wget to use a list of URLs.
355&nbsp;     $runn) run_func;;    #  Useful if you are calling wgetter from, for example,
356&nbsp;                          #+ a cron script.
357&nbsp;     $inpu) run_func;;    #  When you don't know what your files are named.
358&nbsp;     $wopt) wopts;;       #  Pass options directly to wget.
359&nbsp;        \?) echo "Not a valid option."
360&nbsp;            echo "Use -${wopt} if you want to pass options directly to wget,"
361&nbsp;            echo "or -${help} for help";;      # Catch anything else.
362&nbsp;  esac
363&nbsp;done
364&nbsp;shift $((OPTIND - 1))     # Do funky magic stuff with $#.
365&nbsp;
366&nbsp;
367&nbsp;if [ -z "$1" ] &#38;&#38; [ -z "$lister" ]; then
368&nbsp;                          #  We should be left with at least one URL
369&nbsp;                          #+ on the command line, unless a list is 
370&nbsp;			  #+ being used -- catch empty CL's.
371&nbsp;   echo "No URL's given!  You must enter them on the same line as wgetter2."
372&nbsp;   echo "E.g.,  wgetter2 http://somesite http://anothersite."
373&nbsp;   echo "Use $help option for more information."
374&nbsp;   exit $E_NO_URLS        # Bail out, with appropriate error code.
375&nbsp;fi
376&nbsp;
377&nbsp;URLS=" $@"
378&nbsp;# Use this so that URL list can be changed if we stay in the option loop.
379&nbsp;
380&nbsp;while [ 1 ]; do
381&nbsp;   # This is where we ask for the most used options.
382&nbsp;   # (Mostly unchanged from version 1 of wgetter)
383&nbsp;   if [ -z $curDepth ]; then
384&nbsp;      Current=""
385&nbsp;   else Current=" Current value is $curDepth"
386&nbsp;   fi
387&nbsp;       echo "How deep should I go? (integer: Default is $depthDefault.$Current)"
388&nbsp;       read Depth   # Recursion -- how far should we go?
389&nbsp;       inputB=""    # Reset this to blank on each pass of the loop.
390&nbsp;       echo "Enter the name of the referring page (default is none)."
391&nbsp;       read inputB  # Need this for some sites.
392&nbsp;
393&nbsp;       echo "Do you want to have the output logged to the terminal"
394&nbsp;       echo "(y/n, default is yes)?"
395&nbsp;       read noHide  # Otherwise wget will just log it to a file.
396&nbsp;
397&nbsp;       case $noHide in    # Now you see me, now you don't.
398&nbsp;          y|Y ) hide="";;
399&nbsp;          n|N ) hide=" -b";;
400&nbsp;            * ) hide="";;
401&nbsp;       esac
402&nbsp;
403&nbsp;       if [ -z ${Depth} ]; then       #  User accepted either default or current depth,
404&nbsp;                                      #+ in which case Depth is now empty.
405&nbsp;          if [ -z ${curDepth} ]; then #  See if a depth was set on a previous iteration.
406&nbsp;             Depth="$depthDefault"    #  Set the default recursion depth if nothing
407&nbsp;                                      #+ else to use.
408&nbsp;          else Depth="$curDepth"      #  Otherwise, set the one we used before.
409&nbsp;          fi
410&nbsp;       fi
411&nbsp;   Recurse=" -l $Depth"               # Set how deep we want to go.
412&nbsp;   curDepth=$Depth                    # Remember setting for next time.
413&nbsp;
414&nbsp;       if [ ! -z $inputB ]; then
415&nbsp;          RefA=" --referer=$inputB"   # Option to use referring page.
416&nbsp;       fi
417&nbsp;
418&nbsp;   WGETTER="${CommandA}${pattern}${hide}${RefA}${Recurse}${CookiesON}${lister}${Woptions}${URLS}"
419&nbsp;   #  Just string the whole lot together . . .
420&nbsp;   #  NB: no embedded spaces.
421&nbsp;   #  They are in the individual elements so that if any are empty,
422&nbsp;   #+ we don't get an extra space.
423&nbsp;
424&nbsp;   if [ -z "${CookiesON}" ] &#38;&#38; [ "$cFlag" = "1" ] ; then
425&nbsp;       echo "Warning -- can't find cookie file"
426&nbsp;       # This should be changed, in case the user has opted to not use cookies.
427&nbsp;   fi
428&nbsp;
429&nbsp;   if [ "$Flag" = "S" ]; then
430&nbsp;      echo "$WGETTER" &#62;&#62; $savePath/wget-${today}
431&nbsp;      #  Create a unique filename for today, or append to it if it exists.
432&nbsp;      echo "$inputB" &#62;&#62; $savePath/site-list-${today}
433&nbsp;      #  Make a list, so it's easy to refer back to,
434&nbsp;      #+ since the whole command is a bit confusing to look at.
435&nbsp;      echo "Command saved to the file $savePath/wget-${today}"
436&nbsp;           # Tell the user.
437&nbsp;      echo "Referring page URL saved to the file $savePath/site-list-${today}"
438&nbsp;           # Tell the user.
439&nbsp;      Saver=" with save option"
440&nbsp;      # Stick this somewhere, so it appears in the loop if set.
441&nbsp;   else
442&nbsp;       echo "*****************"
443&nbsp;       echo "*****Getting*****"
444&nbsp;       echo "*****************"
445&nbsp;       echo ""
446&nbsp;       echo "$WGETTER"
447&nbsp;       echo ""
448&nbsp;       echo "*****************"
449&nbsp;       eval "$WGETTER"
450&nbsp;   fi
451&nbsp;
452&nbsp;       echo ""
453&nbsp;       echo "Starting over$Saver."
454&nbsp;       echo "If you want to stop, press q."
455&nbsp;       echo "Otherwise, enter some URL's:"
456&nbsp;       # Let them go again. Tell about save option being set.
457&nbsp;
458&nbsp;       read
459&nbsp;       case $REPLY in                # Need to change this to a 'trap' clause.
460&nbsp;          q|Q ) exit $E_USER_EXIT;;  # Exercise for the reader?
461&nbsp;            * ) URLS=" $REPLY";;
462&nbsp;       esac
463&nbsp;
464&nbsp;       echo ""
465&nbsp;done
466&nbsp;
467&nbsp;
468&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="BASHPODDER"
></A
><P
><B
>例子 A-31. 一个<SPAN
CLASS="QUOTE"
>"podcasting"</SPAN
>(译者: 指的是在互联网上发布音视频文件, 并允许用户订阅并自动接收的方法)脚本</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;
  3&nbsp;# bashpodder.sh:
  4&nbsp;# By Linc 10/1/2004
  5&nbsp;# Find the latest script at http://linc.homeunix.org:8080/scripts/bashpodder
  6&nbsp;# Last revision 12/14/2004 - Many Contributors!
  7&nbsp;# If you use this and have made improvements or have comments
  8&nbsp;# drop me an email at linc dot fessenden at gmail dot com
  9&nbsp;# I'd appreciate it!
 10&nbsp;
 11&nbsp;# ==&#62;  ABS Guide extra comments.
 12&nbsp;
 13&nbsp;# ==&#62;  Author of this script has kindly granted permission
 14&nbsp;# ==&#62;+ for inclusion in ABS Guide.
 15&nbsp;
 16&nbsp;
 17&nbsp;# ==&#62; ################################################################
 18&nbsp;# 
 19&nbsp;# ==&#62; What is "podcasting"?
 20&nbsp;
 21&nbsp;# ==&#62; It's broadcasting "radio shows" over the Internet.
 22&nbsp;# ==&#62; These shows can be played on iPods and other music file players.
 23&nbsp;
 24&nbsp;# ==&#62; This script makes it possible.
 25&nbsp;# ==&#62; See documentation at the script author's site, above.
 26&nbsp;
 27&nbsp;# ==&#62; ################################################################
 28&nbsp;
 29&nbsp;
 30&nbsp;# Make script crontab friendly:
 31&nbsp;cd $(dirname $0)
 32&nbsp;# ==&#62; Change to directory where this script lives.
 33&nbsp;
 34&nbsp;# datadir is the directory you want podcasts saved to:
 35&nbsp;datadir=$(date +%Y-%m-%d)
 36&nbsp;# ==&#62; Will create a directory with the name: YYYY-MM-DD
 37&nbsp;
 38&nbsp;# Check for and create datadir if necessary:
 39&nbsp;if test ! -d $datadir
 40&nbsp;        then
 41&nbsp;        mkdir $datadir
 42&nbsp;fi
 43&nbsp;
 44&nbsp;# Delete any temp file:
 45&nbsp;rm -f temp.log
 46&nbsp;
 47&nbsp;# Read the bp.conf file and wget any url not already in the podcast.log file:
 48&nbsp;while read podcast
 49&nbsp;        do # ==&#62; Main action follows.
 50&nbsp;        file=$(wget -q $podcast -O - | tr '\r' '\n' | tr \' \" | sed -n 's/.*url="\([^"]*\)".*/\1/p')
 51&nbsp;        for url in $file
 52&nbsp;                do
 53&nbsp;                echo $url &#62;&#62; temp.log
 54&nbsp;                if ! grep "$url" podcast.log &#62; /dev/null
 55&nbsp;                        then
 56&nbsp;                        wget -q -P $datadir "$url"
 57&nbsp;                fi
 58&nbsp;                done
 59&nbsp;        done &#60; bp.conf
 60&nbsp;
 61&nbsp;# Move dynamically created log file to permanent log file:
 62&nbsp;cat podcast.log &#62;&#62; temp.log
 63&nbsp;sort temp.log | uniq &#62; podcast.log
 64&nbsp;rm temp.log
 65&nbsp;# Create an m3u playlist:
 66&nbsp;ls $datadir | grep -v m3u &#62; $datadir/podcast.m3u
 67&nbsp;
 68&nbsp;
 69&nbsp;exit 0
 70&nbsp;
 71&nbsp;#################################################
 72&nbsp;For a different scripting approach to Podcasting,
 73&nbsp;see Phil Salkie's article, 
 74&nbsp;"Internet Radio to Podcast with Shell Tools"
 75&nbsp;in the September, 2005 issue of LINUX JOURNAL,
 76&nbsp;http://www.linuxjournal.com/article/8171
 77&nbsp;#################################################</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>作为本小节的结尾, 让我们回顾一下基本概念 . . . 可能还有些扩展部分. </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="BASICSREVIEWED"
></A
><P
><B
>例子 A-32. 基础回顾</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# basics-reviewed.bash
  3&nbsp;
  4&nbsp;# File extension == *.bash == specific to Bash
  5&nbsp;
  6&nbsp;#   Copyright (c) Michael S. Zick, 2003; All rights reserved.
  7&nbsp;#   License: Use in any form, for any purpose.
  8&nbsp;#   Revision: $ID$
  9&nbsp;#
 10&nbsp;#              Edited for layout by M.C.
 11&nbsp;#   (author of the "Advanced Bash Scripting Guide")
 12&nbsp;
 13&nbsp;
 14&nbsp;#  This script tested under Bash versions 2.04, 2.05a and 2.05b.
 15&nbsp;#  It may not work with earlier versions.
 16&nbsp;#  This demonstration script generates one --intentional--
 17&nbsp;#+ "command not found" error message. See line 394.
 18&nbsp;
 19&nbsp;#  The current Bash maintainer, Chet Ramey, has fixed the items noted
 20&nbsp;#+ for an upcoming version of Bash.
 21&nbsp;
 22&nbsp;
 23&nbsp;
 24&nbsp;        ###-------------------------------------------###
 25&nbsp;        ###  Pipe the output of this script to 'more' ###
 26&nbsp;        ###+ else it will scroll off the page.        ###
 27&nbsp;        ###                                           ###
 28&nbsp;        ###  You may also redirect its output         ###
 29&nbsp;        ###+ to a file for examination.               ###  
 30&nbsp;        ###-------------------------------------------###
 31&nbsp;
 32&nbsp;
 33&nbsp;
 34&nbsp;#  Most of the following points are described at length in
 35&nbsp;#+ the text of the foregoing "Advanced Bash Scripting Guide."
 36&nbsp;#  This demonstration script is mostly just a reorganized presentation.
 37&nbsp;#      -- msz
 38&nbsp;
 39&nbsp;# Variables are not typed unless otherwise specified.
 40&nbsp;
 41&nbsp;#  Variables are named. Names must contain a non-digit.
 42&nbsp;#  File descriptor names (as in, for example: 2&#62;&#38;1)
 43&nbsp;#+ contain ONLY digits.
 44&nbsp;
 45&nbsp;# Parameters and Bash array elements are numbered.
 46&nbsp;# (Parameters are very similar to Bash arrays.)
 47&nbsp;
 48&nbsp;# A variable name may be undefined (null reference).
 49&nbsp;unset VarNull
 50&nbsp;
 51&nbsp;# A variable name may be defined but empty (null contents).
 52&nbsp;VarEmpty=''                         # Two, adjacent, single quotes.
 53&nbsp;
 54&nbsp;# A variable name my be defined and non-empty
 55&nbsp;VarSomething='Literal'
 56&nbsp;
 57&nbsp;# A variable may contain:
 58&nbsp;#   * A whole number as a signed 32-bit (or larger) integer
 59&nbsp;#   * A string
 60&nbsp;# A variable may also be an array.
 61&nbsp;
 62&nbsp;#  A string may contain embedded blanks and may be treated
 63&nbsp;#+ as if it where a function name with optional arguments.
 64&nbsp;
 65&nbsp;#  The names of variables and the names of functions
 66&nbsp;#+ are in different namespaces.
 67&nbsp;
 68&nbsp;
 69&nbsp;#  A variable may be defined as a Bash array either explicitly or
 70&nbsp;#+ implicitly by the syntax of the assignment statement.
 71&nbsp;#  Explicit:
 72&nbsp;declare -a ArrayVar
 73&nbsp;
 74&nbsp;
 75&nbsp;
 76&nbsp;# The echo command is a built-in.
 77&nbsp;echo $VarSomething
 78&nbsp;
 79&nbsp;# The printf command is a built-in.
 80&nbsp;# Translate %s as: String-Format
 81&nbsp;printf %s $VarSomething         # No linebreak specified, none output.
 82&nbsp;echo                            # Default, only linebreak output.
 83&nbsp;
 84&nbsp;
 85&nbsp;
 86&nbsp;
 87&nbsp;# The Bash parser word breaks on whitespace.
 88&nbsp;# Whitespace, or the lack of it is significant.
 89&nbsp;# (This holds true in general; there are, of course, exceptions.)
 90&nbsp;
 91&nbsp;
 92&nbsp;
 93&nbsp;
 94&nbsp;# Translate the DOLLAR_SIGN character as: Content-Of.
 95&nbsp;
 96&nbsp;# Extended-Syntax way of writing Content-Of:
 97&nbsp;echo ${VarSomething}
 98&nbsp;
 99&nbsp;#  The ${ ... } Extended-Syntax allows more than just the variable
100&nbsp;#+ name to be specified.
101&nbsp;#  In general, $VarSomething can always be written as: ${VarSomething}.
102&nbsp;
103&nbsp;# Call this script with arguments to see the following in action.
104&nbsp;
105&nbsp;
106&nbsp;
107&nbsp;#  Outside of double-quotes, the special characters @ and *
108&nbsp;#+ specify identical behavior.
109&nbsp;#  May be pronounced as: All-Elements-Of.
110&nbsp;
111&nbsp;#  Without specification of a name, they refer to the
112&nbsp;#+ pre-defined parameter Bash-Array.
113&nbsp;
114&nbsp;
115&nbsp;
116&nbsp;# Glob-Pattern references
117&nbsp;echo $*                         # All parameters to script or function
118&nbsp;echo ${*}                       # Same
119&nbsp;
120&nbsp;# Bash disables filename expansion for Glob-Patterns.
121&nbsp;# Only character matching is active.
122&nbsp;
123&nbsp;
124&nbsp;# All-Elements-Of references
125&nbsp;echo $@                         # Same as above
126&nbsp;echo ${@}                       # Same as above
127&nbsp;
128&nbsp;
129&nbsp;
130&nbsp;
131&nbsp;#  Within double-quotes, the behavior of Glob-Pattern references
132&nbsp;#+ depends on the setting of IFS (Input Field Separator).
133&nbsp;#  Within double-quotes, All-Elements-Of references behave the same.
134&nbsp;
135&nbsp;
136&nbsp;#  Specifying only the name of a variable holding a string refers
137&nbsp;#+ to all elements (characters) of a string.
138&nbsp;
139&nbsp;
140&nbsp;#  To specify an element (character) of a string,
141&nbsp;#+ the Extended-Syntax reference notation (see below) MAY be used.
142&nbsp;
143&nbsp;
144&nbsp;
145&nbsp;
146&nbsp;#  Specifying only the name of a Bash array references
147&nbsp;#+ the subscript zero element,
148&nbsp;#+ NOT the FIRST DEFINED nor the FIRST WITH CONTENTS element.
149&nbsp;
150&nbsp;#  Additional qualification is needed to reference other elements,
151&nbsp;#+ which means that the reference MUST be written in Extended-Syntax.
152&nbsp;#  The general form is: ${name[subscript]}.
153&nbsp;
154&nbsp;#  The string forms may also be used: ${name:subscript}
155&nbsp;#+ for Bash-Arrays when referencing the subscript zero element.
156&nbsp;
157&nbsp;
158&nbsp;# Bash-Arrays are implemented internally as linked lists,
159&nbsp;#+ not as a fixed area of storage as in some programming languages.
160&nbsp;
161&nbsp;
162&nbsp;#   Characteristics of Bash arrays (Bash-Arrays):
163&nbsp;#   --------------------------------------------
164&nbsp;
165&nbsp;#   If not otherwise specified, Bash-Array subscripts begin with
166&nbsp;#+  subscript number zero. Literally: [0]
167&nbsp;#   This is called zero-based indexing.
168&nbsp;###
169&nbsp;#   If not otherwise specified, Bash-Arrays are subscript packed
170&nbsp;#+  (sequential subscripts without subscript gaps).
171&nbsp;###
172&nbsp;#   Negative subscripts are not allowed.
173&nbsp;###
174&nbsp;#   Elements of a Bash-Array need not all be of the same type.
175&nbsp;###
176&nbsp;#   Elements of a Bash-Array may be undefined (null reference).
177&nbsp;#       That is, a Bash-Array my be "subscript sparse."
178&nbsp;###
179&nbsp;#   Elements of a Bash-Array may be defined and empty (null contents).
180&nbsp;###
181&nbsp;#   Elements of a Bash-Array may contain:
182&nbsp;#     * A whole number as a signed 32-bit (or larger) integer
183&nbsp;#     * A string
184&nbsp;#     * A string formated so that it appears to be a function name
185&nbsp;#     + with optional arguments
186&nbsp;###
187&nbsp;#   Defined elements of a Bash-Array may be undefined (unset).
188&nbsp;#       That is, a subscript packed Bash-Array may be changed
189&nbsp;#   +   into a subscript sparse Bash-Array.
190&nbsp;###
191&nbsp;#   Elements may be added to a Bash-Array by defining an element
192&nbsp;#+  not previously defined.
193&nbsp;###
194&nbsp;# For these reasons, I have been calling them "Bash-Arrays".
195&nbsp;# I'll return to the generic term "array" from now on.
196&nbsp;#     -- msz
197&nbsp;
198&nbsp;
199&nbsp;
200&nbsp;
201&nbsp;#  Demo time -- initialize the previously declared ArrayVar as a
202&nbsp;#+ sparse array.
203&nbsp;#  (The 'unset ... ' is just documentation here.)
204&nbsp;
205&nbsp;unset ArrayVar[0]                   # Just for the record
206&nbsp;ArrayVar[1]=one                     # Unquoted literal
207&nbsp;ArrayVar[2]=''                      # Defined, and empty
208&nbsp;unset ArrayVar[3]                   # Just for the record
209&nbsp;ArrayVar[4]='four'                  # Quoted literal
210&nbsp;
211&nbsp;
212&nbsp;
213&nbsp;# Translate the %q format as: Quoted-Respecting-IFS-Rules.
214&nbsp;echo
215&nbsp;echo '- - Outside of double-quotes - -'
216&nbsp;###
217&nbsp;printf %q ${ArrayVar[*]}            # Glob-Pattern All-Elements-Of
218&nbsp;echo
219&nbsp;echo 'echo command:'${ArrayVar[*]}
220&nbsp;###
221&nbsp;printf %q ${ArrayVar[@]}            # All-Elements-Of
222&nbsp;echo
223&nbsp;echo 'echo command:'${ArrayVar[@]}
224&nbsp;
225&nbsp;# The use of double-quotes may be translated as: Enable-Substitution.
226&nbsp;
227&nbsp;# There are five cases recognized for the IFS setting.
228&nbsp;
229&nbsp;echo
230&nbsp;echo '- - Within double-quotes - Default IFS of space-tab-newline - -'
231&nbsp;IFS=$'\x20'$'\x09'$'\x0A'           #  These three bytes,
232&nbsp;                                    #+ in exactly this order.
233&nbsp;
234&nbsp;
235&nbsp;printf %q "${ArrayVar[*]}"          # Glob-Pattern All-Elements-Of
236&nbsp;echo
237&nbsp;echo 'echo command:'"${ArrayVar[*]}"
238&nbsp;###
239&nbsp;printf %q "${ArrayVar[@]}"          # All-Elements-Of
240&nbsp;echo
241&nbsp;echo 'echo command:'"${ArrayVar[@]}"
242&nbsp;
243&nbsp;
244&nbsp;echo
245&nbsp;echo '- - Within double-quotes - First character of IFS is ^ - -'
246&nbsp;# Any printing, non-whitespace character should do the same.
247&nbsp;IFS='^'$IFS                         # ^ + space tab newline
248&nbsp;###
249&nbsp;printf %q "${ArrayVar[*]}"          # Glob-Pattern All-Elements-Of
250&nbsp;echo
251&nbsp;echo 'echo command:'"${ArrayVar[*]}"
252&nbsp;###
253&nbsp;printf %q "${ArrayVar[@]}"          # All-Elements-Of
254&nbsp;echo
255&nbsp;echo 'echo command:'"${ArrayVar[@]}"
256&nbsp;
257&nbsp;
258&nbsp;echo
259&nbsp;echo '- - Within double-quotes - Without whitespace in IFS - -'
260&nbsp;IFS='^:%!'
261&nbsp;###
262&nbsp;printf %q "${ArrayVar[*]}"          # Glob-Pattern All-Elements-Of
263&nbsp;echo
264&nbsp;echo 'echo command:'"${ArrayVar[*]}"
265&nbsp;###
266&nbsp;printf %q "${ArrayVar[@]}"          # All-Elements-Of
267&nbsp;echo
268&nbsp;echo 'echo command:'"${ArrayVar[@]}"
269&nbsp;
270&nbsp;
271&nbsp;echo
272&nbsp;echo '- - Within double-quotes - IFS set and empty - -'
273&nbsp;IFS=''
274&nbsp;###
275&nbsp;printf %q "${ArrayVar[*]}"          # Glob-Pattern All-Elements-Of
276&nbsp;echo
277&nbsp;echo 'echo command:'"${ArrayVar[*]}"
278&nbsp;###
279&nbsp;printf %q "${ArrayVar[@]}"          # All-Elements-Of
280&nbsp;echo
281&nbsp;echo 'echo command:'"${ArrayVar[@]}"
282&nbsp;
283&nbsp;
284&nbsp;echo
285&nbsp;echo '- - Within double-quotes - IFS undefined - -'
286&nbsp;unset IFS
287&nbsp;###
288&nbsp;printf %q "${ArrayVar[*]}"          # Glob-Pattern All-Elements-Of
289&nbsp;echo
290&nbsp;echo 'echo command:'"${ArrayVar[*]}"
291&nbsp;###
292&nbsp;printf %q "${ArrayVar[@]}"          # All-Elements-Of
293&nbsp;echo
294&nbsp;echo 'echo command:'"${ArrayVar[@]}"
295&nbsp;
296&nbsp;
297&nbsp;# Put IFS back to the default.
298&nbsp;# Default is exactly these three bytes.
299&nbsp;IFS=$'\x20'$'\x09'$'\x0A'           # In exactly this order.
300&nbsp;
301&nbsp;# Interpretation of the above outputs:
302&nbsp;#   A Glob-Pattern is I/O; the setting of IFS matters.
303&nbsp;###
304&nbsp;#   An All-Elements-Of does not consider IFS settings.
305&nbsp;###
306&nbsp;#   Note the different output using the echo command and the
307&nbsp;#+  quoted format operator of the printf command.
308&nbsp;
309&nbsp;
310&nbsp;#  Recall:
311&nbsp;#   Parameters are similar to arrays and have the similar behaviors.
312&nbsp;###
313&nbsp;#  The above examples demonstrate the possible variations.
314&nbsp;#  To retain the shape of a sparse array, additional script
315&nbsp;#+ programming is required.
316&nbsp;###
317&nbsp;#  The source code of Bash has a routine to output the
318&nbsp;#+ [subscript]=value   array assignment format.
319&nbsp;#  As of version 2.05b, that routine is not used,
320&nbsp;#+ but that might change in future releases.
321&nbsp;
322&nbsp;
323&nbsp;
324&nbsp;# The length of a string, measured in non-null elements (characters):
325&nbsp;echo
326&nbsp;echo '- - Non-quoted references - -'
327&nbsp;echo 'Non-Null character count: '${#VarSomething}' characters.'
328&nbsp;
329&nbsp;# test='Lit'$'\x00''eral'           # $'\x00' is a null character.
330&nbsp;# echo ${#test}                     # See that?
331&nbsp;
332&nbsp;
333&nbsp;
334&nbsp;#  The length of an array, measured in defined elements,
335&nbsp;#+ including null content elements.
336&nbsp;echo
337&nbsp;echo 'Defined content count: '${#ArrayVar[@]}' elements.'
338&nbsp;# That is NOT the maximum subscript (4).
339&nbsp;# That is NOT the range of the subscripts (1 . . 4 inclusive).
340&nbsp;# It IS the length of the linked list.
341&nbsp;###
342&nbsp;#  Both the maximum subscript and the range of the subscripts may
343&nbsp;#+ be found with additional script programming.
344&nbsp;
345&nbsp;# The length of a string, measured in non-null elements (characters):
346&nbsp;echo
347&nbsp;echo '- - Quoted, Glob-Pattern references - -'
348&nbsp;echo 'Non-Null character count: '"${#VarSomething}"' characters.'
349&nbsp;
350&nbsp;#  The length of an array, measured in defined elements,
351&nbsp;#+ including null-content elements.
352&nbsp;echo
353&nbsp;echo 'Defined element count: '"${#ArrayVar[*]}"' elements.'
354&nbsp;
355&nbsp;#  Interpretation: Substitution does not effect the ${# ... } operation.
356&nbsp;#  Suggestion:
357&nbsp;#  Always use the All-Elements-Of character
358&nbsp;#+ if that is what is intended (independence from IFS).
359&nbsp;
360&nbsp;
361&nbsp;
362&nbsp;#  Define a simple function.
363&nbsp;#  I include an underscore in the name
364&nbsp;#+ to make it distinctive in the examples below.
365&nbsp;###
366&nbsp;#  Bash separates variable names and function names
367&nbsp;#+ in different namespaces.
368&nbsp;#  The Mark-One eyeball isn't that advanced.
369&nbsp;###
370&nbsp;_simple() {
371&nbsp;    echo -n 'SimpleFunc'$@          #  Newlines are swallowed in
372&nbsp;}                                   #+ result returned in any case.
373&nbsp;
374&nbsp;
375&nbsp;# The ( ... ) notation invokes a command or function.
376&nbsp;# The $( ... ) notation is pronounced: Result-Of.
377&nbsp;
378&nbsp;
379&nbsp;# Invoke the function _simple
380&nbsp;echo
381&nbsp;echo '- - Output of function _simple - -'
382&nbsp;_simple                             # Try passing arguments.
383&nbsp;echo
384&nbsp;# or
385&nbsp;(_simple)                           # Try passing arguments.
386&nbsp;echo
387&nbsp;
388&nbsp;echo '- Is there a variable of that name? -'
389&nbsp;echo $_simple not defined           # No variable by that name.
390&nbsp;
391&nbsp;# Invoke the result of function _simple (Error msg intended)
392&nbsp;
393&nbsp;###
394&nbsp;$(_simple)                          # Gives an error message:
395&nbsp;#                          line 394: SimpleFunc: command not found
396&nbsp;#                          ---------------------------------------
397&nbsp;
398&nbsp;echo
399&nbsp;###
400&nbsp;
401&nbsp;#  The first word of the result of function _simple
402&nbsp;#+ is neither a valid Bash command nor the name of a defined function.
403&nbsp;###
404&nbsp;# This demonstrates that the output of _simple is subject to evaluation.
405&nbsp;###
406&nbsp;# Interpretation:
407&nbsp;#   A function can be used to generate in-line Bash commands.
408&nbsp;
409&nbsp;
410&nbsp;# A simple function where the first word of result IS a bash command:
411&nbsp;###
412&nbsp;_print() {
413&nbsp;    echo -n 'printf %q '$@
414&nbsp;}
415&nbsp;
416&nbsp;echo '- - Outputs of function _print - -'
417&nbsp;_print parm1 parm2                  # An Output NOT A Command.
418&nbsp;echo
419&nbsp;
420&nbsp;$(_print parm1 parm2)               #  Executes: printf %q parm1 parm2
421&nbsp;                                    #  See above IFS examples for the
422&nbsp;                                    #+ various possibilities.
423&nbsp;echo
424&nbsp;
425&nbsp;$(_print $VarSomething)             # The predictable result.
426&nbsp;echo
427&nbsp;
428&nbsp;
429&nbsp;
430&nbsp;# Function variables
431&nbsp;# ------------------
432&nbsp;
433&nbsp;echo
434&nbsp;echo '- - Function variables - -'
435&nbsp;# A variable may represent a signed integer, a string or an array.
436&nbsp;# A string may be used like a function name with optional arguments.
437&nbsp;
438&nbsp;# set -vx                           #  Enable if desired
439&nbsp;declare -f funcVar                  #+ in namespace of functions
440&nbsp;
441&nbsp;funcVar=_print                      # Contains name of function.
442&nbsp;$funcVar parm1                      # Same as _print at this point.
443&nbsp;echo
444&nbsp;
445&nbsp;funcVar=$(_print )                  # Contains result of function.
446&nbsp;$funcVar                            # No input, No output.
447&nbsp;$funcVar $VarSomething              # The predictable result.
448&nbsp;echo
449&nbsp;
450&nbsp;funcVar=$(_print $VarSomething)     #  $VarSomething replaced HERE.
451&nbsp;$funcVar                            #  The expansion is part of the
452&nbsp;echo                                #+ variable contents.
453&nbsp;
454&nbsp;funcVar="$(_print $VarSomething)"   #  $VarSomething replaced HERE.
455&nbsp;$funcVar                            #  The expansion is part of the
456&nbsp;echo                                #+ variable contents.
457&nbsp;
458&nbsp;#  The difference between the unquoted and the double-quoted versions
459&nbsp;#+ above can be seen in the "protect_literal.sh" example.
460&nbsp;#  The first case above is processed as two, unquoted, Bash-Words.
461&nbsp;#  The second case above is processed as one, quoted, Bash-Word.
462&nbsp;
463&nbsp;
464&nbsp;
465&nbsp;
466&nbsp;# Delayed replacement
467&nbsp;# -------------------
468&nbsp;
469&nbsp;echo
470&nbsp;echo '- - Delayed replacement - -'
471&nbsp;funcVar="$(_print '$VarSomething')" # No replacement, single Bash-Word.
472&nbsp;eval $funcVar                       # $VarSomething replaced HERE.
473&nbsp;echo
474&nbsp;
475&nbsp;VarSomething='NewThing'
476&nbsp;eval $funcVar                       # $VarSomething replaced HERE.
477&nbsp;echo
478&nbsp;
479&nbsp;# Restore the original setting trashed above.
480&nbsp;VarSomething=Literal
481&nbsp;
482&nbsp;#  There are a pair of functions demonstrated in the
483&nbsp;#+ "protect_literal.sh" and "unprotect_literal.sh" examples.
484&nbsp;#  These are general purpose functions for delayed replacement literals
485&nbsp;#+ containing variables.
486&nbsp;
487&nbsp;
488&nbsp;
489&nbsp;
490&nbsp;
491&nbsp;# REVIEW:
492&nbsp;# ------
493&nbsp;
494&nbsp;#  A string can be considered a Classic-Array of elements (characters).
495&nbsp;#  A string operation applies to all elements (characters) of the string
496&nbsp;#+ (in concept, anyway).
497&nbsp;###
498&nbsp;#  The notation: ${array_name[@]} represents all elements of the
499&nbsp;#+ Bash-Array: array_name.
500&nbsp;###
501&nbsp;#  The Extended-Syntax string operations can be applied to all
502&nbsp;#+ elements of an array.
503&nbsp;###
504&nbsp;#  This may be thought of as a For-Each operation on a vector of strings.
505&nbsp;###
506&nbsp;#  Parameters are similar to an array.
507&nbsp;#  The initialization of a parameter array for a script
508&nbsp;#+ and a parameter array for a function only differ
509&nbsp;#+ in the initialization of ${0}, which never changes its setting.
510&nbsp;###
511&nbsp;#  Subscript zero of the script's parameter array contains
512&nbsp;#+ the name of the script.
513&nbsp;###
514&nbsp;#  Subscript zero of a function's parameter array DOES NOT contain
515&nbsp;#+ the name of the function.
516&nbsp;#  The name of the current function is accessed by the $FUNCNAME variable.
517&nbsp;###
518&nbsp;#  A quick, review list follows (quick, not short).
519&nbsp;
520&nbsp;echo
521&nbsp;echo '- - Test (but not change) - -'
522&nbsp;echo '- null reference -'
523&nbsp;echo -n ${VarNull-'NotSet'}' '          # NotSet
524&nbsp;echo ${VarNull}                         # NewLine only
525&nbsp;echo -n ${VarNull:-'NotSet'}' '         # NotSet
526&nbsp;echo ${VarNull}                         # Newline only
527&nbsp;
528&nbsp;echo '- null contents -'
529&nbsp;echo -n ${VarEmpty-'Empty'}' '          # Only the space
530&nbsp;echo ${VarEmpty}                        # Newline only
531&nbsp;echo -n ${VarEmpty:-'Empty'}' '         # Empty
532&nbsp;echo ${VarEmpty}                        # Newline only
533&nbsp;
534&nbsp;echo '- contents -'
535&nbsp;echo ${VarSomething-'Content'}          # Literal
536&nbsp;echo ${VarSomething:-'Content'}         # Literal
537&nbsp;
538&nbsp;echo '- Sparse Array -'
539&nbsp;echo ${ArrayVar[@]-'not set'}
540&nbsp;
541&nbsp;# ASCII-Art time
542&nbsp;# State     Y==yes, N==no
543&nbsp;#           -       :-
544&nbsp;# Unset     Y       Y       ${# ... } == 0
545&nbsp;# Empty     N       Y       ${# ... } == 0
546&nbsp;# Contents  N       N       ${# ... } &#62; 0
547&nbsp;
548&nbsp;#  Either the first and/or the second part of the tests
549&nbsp;#+ may be a command or a function invocation string.
550&nbsp;echo
551&nbsp;echo '- - Test 1 for undefined - -'
552&nbsp;declare -i t
553&nbsp;_decT() {
554&nbsp;    t=$t-1
555&nbsp;}
556&nbsp;
557&nbsp;# Null reference, set: t == -1
558&nbsp;t=${#VarNull}                           # Results in zero.
559&nbsp;${VarNull- _decT }                      # Function executes, t now -1.
560&nbsp;echo $t
561&nbsp;
562&nbsp;# Null contents, set: t == 0
563&nbsp;t=${#VarEmpty}                          # Results in zero.
564&nbsp;${VarEmpty- _decT }                     # _decT function NOT executed.
565&nbsp;echo $t
566&nbsp;
567&nbsp;# Contents, set: t == number of non-null characters
568&nbsp;VarSomething='_simple'                  # Set to valid function name.
569&nbsp;t=${#VarSomething}                      # non-zero length
570&nbsp;${VarSomething- _decT }                 # Function _simple executed.
571&nbsp;echo $t                                 # Note the Append-To action.
572&nbsp;
573&nbsp;# Exercise: clean up that example.
574&nbsp;unset t
575&nbsp;unset _decT
576&nbsp;VarSomething=Literal
577&nbsp;
578&nbsp;echo
579&nbsp;echo '- - Test and Change - -'
580&nbsp;echo '- Assignment if null reference -'
581&nbsp;echo -n ${VarNull='NotSet'}' '          # NotSet NotSet
582&nbsp;echo ${VarNull}
583&nbsp;unset VarNull
584&nbsp;
585&nbsp;echo '- Assignment if null reference -'
586&nbsp;echo -n ${VarNull:='NotSet'}' '         # NotSet NotSet
587&nbsp;echo ${VarNull}
588&nbsp;unset VarNull
589&nbsp;
590&nbsp;echo '- No assignment if null contents -'
591&nbsp;echo -n ${VarEmpty='Empty'}' '          # Space only
592&nbsp;echo ${VarEmpty}
593&nbsp;VarEmpty=''
594&nbsp;
595&nbsp;echo '- Assignment if null contents -'
596&nbsp;echo -n ${VarEmpty:='Empty'}' '         # Empty Empty
597&nbsp;echo ${VarEmpty}
598&nbsp;VarEmpty=''
599&nbsp;
600&nbsp;echo '- No change if already has contents -'
601&nbsp;echo ${VarSomething='Content'}          # Literal
602&nbsp;echo ${VarSomething:='Content'}         # Literal
603&nbsp;
604&nbsp;
605&nbsp;# "Subscript sparse" Bash-Arrays
606&nbsp;###
607&nbsp;#  Bash-Arrays are subscript packed, beginning with
608&nbsp;#+ subscript zero unless otherwise specified.
609&nbsp;###
610&nbsp;#  The initialization of ArrayVar was one way
611&nbsp;#+ to "otherwise specify".  Here is the other way:
612&nbsp;###
613&nbsp;echo
614&nbsp;declare -a ArraySparse
615&nbsp;ArraySparse=( [1]=one [2]='' [4]='four' )
616&nbsp;# [0]=null reference, [2]=null content, [3]=null reference
617&nbsp;
618&nbsp;echo '- - Array-Sparse List - -'
619&nbsp;# Within double-quotes, default IFS, Glob-Pattern
620&nbsp;
621&nbsp;IFS=$'\x20'$'\x09'$'\x0A'
622&nbsp;printf %q "${ArraySparse[*]}"
623&nbsp;echo
624&nbsp;
625&nbsp;#  Note that the output does not distinguish between "null content"
626&nbsp;#+ and "null reference".
627&nbsp;#  Both print as escaped whitespace.
628&nbsp;###
629&nbsp;#  Note also that the output does NOT contain escaped whitespace
630&nbsp;#+ for the "null reference(s)" prior to the first defined element.
631&nbsp;###
632&nbsp;# This behavior of 2.04, 2.05a and 2.05b has been reported
633&nbsp;#+ and may change in a future version of Bash.
634&nbsp;
635&nbsp;#  To output a sparse array and maintain the [subscript]=value
636&nbsp;#+ relationship without change requires a bit of programming.
637&nbsp;#  One possible code fragment:
638&nbsp;###
639&nbsp;# local l=${#ArraySparse[@]}        # Count of defined elements
640&nbsp;# local f=0                         # Count of found subscripts
641&nbsp;# local i=0                         # Subscript to test
642&nbsp;(                                   # Anonymous in-line function
643&nbsp;    for (( l=${#ArraySparse[@]}, f = 0, i = 0 ; f &#60; l ; i++ ))
644&nbsp;    do
645&nbsp;        # 'if defined then...'
646&nbsp;        ${ArraySparse[$i]+ eval echo '\ ['$i']='${ArraySparse[$i]} ; (( f++ )) }
647&nbsp;    done
648&nbsp;)
649&nbsp;
650&nbsp;# The reader coming upon the above code fragment cold
651&nbsp;#+ might want to review "command lists" and "multiple commands on a line"
652&nbsp;#+ in the text of the foregoing "Advanced Bash Scripting Guide."
653&nbsp;###
654&nbsp;#  Note:
655&nbsp;#  The "read -a array_name" version of the "read" command
656&nbsp;#+ begins filling array_name at subscript zero.
657&nbsp;#  ArraySparse does not define a value at subscript zero.
658&nbsp;###
659&nbsp;#  The user needing to read/write a sparse array to either
660&nbsp;#+ external storage or a communications socket must invent
661&nbsp;#+ a read/write code pair suitable for their purpose.
662&nbsp;###
663&nbsp;# Exercise: clean it up.
664&nbsp;
665&nbsp;unset ArraySparse
666&nbsp;
667&nbsp;echo
668&nbsp;echo '- - Conditional alternate (But not change)- -'
669&nbsp;echo '- No alternate if null reference -'
670&nbsp;echo -n ${VarNull+'NotSet'}' '
671&nbsp;echo ${VarNull}
672&nbsp;unset VarNull
673&nbsp;
674&nbsp;echo '- No alternate if null reference -'
675&nbsp;echo -n ${VarNull:+'NotSet'}' '
676&nbsp;echo ${VarNull}
677&nbsp;unset VarNull
678&nbsp;
679&nbsp;echo '- Alternate if null contents -'
680&nbsp;echo -n ${VarEmpty+'Empty'}' '              # Empty
681&nbsp;echo ${VarEmpty}
682&nbsp;VarEmpty=''
683&nbsp;
684&nbsp;echo '- No alternate if null contents -'
685&nbsp;echo -n ${VarEmpty:+'Empty'}' '             # Space only
686&nbsp;echo ${VarEmpty}
687&nbsp;VarEmpty=''
688&nbsp;
689&nbsp;echo '- Alternate if already has contents -'
690&nbsp;
691&nbsp;# Alternate literal
692&nbsp;echo -n ${VarSomething+'Content'}' '        # Content Literal
693&nbsp;echo ${VarSomething}
694&nbsp;
695&nbsp;# Invoke function
696&nbsp;echo -n ${VarSomething:+ $(_simple) }' '    # SimpleFunc Literal
697&nbsp;echo ${VarSomething}
698&nbsp;echo
699&nbsp;
700&nbsp;echo '- - Sparse Array - -'
701&nbsp;echo ${ArrayVar[@]+'Empty'}                 # An array of 'Empty'(ies)
702&nbsp;echo
703&nbsp;
704&nbsp;echo '- - Test 2 for undefined - -'
705&nbsp;
706&nbsp;declare -i t
707&nbsp;_incT() {
708&nbsp;    t=$t+1
709&nbsp;}
710&nbsp;
711&nbsp;#  Note:
712&nbsp;#  This is the same test used in the sparse array
713&nbsp;#+ listing code fragment.
714&nbsp;
715&nbsp;# Null reference, set: t == -1
716&nbsp;t=${#VarNull}-1                     # Results in minus-one.
717&nbsp;${VarNull+ _incT }                  # Does not execute.
718&nbsp;echo $t' Null reference'
719&nbsp;
720&nbsp;# Null contents, set: t == 0
721&nbsp;t=${#VarEmpty}-1                    # Results in minus-one.
722&nbsp;${VarEmpty+ _incT }                 # Executes.
723&nbsp;echo $t'  Null content'
724&nbsp;
725&nbsp;# Contents, set: t == (number of non-null characters)
726&nbsp;t=${#VarSomething}-1                # non-null length minus-one
727&nbsp;${VarSomething+ _incT }             # Executes.
728&nbsp;echo $t'  Contents'
729&nbsp;
730&nbsp;# Exercise: clean up that example.
731&nbsp;unset t
732&nbsp;unset _incT
733&nbsp;
734&nbsp;# ${name?err_msg} ${name:?err_msg}
735&nbsp;#  These follow the same rules but always exit afterwards
736&nbsp;#+ if an action is specified following the question mark.
737&nbsp;#  The action following the question mark may be a literal
738&nbsp;#+ or a function result.
739&nbsp;###
740&nbsp;#  ${name?} ${name:?} are test-only, the return can be tested.
741&nbsp;
742&nbsp;
743&nbsp;
744&nbsp;
745&nbsp;# Element operations
746&nbsp;# ------------------
747&nbsp;
748&nbsp;echo
749&nbsp;echo '- - Trailing sub-element selection - -'
750&nbsp;
751&nbsp;#  Strings, Arrays and Positional parameters
752&nbsp;
753&nbsp;#  Call this script with multiple arguments
754&nbsp;#+ to see the parameter selections.
755&nbsp;
756&nbsp;echo '- All -'
757&nbsp;echo ${VarSomething:0}              # all non-null characters
758&nbsp;echo ${ArrayVar[@]:0}               # all elements with content
759&nbsp;echo ${@:0}                         # all parameters with content;
760&nbsp;                                    # ignoring parameter[0]
761&nbsp;
762&nbsp;echo
763&nbsp;echo '- All after -'
764&nbsp;echo ${VarSomething:1}              # all non-null after character[0]
765&nbsp;echo ${ArrayVar[@]:1}               # all after element[0] with content
766&nbsp;echo ${@:2}                         # all after param[1] with content
767&nbsp;
768&nbsp;echo
769&nbsp;echo '- Range after -'
770&nbsp;echo ${VarSomething:4:3}            # ral
771&nbsp;                                    # Three characters after
772&nbsp;                                    # character[3]
773&nbsp;
774&nbsp;echo '- Sparse array gotch -'
775&nbsp;echo ${ArrayVar[@]:1:2}     #  four - The only element with content.
776&nbsp;                            #  Two elements after (if that many exist).
777&nbsp;                            #  the FIRST WITH CONTENTS
778&nbsp;                            #+ (the FIRST WITH  CONTENTS is being
779&nbsp;                            #+ considered as if it
780&nbsp;                            #+ were subscript zero).
781&nbsp;#  Executed as if Bash considers ONLY array elements with CONTENT
782&nbsp;#  printf %q "${ArrayVar[@]:0:3}"    # Try this one
783&nbsp;
784&nbsp;#  In versions 2.04, 2.05a and 2.05b,
785&nbsp;#+ Bash does not handle sparse arrays as expected using this notation.
786&nbsp;#
787&nbsp;#  The current Bash maintainer, Chet Ramey, has corrected this
788&nbsp;#+ for an upcoming version of Bash.
789&nbsp;
790&nbsp;
791&nbsp;echo '- Non-sparse array -'
792&nbsp;echo ${@:2:2}               # Two parameters following parameter[1]
793&nbsp;
794&nbsp;# New victims for string vector examples:
795&nbsp;stringZ=abcABC123ABCabc
796&nbsp;arrayZ=( abcabc ABCABC 123123 ABCABC abcabc )
797&nbsp;sparseZ=( [1]='abcabc' [3]='ABCABC' [4]='' [5]='123123' )
798&nbsp;
799&nbsp;echo
800&nbsp;echo ' - - Victim string - -'$stringZ'- - '
801&nbsp;echo ' - - Victim array - -'${arrayZ[@]}'- - '
802&nbsp;echo ' - - Sparse array - -'${sparseZ[@]}'- - '
803&nbsp;echo ' - [0]==null ref, [2]==null ref, [4]==null content - '
804&nbsp;echo ' - [1]=abcabc [3]=ABCABC [5]=123123 - '
805&nbsp;echo ' - non-null-reference count: '${#sparseZ[@]}' elements'
806&nbsp;
807&nbsp;echo
808&nbsp;echo '- - Prefix sub-element removal - -'
809&nbsp;echo '- - Glob-Pattern match must include the first character. - -'
810&nbsp;echo '- - Glob-Pattern may be a literal or a function result. - -'
811&nbsp;echo
812&nbsp;
813&nbsp;
814&nbsp;# Function returning a simple, Literal, Glob-Pattern
815&nbsp;_abc() {
816&nbsp;    echo -n 'abc'
817&nbsp;}
818&nbsp;
819&nbsp;echo '- Shortest prefix -'
820&nbsp;echo ${stringZ#123}                 # Unchanged (not a prefix).
821&nbsp;echo ${stringZ#$(_abc)}             # ABC123ABCabc
822&nbsp;echo ${arrayZ[@]#abc}               # Applied to each element.
823&nbsp;
824&nbsp;# Fixed by Chet Ramey for an upcoming version of Bash.
825&nbsp;# echo ${sparseZ[@]#abc}            # Version-2.05b core dumps.
826&nbsp;
827&nbsp;# The -it would be nice- First-Subscript-Of
828&nbsp;# echo ${#sparseZ[@]#*}             # This is NOT valid Bash.
829&nbsp;
830&nbsp;echo
831&nbsp;echo '- Longest prefix -'
832&nbsp;echo ${stringZ##1*3}                # Unchanged (not a prefix)
833&nbsp;echo ${stringZ##a*C}                # abc
834&nbsp;echo ${arrayZ[@]##a*c}              # ABCABC 123123 ABCABC
835&nbsp;
836&nbsp;# Fixed by Chet Ramey for an upcoming version of Bash
837&nbsp;# echo ${sparseZ[@]##a*c}           # Version-2.05b core dumps.
838&nbsp;
839&nbsp;echo
840&nbsp;echo '- - Suffix sub-element removal - -'
841&nbsp;echo '- - Glob-Pattern match must include the last character. - -'
842&nbsp;echo '- - Glob-Pattern may be a literal or a function result. - -'
843&nbsp;echo
844&nbsp;echo '- Shortest suffix -'
845&nbsp;echo ${stringZ%1*3}                 # Unchanged (not a suffix).
846&nbsp;echo ${stringZ%$(_abc)}             # abcABC123ABC
847&nbsp;echo ${arrayZ[@]%abc}               # Applied to each element.
848&nbsp;
849&nbsp;# Fixed by Chet Ramey for an upcoming version of Bash.
850&nbsp;# echo ${sparseZ[@]%abc}            # Version-2.05b core dumps.
851&nbsp;
852&nbsp;# The -it would be nice- Last-Subscript-Of
853&nbsp;# echo ${#sparseZ[@]%*}             # This is NOT valid Bash.
854&nbsp;
855&nbsp;echo
856&nbsp;echo '- Longest suffix -'
857&nbsp;echo ${stringZ%%1*3}                # Unchanged (not a suffix)
858&nbsp;echo ${stringZ%%b*c}                # a
859&nbsp;echo ${arrayZ[@]%%b*c}              # a ABCABC 123123 ABCABC a
860&nbsp;
861&nbsp;# Fixed by Chet Ramey for an upcoming version of Bash.
862&nbsp;# echo ${sparseZ[@]%%b*c}           # Version-2.05b core dumps.
863&nbsp;
864&nbsp;echo
865&nbsp;echo '- - Sub-element replacement - -'
866&nbsp;echo '- - Sub-element at any location in string. - -'
867&nbsp;echo '- - First specification is a Glob-Pattern - -'
868&nbsp;echo '- - Glob-Pattern may be a literal or Glob-Pattern function result. - -'
869&nbsp;echo '- - Second specification may be a literal or function result. - -'
870&nbsp;echo '- - Second specification may be unspecified. Pronounce that'
871&nbsp;echo '    as: Replace-With-Nothing (Delete) - -'
872&nbsp;echo
873&nbsp;
874&nbsp;
875&nbsp;
876&nbsp;# Function returning a simple, Literal, Glob-Pattern
877&nbsp;_123() {
878&nbsp;    echo -n '123'
879&nbsp;}
880&nbsp;
881&nbsp;echo '- Replace first occurrence -'
882&nbsp;echo ${stringZ/$(_123)/999}         # Changed (123 is a component).
883&nbsp;echo ${stringZ/ABC/xyz}             # xyzABC123ABCabc
884&nbsp;echo ${arrayZ[@]/ABC/xyz}           # Applied to each element.
885&nbsp;echo ${sparseZ[@]/ABC/xyz}          # Works as expected.
886&nbsp;
887&nbsp;echo
888&nbsp;echo '- Delete first occurrence -'
889&nbsp;echo ${stringZ/$(_123)/}
890&nbsp;echo ${stringZ/ABC/}
891&nbsp;echo ${arrayZ[@]/ABC/}
892&nbsp;echo ${sparseZ[@]/ABC/}
893&nbsp;
894&nbsp;#  The replacement need not be a literal,
895&nbsp;#+ since the result of a function invocation is allowed.
896&nbsp;#  This is general to all forms of replacement.
897&nbsp;echo
898&nbsp;echo '- Replace first occurrence with Result-Of -'
899&nbsp;echo ${stringZ/$(_123)/$(_simple)}  # Works as expected.
900&nbsp;echo ${arrayZ[@]/ca/$(_simple)}     # Applied to each element.
901&nbsp;echo ${sparseZ[@]/ca/$(_simple)}    # Works as expected.
902&nbsp;
903&nbsp;echo
904&nbsp;echo '- Replace all occurrences -'
905&nbsp;echo ${stringZ//[b2]/X}             # X-out b's and 2's
906&nbsp;echo ${stringZ//abc/xyz}            # xyzABC123ABCxyz
907&nbsp;echo ${arrayZ[@]//abc/xyz}          # Applied to each element.
908&nbsp;echo ${sparseZ[@]//abc/xyz}         # Works as expected.
909&nbsp;
910&nbsp;echo
911&nbsp;echo '- Delete all occurrences -'
912&nbsp;echo ${stringZ//[b2]/}
913&nbsp;echo ${stringZ//abc/}
914&nbsp;echo ${arrayZ[@]//abc/}
915&nbsp;echo ${sparseZ[@]//abc/}
916&nbsp;
917&nbsp;echo
918&nbsp;echo '- - Prefix sub-element replacement - -'
919&nbsp;echo '- - Match must include the first character. - -'
920&nbsp;echo
921&nbsp;
922&nbsp;echo '- Replace prefix occurrences -'
923&nbsp;echo ${stringZ/#[b2]/X}             # Unchanged (neither is a prefix).
924&nbsp;echo ${stringZ/#$(_abc)/XYZ}        # XYZABC123ABCabc
925&nbsp;echo ${arrayZ[@]/#abc/XYZ}          # Applied to each element.
926&nbsp;echo ${sparseZ[@]/#abc/XYZ}         # Works as expected.
927&nbsp;
928&nbsp;echo
929&nbsp;echo '- Delete prefix occurrences -'
930&nbsp;echo ${stringZ/#[b2]/}
931&nbsp;echo ${stringZ/#$(_abc)/}
932&nbsp;echo ${arrayZ[@]/#abc/}
933&nbsp;echo ${sparseZ[@]/#abc/}
934&nbsp;
935&nbsp;echo
936&nbsp;echo '- - Suffix sub-element replacement - -'
937&nbsp;echo '- - Match must include the last character. - -'
938&nbsp;echo
939&nbsp;
940&nbsp;echo '- Replace suffix occurrences -'
941&nbsp;echo ${stringZ/%[b2]/X}             # Unchanged (neither is a suffix).
942&nbsp;echo ${stringZ/%$(_abc)/XYZ}        # abcABC123ABCXYZ
943&nbsp;echo ${arrayZ[@]/%abc/XYZ}          # Applied to each element.
944&nbsp;echo ${sparseZ[@]/%abc/XYZ}         # Works as expected.
945&nbsp;
946&nbsp;echo
947&nbsp;echo '- Delete suffix occurrences -'
948&nbsp;echo ${stringZ/%[b2]/}
949&nbsp;echo ${stringZ/%$(_abc)/}
950&nbsp;echo ${arrayZ[@]/%abc/}
951&nbsp;echo ${sparseZ[@]/%abc/}
952&nbsp;
953&nbsp;echo
954&nbsp;echo '- - Special cases of null Glob-Pattern - -'
955&nbsp;echo
956&nbsp;
957&nbsp;echo '- Prefix all -'
958&nbsp;# null substring pattern means 'prefix'
959&nbsp;echo ${stringZ/#/NEW}               # NEWabcABC123ABCabc
960&nbsp;echo ${arrayZ[@]/#/NEW}             # Applied to each element.
961&nbsp;echo ${sparseZ[@]/#/NEW}            # Applied to null-content also.
962&nbsp;                                    # That seems reasonable.
963&nbsp;
964&nbsp;echo
965&nbsp;echo '- Suffix all -'
966&nbsp;# null substring pattern means 'suffix'
967&nbsp;echo ${stringZ/%/NEW}               # abcABC123ABCabcNEW
968&nbsp;echo ${arrayZ[@]/%/NEW}             # Applied to each element.
969&nbsp;echo ${sparseZ[@]/%/NEW}            # Applied to null-content also.
970&nbsp;                                    # That seems reasonable.
971&nbsp;
972&nbsp;echo
973&nbsp;echo '- - Special case For-Each Glob-Pattern - -'
974&nbsp;echo '- - - - This is a nice-to-have dream - - - -'
975&nbsp;echo
976&nbsp;
977&nbsp;_GenFunc() {
978&nbsp;    echo -n ${0}                    # Illustration only.
979&nbsp;    # Actually, that would be an arbitrary computation.
980&nbsp;}
981&nbsp;
982&nbsp;# All occurrences, matching the AnyThing pattern.
983&nbsp;# Currently //*/ does not match null-content nor null-reference.
984&nbsp;# /#/ and /%/ does match null-content but not null-reference.
985&nbsp;echo ${sparseZ[@]//*/$(_GenFunc)}
986&nbsp;
987&nbsp;
988&nbsp;#  A possible syntax would be to make
989&nbsp;#+ the parameter notation used within this construct mean:
990&nbsp;#   ${1} - The full element
991&nbsp;#   ${2} - The prefix, if any, to the matched sub-element
992&nbsp;#   ${3} - The matched sub-element
993&nbsp;#   ${4} - The suffix, if any, to the matched sub-element
994&nbsp;#
995&nbsp;# echo ${sparseZ[@]//*/$(_GenFunc ${3})}   # Same as ${1} here.
996&nbsp;# Perhaps it will be implemented in a future version of Bash.
997&nbsp;
998&nbsp;
999&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="CDLL"
></A
><P
><B
>例子 A-33. 一个扩展的<B
CLASS="COMMAND"
>cd</B
>命令</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;############################################################################
  2&nbsp;#
  3&nbsp;#       cdll
  4&nbsp;#       by Phil Braham
  5&nbsp;#
  6&nbsp;#       ############################################
  7&nbsp;#       Latest version of this script available from
  8&nbsp;#       http://freshmeat.net/projects/cd/
  9&nbsp;#       ############################################
 10&nbsp;#
 11&nbsp;#       .cd_new
 12&nbsp;#
 13&nbsp;#       An enhancement of the Unix cd command
 14&nbsp;#
 15&nbsp;#       There are unlimited stack entries and special entries. The stack
 16&nbsp;#       entries keep the last cd_maxhistory
 17&nbsp;#       directories that have been used. The special entries can be assigned
 18&nbsp;#       to commonly used directories.
 19&nbsp;#
 20&nbsp;#       The special entries may be pre-assigned by setting the environment
 21&nbsp;#       variables CDSn or by using the -u or -U command.
 22&nbsp;#
 23&nbsp;#       The following is a suggestion for the .profile file:
 24&nbsp;#
 25&nbsp;#               . cdll              #  Set up the cd command
 26&nbsp;#       alias cd='cd_new'           #  Replace te cd command
 27&nbsp;#               cd -U               #  Upload pre-assigned entries for
 28&nbsp;#                                   #+ the stact and special entries
 29&nbsp;#               cd -D               #  Set non-default mode
 30&nbsp;#               alias @="cd_new @"  #  Allow @ to be used to get history
 31&nbsp;#
 32&nbsp;#       For help type:
 33&nbsp;#
 34&nbsp;#               cd -h or
 35&nbsp;#               cd -H
 36&nbsp;#
 37&nbsp;#
 38&nbsp;############################################################################
 39&nbsp;#
 40&nbsp;#       Version 1.2.1
 41&nbsp;#
 42&nbsp;#       Written by Phil Braham - Realtime Software Pty Ltd
 43&nbsp;#       (realtime@mpx.com.au)
 44&nbsp;#       Please send any suggestions or enhancements to the author (also at
 45&nbsp;#       phil@braham.net)
 46&nbsp;#
 47&nbsp;############################################################################
 48&nbsp;
 49&nbsp;cd_hm ()
 50&nbsp;{
 51&nbsp;        ${PRINTF} "%s" "cd [dir] [0-9] [@[s|h] [-g [&#60;dir&#62;]] [-d] [-D] [-r&#60;n&#62;] [dir|0-9] [-R&#60;n&#62;] [&#60;dir&#62;|0-9]
 52&nbsp;   [-s&#60;n&#62;] [-S&#60;n&#62;] [-u] [-U] [-f] [-F] [-h] [-H] [-v]
 53&nbsp;    &#60;dir&#62; Go to directory
 54&nbsp;    0-n         Goto previous directory (0 is previous, 1 is last but 1 etc)
 55&nbsp;                n is up to max history (default is 50)
 56&nbsp;    @           List history and special entries
 57&nbsp;    @h          List history entries
 58&nbsp;    @s          List special entries
 59&nbsp;    -g [&#60;dir&#62;]  Go to literal name (bypass special names)
 60&nbsp;                This is to allow access to dirs called '0','1','-h' etc
 61&nbsp;    -d          Change default action - verbose. (See note)
 62&nbsp;    -D          Change default action - silent. (See note)
 63&nbsp;    -s&#60;n&#62;       Go to the special entry &#60;n&#62;*
 64&nbsp;    -S&#60;n&#62;       Go to the special entry &#60;n&#62; and replace it with the current dir*
 65&nbsp;    -r&#60;n&#62; [&#60;dir&#62;] Go to directory &#60;dir&#62; and then put it on special entry &#60;n&#62;*
 66&nbsp;    -R&#60;n&#62; [&#60;dir&#62;] Go to directory &#60;dir&#62; and put current dir on special entry &#60;n&#62;*
 67&nbsp;    -a&#60;n&#62;       Alternative suggested directory. See note below.
 68&nbsp;    -f [&#60;file&#62;] File entries to &#60;file&#62;.
 69&nbsp;    -u [&#60;file&#62;] Update entries from &#60;file&#62;.
 70&nbsp;                If no filename supplied then default file (${CDPath}${2:-"$CDFile"}) is used
 71&nbsp;                -F and -U are silent versions
 72&nbsp;    -v          Print version number
 73&nbsp;    -h          Help
 74&nbsp;    -H          Detailed help
 75&nbsp;
 76&nbsp;    *The special entries (0 - 9) are held until log off, replaced by another entry
 77&nbsp;     or updated with the -u command
 78&nbsp;
 79&nbsp;    Alternative suggested directories:
 80&nbsp;    If a directory is not found then CD will suggest any possibilities. These are
 81&nbsp;    directories starting with the same letters and if any are found they are listed
 82&nbsp;    prefixed with -a&#60;n&#62; where &#60;n&#62; is a number.
 83&nbsp;    It's possible to go to the directory by entering cd -a&#60;n&#62; on the command line. 
 84&nbsp;    
 85&nbsp;    The directory for -r&#60;n&#62; or -R&#60;n&#62; may be a number. For example:
 86&nbsp;        $ cd -r3 4  Go to history entry 4 and put it on special entry 3
 87&nbsp;        $ cd -R3 4  Put current dir on the special entry 3 and go to history entry 4
 88&nbsp;        $ cd -s3    Go to special entry 3
 89&nbsp;    
 90&nbsp;    Note that commands R,r,S and s may be used without a number and refer to 0:
 91&nbsp;        $ cd -s     Go to special entry 0
 92&nbsp;        $ cd -S     Go to special entry 0 and make special entry 0 current dir
 93&nbsp;        $ cd -r 1   Go to history entry 1 and put it on special entry 0
 94&nbsp;        $ cd -r     Go to history entry 0 and put it on special entry 0
 95&nbsp;    "
 96&nbsp;        if ${TEST} "$CD_MODE" = "PREV"
 97&nbsp;        then
 98&nbsp;                ${PRINTF} "$cd_mnset"
 99&nbsp;        else
100&nbsp;                ${PRINTF} "$cd_mset"
101&nbsp;        fi
102&nbsp;}
103&nbsp;
104&nbsp;cd_Hm ()
105&nbsp;{
106&nbsp;        cd_hm
107&nbsp;        ${PRINTF} "%s" "
108&nbsp;        The previous directories (0-$cd_maxhistory) are stored in the
109&nbsp;        environment variables CD[0] - CD[$cd_maxhistory]
110&nbsp;        Similarly the special directories S0 - $cd_maxspecial are in
111&nbsp;        the environment variable CDS[0] - CDS[$cd_maxspecial]
112&nbsp;        and may be accessed from the command line
113&nbsp;
114&nbsp;        The default pathname for the -f and -u commands is $CDPath
115&nbsp;        The default filename for the -f and -u commands is $CDFile
116&nbsp;
117&nbsp;        Set the following environment variables:
118&nbsp;            CDL_PROMPTLEN  - Set to the length of prompt you require.
119&nbsp;                Prompt string is set to the right characters of the
120&nbsp;                current directory.
121&nbsp;                If not set then prompt is left unchanged
122&nbsp;            CDL_PROMPT_PRE - Set to the string to prefix the prompt.
123&nbsp;                Default is:
124&nbsp;                    non-root:  \"\\[\\e[01;34m\\]\"  (sets colour to blue).
125&nbsp;                    root:      \"\\[\\e[01;31m\\]\"  (sets colour to red).
126&nbsp;            CDL_PROMPT_POST    - Set to the string to suffix the prompt.
127&nbsp;                Default is:
128&nbsp;                    non-root:  \"\\[\\e[00m\\]$\"   (resets colour and displays $).
129&nbsp;                    root:      \"\\[\\e[00m\\]#\"   (resets colour and displays #).
130&nbsp;            CDPath - Set the default path for the -f &#38; -u options.
131&nbsp;                     Default is home directory
132&nbsp;            CDFile - Set the default filename for the -f &#38; -u options.
133&nbsp;                     Default is cdfile
134&nbsp;        
135&nbsp;"
136&nbsp;    cd_version
137&nbsp;
138&nbsp;}
139&nbsp;
140&nbsp;cd_version ()
141&nbsp;{
142&nbsp;    printf "Version: ${VERSION_MAJOR}.${VERSION_MINOR} Date: ${VERSION_DATE}\n"
143&nbsp;}
144&nbsp;
145&nbsp;#
146&nbsp;# Truncate right.
147&nbsp;#
148&nbsp;# params:
149&nbsp;#   p1 - string
150&nbsp;#   p2 - length to truncate to
151&nbsp;#
152&nbsp;# returns string in tcd
153&nbsp;#
154&nbsp;cd_right_trunc ()
155&nbsp;{
156&nbsp;    local tlen=${2}
157&nbsp;    local plen=${#1}
158&nbsp;    local str="${1}"
159&nbsp;    local diff
160&nbsp;    local filler="&#60;--"
161&nbsp;    if ${TEST} ${plen} -le ${tlen}
162&nbsp;    then
163&nbsp;        tcd="${str}"
164&nbsp;    else
165&nbsp;        let diff=${plen}-${tlen}
166&nbsp;        elen=3
167&nbsp;        if ${TEST} ${diff} -le 2
168&nbsp;        then
169&nbsp;            let elen=${diff}
170&nbsp;        fi
171&nbsp;        tlen=-${tlen}
172&nbsp;        let tlen=${tlen}+${elen}
173&nbsp;        tcd=${filler:0:elen}${str:tlen}
174&nbsp;    fi
175&nbsp;}
176&nbsp;
177&nbsp;#
178&nbsp;# Three versions of do history:
179&nbsp;#    cd_dohistory  - packs history and specials side by side
180&nbsp;#    cd_dohistoryH - Shows only hstory
181&nbsp;#    cd_dohistoryS - Shows only specials
182&nbsp;#
183&nbsp;cd_dohistory ()
184&nbsp;{
185&nbsp;    cd_getrc
186&nbsp;        ${PRINTF} "History:\n"
187&nbsp;    local -i count=${cd_histcount}
188&nbsp;    while ${TEST} ${count} -ge 0
189&nbsp;    do
190&nbsp;        cd_right_trunc "${CD[count]}" ${cd_lchar}
191&nbsp;            ${PRINTF} "%2d %-${cd_lchar}.${cd_lchar}s " ${count} "${tcd}"
192&nbsp;
193&nbsp;        cd_right_trunc "${CDS[count]}" ${cd_rchar}
194&nbsp;            ${PRINTF} "S%d %-${cd_rchar}.${cd_rchar}s\n" ${count} "${tcd}"
195&nbsp;        count=${count}-1
196&nbsp;    done
197&nbsp;}
198&nbsp;
199&nbsp;cd_dohistoryH ()
200&nbsp;{
201&nbsp;    cd_getrc
202&nbsp;        ${PRINTF} "History:\n"
203&nbsp;        local -i count=${cd_maxhistory}
204&nbsp;        while ${TEST} ${count} -ge 0
205&nbsp;        do
206&nbsp;                ${PRINTF} "${count} %-${cd_flchar}.${cd_flchar}s\n" ${CD[$count]}
207&nbsp;                count=${count}-1
208&nbsp;        done
209&nbsp;}
210&nbsp;
211&nbsp;cd_dohistoryS ()
212&nbsp;{
213&nbsp;    cd_getrc
214&nbsp;        ${PRINTF} "Specials:\n"
215&nbsp;        local -i count=${cd_maxspecial}
216&nbsp;        while ${TEST} ${count} -ge 0
217&nbsp;        do
218&nbsp;                ${PRINTF} "S${count} %-${cd_flchar}.${cd_flchar}s\n" ${CDS[$count]}
219&nbsp;                count=${count}-1
220&nbsp;        done
221&nbsp;}
222&nbsp;
223&nbsp;cd_getrc ()
224&nbsp;{
225&nbsp;    cd_flchar=$(stty -a | awk -F \; '/rows/ { print $2 $3 }' | awk -F \  '{ print $4 }')
226&nbsp;    if ${TEST} ${cd_flchar} -ne 0
227&nbsp;    then
228&nbsp;        cd_lchar=${cd_flchar}/2-5
229&nbsp;        cd_rchar=${cd_flchar}/2-5
230&nbsp;            cd_flchar=${cd_flchar}-5
231&nbsp;    else
232&nbsp;            cd_flchar=${FLCHAR:=75}  # cd_flchar is used for for the @s &#38; @h history
233&nbsp;            cd_lchar=${LCHAR:=35}
234&nbsp;            cd_rchar=${RCHAR:=35}
235&nbsp;    fi
236&nbsp;}
237&nbsp;
238&nbsp;cd_doselection ()
239&nbsp;{
240&nbsp;        local -i nm=0
241&nbsp;        cd_doflag="TRUE"
242&nbsp;        if ${TEST} "${CD_MODE}" = "PREV"
243&nbsp;        then
244&nbsp;                if ${TEST} -z "$cd_npwd"
245&nbsp;                then
246&nbsp;                        cd_npwd=0
247&nbsp;                fi
248&nbsp;        fi
249&nbsp;        tm=$(echo "${cd_npwd}" | cut -b 1)
250&nbsp;    if ${TEST} "${tm}" = "-"
251&nbsp;    then
252&nbsp;        pm=$(echo "${cd_npwd}" | cut -b 2)
253&nbsp;        nm=$(echo "${cd_npwd}" | cut -d $pm -f2)
254&nbsp;        case "${pm}" in
255&nbsp;                a) cd_npwd=${cd_sugg[$nm]} ;;
256&nbsp;                s) cd_npwd="${CDS[$nm]}" ;;
257&nbsp;                S) cd_npwd="${CDS[$nm]}" ; CDS[$nm]=`pwd` ;;
258&nbsp;                r) cd_npwd="$2" ; cd_specDir=$nm ; cd_doselection "$1" "$2";;
259&nbsp;                R) cd_npwd="$2" ; CDS[$nm]=`pwd` ; cd_doselection "$1" "$2";;
260&nbsp;        esac
261&nbsp;    fi
262&nbsp;
263&nbsp;        if ${TEST} "${cd_npwd}" != "." -a "${cd_npwd}" != ".." -a "${cd_npwd}" -le ${cd_maxhistory} &#62;&#62;/dev/null 2&#62;&#38;1
264&nbsp;        then
265&nbsp;                cd_npwd=${CD[$cd_npwd]}
266&nbsp;        else
267&nbsp;                case "$cd_npwd" in
268&nbsp;                         @)  cd_dohistory ; cd_doflag="FALSE" ;;
269&nbsp;                        @h) cd_dohistoryH ; cd_doflag="FALSE" ;;
270&nbsp;                        @s) cd_dohistoryS ; cd_doflag="FALSE" ;;
271&nbsp;                        -h) cd_hm ; cd_doflag="FALSE" ;;
272&nbsp;                        -H) cd_Hm ; cd_doflag="FALSE" ;;
273&nbsp;                        -f) cd_fsave "SHOW" $2 ; cd_doflag="FALSE" ;;
274&nbsp;                        -u) cd_upload "SHOW" $2 ; cd_doflag="FALSE" ;;
275&nbsp;                        -F) cd_fsave "NOSHOW" $2 ; cd_doflag="FALSE" ;;
276&nbsp;                        -U) cd_upload "NOSHOW" $2 ; cd_doflag="FALSE" ;;
277&nbsp;                        -g) cd_npwd="$2" ;;
278&nbsp;                        -d) cd_chdefm 1; cd_doflag="FALSE" ;;
279&nbsp;                        -D) cd_chdefm 0; cd_doflag="FALSE" ;;
280&nbsp;                        -r) cd_npwd="$2" ; cd_specDir=0 ; cd_doselection "$1" "$2";;
281&nbsp;                        -R) cd_npwd="$2" ; CDS[0]=`pwd` ; cd_doselection "$1" "$2";;
282&nbsp;                        -s) cd_npwd="${CDS[0]}" ;;
283&nbsp;                        -S) cd_npwd="${CDS[0]}"  ; CDS[0]=`pwd` ;;
284&nbsp;                        -v) cd_version ; cd_doflag="FALSE";;
285&nbsp;                esac
286&nbsp;        fi
287&nbsp;}
288&nbsp;
289&nbsp;cd_chdefm ()
290&nbsp;{
291&nbsp;        if ${TEST} "${CD_MODE}" = "PREV"
292&nbsp;        then
293&nbsp;                CD_MODE=""
294&nbsp;                if ${TEST} $1 -eq 1
295&nbsp;                then
296&nbsp;                        ${PRINTF} "${cd_mset}"
297&nbsp;                fi
298&nbsp;        else
299&nbsp;                CD_MODE="PREV"
300&nbsp;                if ${TEST} $1 -eq 1
301&nbsp;                then
302&nbsp;                        ${PRINTF} "${cd_mnset}"
303&nbsp;                fi
304&nbsp;        fi
305&nbsp;}
306&nbsp;
307&nbsp;cd_fsave ()
308&nbsp;{
309&nbsp;        local sfile=${CDPath}${2:-"$CDFile"}
310&nbsp;        if ${TEST} "$1" = "SHOW"
311&nbsp;        then
312&nbsp;                ${PRINTF} "Saved to %s\n" $sfile
313&nbsp;        fi
314&nbsp;        ${RM} -f ${sfile}
315&nbsp;        local -i count=0
316&nbsp;        while ${TEST} ${count} -le ${cd_maxhistory}
317&nbsp;        do
318&nbsp;                echo "CD[$count]=\"${CD[$count]}\"" &#62;&#62; ${sfile}
319&nbsp;                count=${count}+1
320&nbsp;        done
321&nbsp;        count=0
322&nbsp;        while ${TEST} ${count} -le ${cd_maxspecial}
323&nbsp;        do
324&nbsp;                echo "CDS[$count]=\"${CDS[$count]}\"" &#62;&#62; ${sfile}
325&nbsp;                count=${count}+1
326&nbsp;        done
327&nbsp;}
328&nbsp;
329&nbsp;cd_upload ()
330&nbsp;{
331&nbsp;        local sfile=${CDPath}${2:-"$CDFile"}
332&nbsp;        if ${TEST} "${1}" = "SHOW"
333&nbsp;        then
334&nbsp;                ${PRINTF} "Loading from %s\n" ${sfile}
335&nbsp;        fi
336&nbsp;        . ${sfile}
337&nbsp;}
338&nbsp;
339&nbsp;cd_new ()
340&nbsp;{
341&nbsp;    local -i count
342&nbsp;    local -i choose=0
343&nbsp;
344&nbsp;        cd_npwd="${1}"
345&nbsp;        cd_specDir=-1
346&nbsp;        cd_doselection "${1}" "${2}"
347&nbsp;
348&nbsp;        if ${TEST} ${cd_doflag} = "TRUE"
349&nbsp;        then
350&nbsp;                if ${TEST} "${CD[0]}" != "`pwd`"
351&nbsp;                then
352&nbsp;                        count=$cd_maxhistory
353&nbsp;                        while ${TEST} $count -gt 0
354&nbsp;                        do
355&nbsp;                                CD[$count]=${CD[$count-1]}
356&nbsp;                                count=${count}-1
357&nbsp;                        done
358&nbsp;                        CD[0]=`pwd`
359&nbsp;                fi
360&nbsp;                command cd "${cd_npwd}" 2&#62;/dev/null
361&nbsp;        if ${TEST} $? -eq 1
362&nbsp;        then
363&nbsp;            ${PRINTF} "Unknown dir: %s\n" "${cd_npwd}"
364&nbsp;            local -i ftflag=0
365&nbsp;            for i in "${cd_npwd}"*
366&nbsp;            do
367&nbsp;                if ${TEST} -d "${i}"
368&nbsp;                then
369&nbsp;                    if ${TEST} ${ftflag} -eq 0
370&nbsp;                    then
371&nbsp;                        ${PRINTF} "Suggest:\n"
372&nbsp;                        ftflag=1
373&nbsp;                fi
374&nbsp;                    ${PRINTF} "\t-a${choose} %s\n" "$i"
375&nbsp;                                        cd_sugg[$choose]="${i}"
376&nbsp;                    choose=${choose}+1
377&nbsp;        fi
378&nbsp;            done
379&nbsp;        fi
380&nbsp;        fi
381&nbsp;
382&nbsp;        if ${TEST} ${cd_specDir} -ne -1
383&nbsp;        then
384&nbsp;                CDS[${cd_specDir}]=`pwd`
385&nbsp;        fi
386&nbsp;
387&nbsp;        if ${TEST} ! -z "${CDL_PROMPTLEN}"
388&nbsp;        then
389&nbsp;        cd_right_trunc "${PWD}" ${CDL_PROMPTLEN}
390&nbsp;            cd_rp=${CDL_PROMPT_PRE}${tcd}${CDL_PROMPT_POST}
391&nbsp;                export PS1="$(echo -ne ${cd_rp})"
392&nbsp;        fi
393&nbsp;}
394&nbsp;#################################################################################
395&nbsp;#                                                                               #
396&nbsp;#                            Initialisation here                                #
397&nbsp;#                                                                               #
398&nbsp;#################################################################################
399&nbsp;#
400&nbsp;VERSION_MAJOR="1"
401&nbsp;VERSION_MINOR="2.1"
402&nbsp;VERSION_DATE="24-MAY-2003"
403&nbsp;#
404&nbsp;alias cd=cd_new
405&nbsp;#
406&nbsp;# Set up commands
407&nbsp;RM=/bin/rm
408&nbsp;TEST=test
409&nbsp;PRINTF=printf              # Use builtin printf
410&nbsp;
411&nbsp;#################################################################################
412&nbsp;#                                                                               #
413&nbsp;# Change this to modify the default pre- and post prompt strings.               #
414&nbsp;# These only come into effect if CDL_PROMPTLEN is set.                          #
415&nbsp;#                                                                               #
416&nbsp;#################################################################################
417&nbsp;if ${TEST} ${EUID} -eq 0
418&nbsp;then
419&nbsp;#   CDL_PROMPT_PRE=${CDL_PROMPT_PRE:="$HOSTNAME@"}
420&nbsp;    CDL_PROMPT_PRE=${CDL_PROMPT_PRE:="\\[\\e[01;31m\\]"}    # Root is in red
421&nbsp;    CDL_PROMPT_POST=${CDL_PROMPT_POST:="\\[\\e[00m\\]#"}
422&nbsp;else
423&nbsp;    CDL_PROMPT_PRE=${CDL_PROMPT_PRE:="\\[\\e[01;34m\\]"}    # Users in blue
424&nbsp;    CDL_PROMPT_POST=${CDL_PROMPT_POST:="\\[\\e[00m\\]$"}
425&nbsp;fi
426&nbsp;#################################################################################
427&nbsp;#
428&nbsp;# cd_maxhistory defines the max number of history entries allowed.
429&nbsp;typeset -i cd_maxhistory=50
430&nbsp;
431&nbsp;#################################################################################
432&nbsp;#
433&nbsp;# cd_maxspecial defines the number of special entries.
434&nbsp;typeset -i cd_maxspecial=9
435&nbsp;#
436&nbsp;#
437&nbsp;#################################################################################
438&nbsp;#
439&nbsp;# cd_histcount defines the number of entries displayed in the history command.
440&nbsp;typeset -i cd_histcount=9
441&nbsp;#
442&nbsp;#################################################################################
443&nbsp;export CDPath=${HOME}/
444&nbsp;#  Change these to use a different                                              #
445&nbsp;#+ default path and filename                                                    #
446&nbsp;export CDFile=${CDFILE:=cdfile}                   # for the -u and -f commands  #
447&nbsp;#
448&nbsp;#################################################################################
449&nbsp;                                                                                #
450&nbsp;typeset -i cd_lchar cd_rchar cd_flchar
451&nbsp;                               #  This is the number of chars to allow for the  #
452&nbsp;cd_flchar=${FLCHAR:=75}        #+ cd_flchar is used for for the @s &#38; @h history #
453&nbsp;
454&nbsp;typeset -ax CD CDS
455&nbsp;#
456&nbsp;cd_mset="\n\tDefault mode is now set - entering cd with no parameters has the default action\n\tUse cd -d or -D for cd to go to previous directory with no parameters\n"
457&nbsp;cd_mnset="\n\tNon-default mode is now set - entering cd with no parameters is the same as entering cd 0\n\tUse cd -d or -D to change default cd action\n"
458&nbsp;
459&nbsp;# ==================================================================== #
460&nbsp;
461&nbsp;
462&nbsp;
463&nbsp;: &#60;&#60;DOCUMENTATION
464&nbsp;
465&nbsp;Written by Phil Braham. Realtime Software Pty Ltd.
466&nbsp;Released under GNU license. Free to use. Please pass any modifications
467&nbsp;or comments to the author Phil Braham:
468&nbsp;
469&nbsp;realtime@mpx.com.au
470&nbsp;===============================================================================
471&nbsp;
472&nbsp;cdll is a replacement for cd and incorporates similar functionality to
473&nbsp;the bash pushd and popd commands but is independent of them.
474&nbsp;
475&nbsp;This version of cdll has been tested on Linux using Bash. It will work
476&nbsp;on most Linux versions but will probably not work on other shells without
477&nbsp;modification.
478&nbsp;
479&nbsp;Introduction
480&nbsp;============
481&nbsp;
482&nbsp;cdll allows easy moving about between directories. When changing to a new
483&nbsp;directory the current one is automatically put onto a stack. By default
484&nbsp;50 entries are kept, but this is configurable. Special directories can be
485&nbsp;kept for easy access - by default up to 10, but this is configurable. The
486&nbsp;most recent stack entries and the special entries can be easily viewed.
487&nbsp;
488&nbsp;The directory stack and special entries can be saved to, and loaded from,
489&nbsp;a file. This allows them to be set up on login, saved before logging out
490&nbsp;or changed when moving project to project.
491&nbsp;
492&nbsp;In addition, cdll provides a flexible command prompt facility that allows,
493&nbsp;for example, a directory name in colour that is truncated from the left
494&nbsp;if it gets too long.
495&nbsp;
496&nbsp;
497&nbsp;Setting up cdll
498&nbsp;===============
499&nbsp;
500&nbsp;Copy cdll to either your local home directory or a central directory
501&nbsp;such as /usr/bin (this will require root access).
502&nbsp;
503&nbsp;Copy the file cdfile to your home directory. It will require read and
504&nbsp;write access. This a default file that contains a directory stack and
505&nbsp;special entries.
506&nbsp;
507&nbsp;To replace the cd command you must add commands to your login script.
508&nbsp;The login script is one or more of:
509&nbsp;
510&nbsp;    /etc/profile
511&nbsp;    ~/.bash_profile
512&nbsp;    ~/.bash_login
513&nbsp;    ~/.profile
514&nbsp;    ~/.bashrc
515&nbsp;    /etc/bash.bashrc.local
516&nbsp;    
517&nbsp;To setup your login, ~/.bashrc is recommended, for global (and root) setup
518&nbsp;add the commands to /etc/bash.bashrc.local
519&nbsp;    
520&nbsp;To set up on login, add the command:
521&nbsp;    . &#60;dir&#62;/cdll
522&nbsp;For example if cdll is in your local home directory:
523&nbsp;    . ~/cdll
524&nbsp;If in /usr/bin then:
525&nbsp;    . /usr/bin/cdll
526&nbsp;
527&nbsp;If you want to use this instead of the buitin cd command then add:
528&nbsp;    alias cd='cd_new'
529&nbsp;We would also recommend the following commands:
530&nbsp;    alias @='cd_new @'
531&nbsp;    cd -U
532&nbsp;    cd -D
533&nbsp;
534&nbsp;If you want to use cdll's prompt facilty then add the following:
535&nbsp;    CDL_PROMPTLEN=nn
536&nbsp;Where nn is a number described below. Initially 99 would be suitable
537&nbsp;number.
538&nbsp;
539&nbsp;Thus the script looks something like this:
540&nbsp;
541&nbsp;    ######################################################################
542&nbsp;    # CD Setup
543&nbsp;    ######################################################################
544&nbsp;    CDL_PROMPTLEN=21        # Allow a prompt length of up to 21 characters
545&nbsp;    . /usr/bin/cdll         # Initialise cdll
546&nbsp;    alias cd='cd_new'       # Replace the built in cd command
547&nbsp;    alias @='cd_new @'      # Allow @ at the prompt to display history
548&nbsp;    cd -U                   # Upload directories
549&nbsp;    cd -D                   # Set default action to non-posix
550&nbsp;    ######################################################################
551&nbsp;
552&nbsp;The full meaning of these commands will become clear later.
553&nbsp;
554&nbsp;There are a couple of caveats. If another program changes the directory
555&nbsp;without calling cdll, then the directory won't be put on the stack and
556&nbsp;also if the prompt facility is used then this will not be updated. Two
557&nbsp;programs that can do this are pushd and popd. To update the prompt and
558&nbsp;stack simply enter:
559&nbsp;
560&nbsp;    cd .
561&nbsp;    
562&nbsp;Note that if the previous entry on the stack is the current directory
563&nbsp;then the stack is not updated.
564&nbsp;
565&nbsp;Usage
566&nbsp;=====  
567&nbsp;cd [dir] [0-9] [@[s|h] [-g &#60;dir&#62;] [-d] [-D] [-r&#60;n&#62;] [dir|0-9] [-R&#60;n&#62;]
568&nbsp;   [&#60;dir&#62;|0-9] [-s&#60;n&#62;] [-S&#60;n&#62;] [-u] [-U] [-f] [-F] [-h] [-H] [-v]
569&nbsp;
570&nbsp;    &#60;dir&#62;       Go to directory
571&nbsp;    0-n         Goto previous directory (0 is previous, 1 is last but 1, etc.)
572&nbsp;                n is up to max history (default is 50)
573&nbsp;    @           List history and special entries (Usually available as $ @)
574&nbsp;    @h          List history entries
575&nbsp;    @s          List special entries
576&nbsp;    -g [&#60;dir&#62;]  Go to literal name (bypass special names)
577&nbsp;                This is to allow access to dirs called '0','1','-h' etc
578&nbsp;    -d          Change default action - verbose. (See note)
579&nbsp;    -D          Change default action - silent. (See note)
580&nbsp;    -s&#60;n&#62;       Go to the special entry &#60;n&#62;
581&nbsp;    -S&#60;n&#62;       Go to the special entry &#60;n&#62; and replace it with the current dir
582&nbsp;    -r&#60;n&#62; [&#60;dir&#62;] Go to directory &#60;dir&#62; and then put it on special entry &#60;n&#62;
583&nbsp;    -R&#60;n&#62; [&#60;dir&#62;] Go to directory &#60;dir&#62; and put current dir on special entry &#60;n&#62;
584&nbsp;    -a&#60;n&#62;       Alternative suggested directory. See note below.
585&nbsp;    -f [&#60;file&#62;] File entries to &#60;file&#62;.
586&nbsp;    -u [&#60;file&#62;] Update entries from &#60;file&#62;.
587&nbsp;                If no filename supplied then default file (~/cdfile) is used
588&nbsp;                -F and -U are silent versions
589&nbsp;    -v          Print version number
590&nbsp;    -h          Help
591&nbsp;    -H          Detailed help
592&nbsp;
593&nbsp;
594&nbsp;
595&nbsp;Examples
596&nbsp;========
597&nbsp;
598&nbsp;These examples assume non-default mode is set (that is, cd with no
599&nbsp;parameters will go to the most recent stack directory), that aliases
600&nbsp;have been set up for cd and @ as described above and that cd's prompt
601&nbsp;facility is active and the prompt length is 21 characters.
602&nbsp;
603&nbsp;    /home/phil$ @                                                   # List the entries with the @
604&nbsp;    History:                                                        # Output of the @ command
605&nbsp;    .....                                                           # Skipped these entries for brevity
606&nbsp;    1 /home/phil/ummdev               S1 /home/phil/perl            # Most recent two history entries
607&nbsp;    0 /home/phil/perl/eg              S0 /home/phil/umm/ummdev      # and two special entries are shown
608&nbsp;    
609&nbsp;    /home/phil$ cd /home/phil/utils/Cdll                            # Now change directories
610&nbsp;    /home/phil/utils/Cdll$ @                                        # Prompt reflects the directory.
611&nbsp;    History:                                                        # New history
612&nbsp;    .....   
613&nbsp;    1 /home/phil/perl/eg              S1 /home/phil/perl            # History entry 0 has moved to 1
614&nbsp;    0 /home/phil                      S0 /home/phil/umm/ummdev      # and the most recent has entered
615&nbsp;       
616&nbsp;To go to a history entry:
617&nbsp;
618&nbsp;    /home/phil/utils/Cdll$ cd 1                                     # Go to history entry 1.
619&nbsp;    /home/phil/perl/eg$                                             # Current directory is now what was 1
620&nbsp;    
621&nbsp;To go to a special entry:
622&nbsp;
623&nbsp;    /home/phil/perl/eg$ cd -s1                                      # Go to special entry 1
624&nbsp;    /home/phil/umm/ummdev$                                          # Current directory is S1
625&nbsp;
626&nbsp;To go to a directory called, for example, 1:
627&nbsp;
628&nbsp;    /home/phil$ cd -g 1                                             # -g ignores the special meaning of 1
629&nbsp;    /home/phil/1$
630&nbsp;    
631&nbsp;To put current directory on the special list as S1:
632&nbsp;    cd -r1 .        #  OR
633&nbsp;    cd -R1 .        #  These have the same effect if the directory is
634&nbsp;                    #+ . (the current directory)
635&nbsp;
636&nbsp;To go to a directory and add it as a special  
637&nbsp;    The directory for -r&#60;n&#62; or -R&#60;n&#62; may be a number. For example:
638&nbsp;        $ cd -r3 4  Go to history entry 4 and put it on special entry 3
639&nbsp;        $ cd -R3 4  Put current dir on the special entry 3 and go to
640&nbsp;                    history entry 4
641&nbsp;        $ cd -s3    Go to special entry 3
642&nbsp;
643&nbsp;    Note that commands R,r,S and s may be used without a number and
644&nbsp;    refer to 0:
645&nbsp;        $ cd -s     Go to special entry 0
646&nbsp;        $ cd -S     Go to special entry 0 and make special entry 0
647&nbsp;                    current dir
648&nbsp;        $ cd -r 1   Go to history entry 1 and put it on special entry 0
649&nbsp;        $ cd -r     Go to history entry 0 and put it on special entry 0
650&nbsp;
651&nbsp;
652&nbsp;    Alternative suggested directories:
653&nbsp;
654&nbsp;    If a directory is not found, then CD will suggest any
655&nbsp;    possibilities. These are directories starting with the same letters
656&nbsp;    and if any are found they are listed prefixed with -a&#60;n&#62;
657&nbsp;    where &#60;n&#62; is a number. It's possible to go to the directory
658&nbsp;    by entering cd -a&#60;n&#62; on the command line.
659&nbsp;
660&nbsp;        Use cd -d or -D to change default cd action. cd -H will show
661&nbsp;        current action.
662&nbsp;
663&nbsp;        The history entries (0-n) are stored in the environment variables
664&nbsp;        CD[0] - CD[n]
665&nbsp;        Similarly the special directories S0 - 9 are in the environment
666&nbsp;        variable CDS[0] - CDS[9]
667&nbsp;        and may be accessed from the command line, for example:
668&nbsp;        
669&nbsp;            ls -l ${CDS[3]}
670&nbsp;            cat ${CD[8]}/file.txt
671&nbsp;
672&nbsp;        The default pathname for the -f and -u commands is ~
673&nbsp;        The default filename for the -f and -u commands is cdfile
674&nbsp;
675&nbsp;
676&nbsp;Configuration
677&nbsp;=============
678&nbsp;
679&nbsp;    The following environment variables can be set:
680&nbsp;    
681&nbsp;        CDL_PROMPTLEN  - Set to the length of prompt you require.
682&nbsp;            Prompt string is set to the right characters of the current
683&nbsp;            directory. If not set, then prompt is left unchanged. Note
684&nbsp;            that this is the number of characters that the directory is
685&nbsp;            shortened to, not the total characters in the prompt.
686&nbsp;
687&nbsp;            CDL_PROMPT_PRE - Set to the string to prefix the prompt.
688&nbsp;                Default is:
689&nbsp;                    non-root:  "\\[\\e[01;34m\\]"  (sets colour to blue).
690&nbsp;                    root:      "\\[\\e[01;31m\\]"  (sets colour to red).
691&nbsp;
692&nbsp;            CDL_PROMPT_POST    - Set to the string to suffix the prompt.
693&nbsp;                Default is:
694&nbsp;                    non-root:  "\\[\\e[00m\\]$"    (resets colour and displays $).
695&nbsp;                    root:      "\\[\\e[00m\\]#"    (resets colour and displays #).
696&nbsp;
697&nbsp;        Note:
698&nbsp;            CDL_PROMPT_PRE &#38; _POST only t
699&nbsp;
700&nbsp;        CDPath - Set the default path for the -f &#38; -u options.
701&nbsp;                 Default is home directory
702&nbsp;        CDFile - Set the default filename for the -f &#38; -u options.
703&nbsp;                 Default is cdfile
704&nbsp;
705&nbsp;
706&nbsp;    There are three variables defined in the file cdll which control the
707&nbsp;    number of entries stored or displayed. They are in the section labeled
708&nbsp;    'Initialisation here' towards the end of the file.
709&nbsp;
710&nbsp;        cd_maxhistory       - The number of history entries stored.
711&nbsp;                              Default is 50.
712&nbsp;        cd_maxspecial       - The number of special entries allowed.
713&nbsp;                              Default is 9.
714&nbsp;        cd_histcount        - The number of history and special entries
715&nbsp;                              displayed. Default is 9.
716&nbsp;
717&nbsp;    Note that cd_maxspecial should be &#62;= cd_histcount to avoid displaying
718&nbsp;    special entries that can't be set.
719&nbsp;
720&nbsp;
721&nbsp;Version: 1.2.1 Date: 24-MAY-2003
722&nbsp;
723&nbsp;DOCUMENTATION</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="biblio.html"
ACCESSKEY="P"
>前一页</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>首页</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="refcards.html"
ACCESSKEY="N"
>下一页</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>参考文献</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>参考卡片</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
